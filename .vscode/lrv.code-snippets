{
    "bit": {
        "scope": "cpp",
        "prefix": [
            "lrv_bit"
        ],
        "body": [
            "template <class T> struct BIT {",
            "    vector<T> s;",
            "    BIT() {}",
            "    /**",
            "     * @param n initial size",
            "     * @time O(n)",
            "     * @space O(n) for `s` vector",
            "     */",
            "    BIT(int n) : s(n) {}",
            "    /**",
            "     * @param a initial array",
            "     * @time O(n)",
            "     * @space O(n) for `s` vector",
            "     */",
            "    BIT(const vector<T>& a) : s(a) {",
            "        for (int i = 0; i < sz(a); i++) {",
            "            int j = i | (i + 1);",
            "            if (j < sz(a)) s[j] += s[i];",
            "        }",
            "    }",
            "    /**",
            "     * @param i index",
            "     * @param d delta",
            "     * @time O(log n)",
            "     * @space O(1)",
            "     */",
            "    inline void update(int i, T d) {",
            "        assert(0 <= i && i < sz(s));",
            "        for (; i < sz(s); i |= i + 1) s[i] += d;",
            "    }",
            "    /**",
            "     * @param ri defines range [0, ri)",
            "     * @returns a[0] + a[1] + ... + a[ri - 1]",
            "     * @time O(log n)",
            "     * @space O(1)",
            "     */",
            "    inline T sum(int ri) {",
            "        assert(0 <= ri && ri <= sz(s));",
            "        T ret = 0;",
            "        for (; ri > 0; ri &= ri - 1) ret += s[ri - 1];",
            "        return ret;",
            "    }",
            "    /**",
            "     * @param le,ri defines range [le, ri)",
            "     * @returns a[le] + a[le + 1] + ... + a[ri - 1]",
            "     * @time O(log n)",
            "     * @space O(1)",
            "     */",
            "    inline T sum(int le, int ri) {",
            "        assert(le <= ri);",
            "        return sum(ri) - sum(le);",
            "    }",
            "};"
        ],
        "description": ""
    },
    "rmq": {
        "scope": "cpp",
        "prefix": [
            "lrv_rmq"
        ],
        "body": [
            "template <class T, class F> struct RMQ {",
            "    vector<vector<T>> dp;",
            "    F op;",
            "    RMQ() {}",
            "    /**",
            "     * @param a static array",
            "     * @param a_op any associative, communative, idempotent operation",
            "     * @time O(n log n)",
            "     * @space O(n log n) for `dp` vector",
            "     */",
            "    RMQ(const vector<T>& a, F a_op) : dp(1, a), op(a_op) {",
            "        for (int i = 0; (2 << i) <= sz(a); i++) {",
            "            dp.emplace_back(sz(a) - (2 << i) + 1);",
            "            transform(begin(dp[i]), end(dp[i]) - (1 << i), begin(dp[i]) + (1 << i), begin(dp[i + 1]), op);",
            "        }",
            "    }",
            "    /**",
            "     * @param le,ri defines range [le, ri)",
            "     * @returns a[le] op a[le + 1] op ... op a[ri - 1]",
            "     * @time O(1)",
            "     * @space O(1)",
            "     */",
            "    inline T query(int le, int ri) {",
            "        assert(0 <= le && le < ri && ri <= sz(dp[0]));",
            "        int lg = __lg(ri - le);",
            "        return op(dp[lg][le], dp[lg][ri - (1 << lg)]);",
            "    }",
            "};",
            "#if 0",
            "vector<long long> a;",
            "RMQ rmq(a, ranges::min); // -std=c++20",
            "RMQ rmq(a, [&](auto& x, auto& y) { return min(x, y); });",
            "#endif"
        ],
        "description": ""
    },
    "seg_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_seg_tree"
        ],
        "body": [
            "inline int split(int tl, int tr) {",
            "    int pw2 = 1 << __lg(tr - tl);",
            "    return min(tl + pw2, tr - pw2 / 2);",
            "}",
            "inline long long op(long long vl, long long vr) {",
            "    return vl + vr;",
            "}",
            "struct seg_tree {",
            "    int n;",
            "    vector<long long> tree, lazy;",
            "    seg_tree(int a_n) : n(a_n), tree(2 * n), lazy(n) {}",
            "    seg_tree(const vector<int>& a) : n(sz(a)), tree(2 * n), lazy(n) {",
            "        int pw2 = 1;",
            "        while (pw2 < n) pw2 *= 2;",
            "        for (int i = 0; i < n; i++) tree[(i + pw2) % n + n] = a[i];",
            "        for (int i = n - 1; i >= 1; i--) tree[i] = op(tree[2 * i], tree[2 * i + 1]);",
            "    }",
            "    inline void apply(long long change, int tl, int tr, int u) {",
            "        tree[u] += (tr - tl) * change;",
            "        if (u < n) lazy[u] += change;",
            "    }",
            "    inline void push(int tl, int tm, int tr, int u) {",
            "        if (lazy[u]) {",
            "            apply(lazy[u], tl, tm, 2 * u);",
            "            apply(lazy[u], tm, tr, 2 * u + 1);",
            "            lazy[u] = 0;",
            "        }",
            "    }",
            "    /**",
            "     * @param le,ri defines range [le, ri)",
            "     */",
            "    void update(int le, int ri, long long change) {update(le, ri, change, 0, n, 1);}",
            "    void update(int le, int ri, long long change, int tl, int tr, int u) {",
            "        if (ri <= tl || tr <= le) return;",
            "        if (le <= tl && tr <= ri) return apply(change, tl, tr, u);",
            "        int tm = split(tl, tr);",
            "        push(tl, tm, tr, u);",
            "        update(le, ri, change, tl, tm, 2 * u);",
            "        update(le, ri, change, tm, tr, 2 * u + 1);",
            "        tree[u] = op(tree[2 * u], tree[2 * u + 1]);",
            "    }",
            "    /**",
            "     * @param le,ri defines range [le, ri)",
            "     */",
            "    long long query(int le, int ri) {return query(le, ri, 0, n, 1);}",
            "    long long query(int le, int ri, int tl, int tr, int u) {",
            "        if (ri <= tl || tr <= le) return 0;",
            "        if (le <= tl && tr <= ri) return tree[u];",
            "        int tm = split(tl, tr);",
            "        push(tl, tm, tr, u);",
            "        return op(query(le, ri, tl, tm, 2 * u),",
            "                  query(le, ri, tm, tr, 2 * u + 1));",
            "    }",
            "};"
        ],
        "description": ""
    },
    "knuth_morris_pratt": {
        "scope": "cpp",
        "prefix": [
            "lrv_knuth_morris_pratt"
        ],
        "body": [
            "template <class T> struct KMP {",
            "    T needle;",
            "    vector<int> pi;",
            "    /**",
            "     * @param a_needle string to be searched for inside haystack",
            "     * @time O(|needle|)",
            "     * @space O(|needle|) for `needle` and `pi` arrays",
            "     */",
            "    KMP(const T& a_needle) : needle(a_needle), pi(prefix_function(needle)) {}",
            "    /**",
            "     * @param haystack usually |needle| <= |haystack|",
            "     * @returns array `matches` where:",
            "     * haystack.substr(matches[i], sz(needle)) == needle",
            "     * @time O(|haystack|)",
            "     * @space besides O(|haystack|) param, this function allocates/returns an",
            "     * array of size (# matches), at worst O(|haystack|)",
            "     */",
            "    vector<int> find_str(const T& haystack) {",
            "        vector<int> matches;",
            "        for (int i = 0, j = 0; i < sz(haystack); i++) {",
            "            while (j > 0 && needle[j] != haystack[i]) j = pi[j - 1];",
            "            j += (needle[j] == haystack[i]);",
            "            if (j == sz(needle)) {",
            "                matches.push_back(i - sz(needle) + 1);",
            "                j = pi[j - 1];",
            "            }",
            "        }",
            "        return matches;",
            "    }",
            "};",
            "#if 0",
            "string s;",
            "KMP kmp(s);",
            "vector<int> a;",
            "KMP kmp(a);",
            "#endif"
        ],
        "description": ""
    },
    "trie": {
        "scope": "cpp",
        "prefix": [
            "lrv_trie"
        ],
        "body": [
            "const int mn = 'A', max_val = 26; // mn <= s[i] < mn + max_val",
            "struct trie {",
            "    struct node {",
            "        array<int, max_val> next;",
            "        int cnt_words = 0, par = -1;",
            "        char ch;",
            "        node(int a_par = -1, char a_ch = '#') : par(a_par), ch(a_ch) {",
            "            fill(begin(next), end(next), -1);",
            "        }",
            "    };",
            "    vector<node> t;",
            "    trie() : t(1) {}",
            "    void insert(const string& s) {",
            "        int u = 0;",
            "        for (char ch : s) {",
            "            int v = ch - mn;",
            "            if (t[u].next[v] == -1) {",
            "                t[u].next[v] = sz(t);",
            "                t.emplace_back(u, ch);",
            "            }",
            "            u = t[u].next[v];",
            "        }",
            "        t[u].cnt_words++;",
            "    }",
            "    int find(const string& s) {",
            "        int u = 0;",
            "        for (char ch : s) {",
            "            int v = ch - mn;",
            "            if (t[u].next[v] == -1) return 0;",
            "            u = t[u].next[v];",
            "        }",
            "        return t[u].cnt_words;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "prefix_function": {
        "scope": "cpp",
        "prefix": [
            "lrv_prefix_function"
        ],
        "body": [
            "template <class T> vector<int> prefix_function(const T& s) {",
            "    vector<int> pi(sz(s));",
            "    for (int i = 1; i < sz(s); i++) {",
            "        int j = pi[i - 1];",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];",
            "        pi[i] = j + (s[i] == s[j]);",
            "    }",
            "    return pi;",
            "}"
        ],
        "description": ""
    },
    "count_rectangles": {
        "scope": "cpp",
        "prefix": [
            "lrv_count_rectangles"
        ],
        "body": [
            "vector<vector<int>> count_rectangles(const vector<vector<bool>>& grid) {",
            "    int n = sz(grid), m = sz(grid[0]);",
            "    vector cnt(n + 1, vector(m + 1, 0));",
            "    vector<int> h(m);",
            "    for (const auto& row : grid) {",
            "        transform(begin(h), end(h), begin(row), begin(h), [](int a, bool g) {",
            "            return g * (a + 1);",
            "        });",
            "        auto ri = mono_st(h, less()), le = mono_range(ri);",
            "        for (int j = 0; j < m; j++) {",
            "            int cnt_l = j - le[j] - 1, cnt_r = ri[j] - j - 1;",
            "            cnt[h[j]][cnt_l + cnt_r + 1]++;",
            "            cnt[h[j]][cnt_l]--;",
            "            cnt[h[j]][cnt_r]--;",
            "        }",
            "    }",
            "    for (int i = 1; i <= n; i++)",
            "        for (int k = 0; k < 2; k++)",
            "            for (int j = m; j > 1; j--)",
            "                cnt[i][j - 1] += cnt[i][j];",
            "    for (int i = n; i > 1; i--)",
            "        for (int j = 1; j <= m; j++)",
            "            cnt[i - 1][j] += cnt[i][j];",
            "    return cnt;",
            "}"
        ],
        "description": ""
    },
    "cartesian_k_ary_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_cartesian_k_ary_tree"
        ],
        "body": [
            "template <class T> vector<int> cart_k_ary_tree(const vector<T>& a, const vector<int>& ri) {",
            "    vector<int> p(ri);",
            "    for (int i = 0; i < sz(a); i++)",
            "        for (int j = i + 1; j != ri[i]; j = ri[j])",
            "            if (ri[j] == ri[i] || a[i] == a[ri[j]])",
            "                p[j] = (p[i] > i || a[i] != a[p[i]] ? i : p[i]);",
            "    return p;",
            "}",
            "#if 0",
            "auto ri = mono_st(a, less_equal()), p = cart_k_ary_tree(a, ri); // min cart tree",
            "auto ri = mono_st(a, greater_equal()), p = cart_k_ary_tree(a, ri); // max cart tree",
            "bool is_node = (p[i] > i || a[i] != a[p[i]]);",
            "#endif"
        ],
        "description": ""
    },
    "monotonic_range": {
        "scope": "cpp",
        "prefix": [
            "lrv_monotonic_range"
        ],
        "body": [
            "vector<int> mono_range(const vector<int>& ri) {",
            "    vector le(sz(ri), -1);",
            "    for (int i = 0; i < sz(ri); i++)",
            "        for (int j = i + 1; j != ri[i]; j = ri[j]) le[j] = i;",
            "    return le;",
            "}",
            "#if 0",
            "vector<long long> a;",
            "auto ri = mono_st(a, less()), le = mono_range(ri); // greater(), less_equal(), greater_equal()",
            "#endif"
        ],
        "description": ""
    },
    "cartesian_binary_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_cartesian_binary_tree"
        ],
        "body": [
            "vector<int> cart_binary_tree(const vector<int>& ri) {",
            "    vector<int> p(ri);",
            "    for (int i = 0; i < sz(p); i++)",
            "        for (int j = i + 1; j != ri[i]; j = ri[j])",
            "            if (ri[j] == ri[i]) p[j] = i;",
            "    return p;",
            "}",
            "#if 0",
            "auto ri = mono_st(a, less()), p = cart_binary_tree(ri); // right-most min is root",
            "auto ri = mono_st(a, less_equal()), p = cart_binary_tree(ri); // left-most min is root",
            "auto ri = mono_st(a, greater()), p = cart_binary_tree(ri); // right-most max is root",
            "auto ri = mono_st(a, greater_equal()), p = cart_binary_tree(ri); // left-most max is root",
            "#endif"
        ],
        "description": ""
    },
    "max_rect_histogram": {
        "scope": "cpp",
        "prefix": [
            "lrv_max_rect_histogram"
        ],
        "body": [
            "long long max_rect_histogram(const vector<int>& a) {",
            "    auto ri = mono_st(a, less()), le = mono_range(ri);",
            "    auto max_area = 0LL;",
            "    for (int i = 0; i < sz(a); i++)",
            "        max_area = max(max_area, 1LL * a[i] * (ri[i] - le[i] - 1));",
            "    return max_area;",
            "}"
        ],
        "description": ""
    },
    "monotonic_stack": {
        "scope": "cpp",
        "prefix": [
            "lrv_monotonic_stack"
        ],
        "body": [
            "template <class T, class F> vector<int> mono_st(const vector<T>& a, F cmp) {",
            "    vector<int> ri(sz(a));",
            "    for (int i = sz(a) - 1; i >= 0; i--)",
            "        for (ri[i] = i + 1; ri[i] < sz(a) && cmp(a[i], a[ri[i]]);) ri[i] = ri[ri[i]];",
            "    return ri;",
            "}",
            "#if 0",
            "vector<long long> a;",
            "auto ri = mono_st(a, less()); // greater(), less_equal(), greater_equal()",
            "for (int i = n - 1; i >= 0; i--)",
            "for (int j = i + 1; j != ri[i]; j = ri[j])",
            "// for all k in [j, ri[j]): cmp(a[i], a[k])",
            "// these ranges are disjoint, and union to [i + 1, ri[i])",
            "#endif"
        ],
        "description": ""
    },
    "partitions": {
        "scope": "cpp",
        "prefix": [
            "lrv_partitions"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "vector<long long> partitions(int n) {",
            "    vector dp(n, 1LL);",
            "    for (int i = 1; i < n; i++) {",
            "        auto sum = 0LL;",
            "        for (int j = 1, pent = 1, sign = 1; pent <= i; j++, pent += 3 * j - 2, sign = -sign) {",
            "            if (pent + j <= i) sum += dp[i - pent - j] * sign + mod;",
            "            sum += dp[i - pent] * sign + mod;",
            "        }",
            "        dp[i] = sum % mod;",
            "    }",
            "    return dp;",
            "}"
        ],
        "description": ""
    },
    "num_distinct_subsequences": {
        "scope": "cpp",
        "prefix": [
            "lrv_num_distinct_subsequences"
        ],
        "body": [
            "int num_subsequences(const vector<int>& a, int mod) {",
            "    vector dp(sz(a) + 1, 1);",
            "    map<int, int> last;",
            "    for (int i = 0; i < sz(a); i++) {",
            "        int& curr = dp[i + 1] = 2 * dp[i];",
            "        if (curr >= mod) curr -= mod;",
            "        auto it = last.find(a[i]);",
            "        if (it != end(last)) {",
            "            curr -= dp[it->second];",
            "            if (curr < 0) curr += mod;",
            "            it->second = i;",
            "        } else last[a[i]] = i;",
            "    }",
            "    return dp.back();",
            "}"
        ],
        "description": ""
    },
    "binary_exponentiation_mod": {
        "scope": "cpp",
        "prefix": [
            "lrv_binary_exponentiation_mod"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "long long bin_exp(long long b, long long e) {",
            "    assert(0 <= e);",
            "    auto res = 1LL;",
            "    if ((b %= mod) < 0) b += mod;",
            "    for (; e; b = b * b % mod, e /= 2)",
            "        if (e & 1) res = res * b % mod;",
            "    return res;",
            "}"
        ],
        "description": ""
    },
    "tetration_mod": {
        "scope": "cpp",
        "prefix": [
            "lrv_tetration_mod"
        ],
        "body": [
            "long long bin_exp(long long b, long long e, int mod) {",
            "    assert(0 <= e);",
            "    auto res = 1LL;",
            "    if ((b %= mod) < 0) b += mod;",
            "    for (; e; b = b * b % mod, e /= 2)",
            "        if (e & 1) res = res * b % mod;",
            "    return res;",
            "}",
            "long long tetration(long long b, long long e, int mod) {",
            "    if (mod == 1) return 0;",
            "    if (b == 0) return (e + 1) % 2 % mod;",
            "    if (b == 1 || e == 0) return 1;",
            "    if (e == 1) return b % mod;",
            "    if (b == 2 && e == 2) return 4 % mod;",
            "    if (b == 2 && e == 3) return 16 % mod;",
            "    if (b == 3 && e == 2) return 27 % mod;",
            "    int t = totient(mod);",
            "    auto exp = tetration(b, e - 1, t);",
            "    return bin_exp(b, exp + t, mod);",
            "}"
        ],
        "description": ""
    },
    "fibonacci": {
        "scope": "cpp",
        "prefix": [
            "lrv_fibonacci"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "array<long long, 2> fib(long long n) {",
            "    if (n == 0) return {0LL, 1LL};",
            "    auto [x, y] = fib(n >> 1);",
            "    auto c = x * (2 * y - x + mod) % mod, d = (x * x + y * y) % mod;",
            "    if (n & 1) return {d, (c + d) % mod};",
            "    return {c, d};",
            "}",
            "#if 0",
            "auto val = fib(n)[0];",
            "//n=0 -> val=0",
            "//n=1 -> val=1",
            "//n=2 -> val=1",
            "//n=3 -> val=2",
            "//n=4 -> val=3",
            "//n=5 -> val=5",
            "#endif"
        ],
        "description": ""
    },
    "derangements": {
        "scope": "cpp",
        "prefix": [
            "lrv_derangements"
        ],
        "body": [
            "vector<long long> derangements(int n, int mod) {",
            "    vector dp(n, 0LL);",
            "    dp[0] = 1;",
            "    for (int i = 2; i < n; i++)",
            "        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % mod;",
            "    return dp;",
            "}"
        ],
        "description": ""
    },
    "totient": {
        "scope": "cpp",
        "prefix": [
            "lrv_totient"
        ],
        "body": [
            "int totient(int n) {",
            "    int res = n;",
            "    for (int i = 2; i * i <= n; i++)",
            "        if (n % i == 0) {",
            "            while (n % i == 0) n /= i;",
            "            res -= res / i;",
            "        }",
            "    if (n > 1) res -= res / n;",
            "    return res;",
            "}"
        ],
        "description": ""
    },
    "mobius": {
        "scope": "cpp",
        "prefix": [
            "lrv_mobius"
        ],
        "body": [
            "const int mx_n = 1'000'005;",
            "int mobius[mx_n];",
            "void calc_mobius() {",
            "    mobius[1] = 1;",
            "    for (int i = 1; i < mx_n; i++)",
            "        for (int j = i + i; j < mx_n; j += i)",
            "            mobius[j] -= mobius[i];",
            "}"
        ],
        "description": ""
    },
    "supermasks": {
        "scope": "cpp",
        "prefix": [
            "lrv_supermasks"
        ],
        "body": [
            "template <class F> void supermasks(int mask, int n, F f) {",
            "    for (int supermask = mask; supermask < (1 << n); supermask = (supermask + 1) | mask)",
            "        f(supermask);",
            "}"
        ],
        "description": ""
    },
    "chooses": {
        "scope": "cpp",
        "prefix": [
            "lrv_chooses"
        ],
        "body": [
            "inline int next_subset(int mask) {",
            "    int c = mask & -mask, r = mask + c;",
            "    return r | (((r ^ mask) >> 2) / c);",
            "}",
            "template <class F> void chooses(int n, int k, F f) {",
            "    for (int mask = (1 << k) - 1; mask < (1 << n); mask = next_subset(mask))",
            "        f(mask);",
            "}"
        ],
        "description": ""
    },
    "submasks": {
        "scope": "cpp",
        "prefix": [
            "lrv_submasks"
        ],
        "body": [
            "template <class F> void submasks(int mask, F f) {",
            "    for (int submask = mask; submask; submask = (submask - 1) & mask)",
            "        f(submask);",
            "}"
        ],
        "description": ""
    },
    "quotients": {
        "scope": "cpp",
        "prefix": [
            "lrv_quotients"
        ],
        "body": [
            "template <class F> void quotients(long long n, F f) {",
            "    for (long long le = 1, ri; le <= n; le = ri + 1) {",
            "        ri = n / (n / le);",
            "        /**",
            "         * i-th iteration gives an interval [le_i, ri_i], we have:",
            "         *     - for all i in [le_i, ri_i]: n / i has the same value",
            "         *     - le_0 = 1",
            "         *     - ri_last = n",
            "         *     - ri_i + 1 = le_(i+1)",
            "         */",
            "        f(le, ri);",
            "    }",
            "}"
        ],
        "description": ""
    },
    "enumerate_triangles": {
        "scope": "cpp",
        "prefix": [
            "lrv_enumerate_triangles"
        ],
        "body": [
            "template <class F> void enumerate_triangles(const vector<array<int, 2>>& edges, int n, F f) {",
            "    vector<int> deg(n);",
            "    for (auto [u, v] : edges) deg[u]++, deg[v]++;",
            "    vector<vector<int>> adj(n);",
            "    for (auto [u, v] : edges) {",
            "        if (tie(deg[u], u) > tie(deg[v], v)) swap(u, v);",
            "        adj[u].push_back(v);",
            "    }",
            "    vector<bool> seen(n);",
            "    for (auto [u, v] : edges) {",
            "        for (int w : adj[u]) seen[w] = 1;",
            "        for (int w : adj[v]) if (seen[w]) f(u, v, w);",
            "        for (int w : adj[u]) seen[w] = 0;",
            "    }",
            "}",
            "#if 0",
            "enumerate_triangles(edges, n, [&](int u, int v, int w) {",
            "//u, v, w form a triangle",
            "});",
            "#endif"
        ],
        "description": ""
    },
    "ladder_decomposition": {
        "scope": "cpp",
        "prefix": [
            "lrv_ladder_decomposition"
        ],
        "body": [
            "struct ladder {",
            "    int n;",
            "    vector<vector<int>> b_tbl, l_tbl;",
            "    vector<int> dl/*deepest leaf*/, d, p;",
            "    /**",
            "     * @param adj forest (rooted or unrooted)",
            "     * @time O(n log n)",
            "     * @space O(n log n) for b_tbl. Everything else is O(n)",
            "     */",
            "    ladder(const vector<vector<int>>& adj) : n(sz(adj)), l_tbl(n), dl(n), d(n), p(n, -1) {",
            "        iota(begin(dl), end(dl), 0);",
            "        for (int i = 0; i < n; i++)",
            "            if (p[i] == -1)",
            "                p[i] = i, dfs(adj, i);",
            "        b_tbl = treeJump(p);",
            "        for (int i = 0; i < n; i++)",
            "            if (p[i] == i || dl[p[i]] != dl[i]) {",
            "                int leaf = dl[i];",
            "                auto& lad = l_tbl[leaf];",
            "                lad.resize(min(2 * (d[leaf] - d[i]), d[leaf]) + 1, leaf);",
            "                for (int j = 1; j < sz(lad); j++)",
            "                    lad[j] = p[lad[j - 1]];",
            "            }",
            "    }",
            "    void dfs(const vector<vector<int>>& adj, int u) {",
            "        for (int v : adj[u])",
            "            if (v != p[u]) {",
            "                d[v] = d[p[v] = u] + 1;",
            "                dfs(adj, v);",
            "                if (d[dl[v]] > d[dl[u]]) dl[u] = dl[v];",
            "            }",
            "    }",
            "    /**",
            "     * @param u query node",
            "     * @param k number of edges",
            "     * @returns a node k edges up from u. With k=1, this returns u's parent.",
            "     * @time O(1)",
            "     * @space O(1)",
            "     */",
            "    inline int kth_par(int u, int k) {",
            "        assert(0 <= k && k <= d[u]);",
            "        if (k == 0) return u;",
            "        int bit = __lg(k);",
            "        u = b_tbl[bit][u], k -= (1 << bit);",
            "        int leaf = dl[u];",
            "        return l_tbl[leaf][k + d[leaf] - d[u]];",
            "    }",
            "};",
            "#if 0",
            "ladder ld(adj);",
            "// KACTL functions",
            "int kth_par = jmp(ld.b_tbl, u, k);",
            "int curr_lca = lca(ld.b_tbl, ld.d, u, v);",
            "#endif"
        ],
        "description": ""
    },
    "hopcroft_karp": {
        "scope": "cpp",
        "prefix": [
            "lrv_hopcroft_karp"
        ],
        "body": [
            "struct hopcroft_karp {",
            "    int size_of_matching = 0; /**< # of edges in max matching (which = size of min vertex cover by K\u00f6nig's theorem) */",
            "    /**",
            "     * edge node_left <=> l_to_r[node_left] in matching iff l_to_r[node_left] != -1",
            "     * ditto r_to_l[node_right] <=> node_right",
            "     * @{",
            "     */",
            "    vector<int> l_to_r, r_to_l;",
            "    /** @} */",
            "    /**",
            "     * mvc_l[node_left] = 1 iff node_left is in the min vertex cover; ditto mvc_r[node_right]",
            "     * mvc_l[node_left] = 0 iff node_left is in the max independent set",
            "     * @{",
            "     */",
            "    vector<bool> mvc_l, mvc_r;",
            "    /** @} */",
            "    /**",
            "     * @param adj bipartite graph",
            "     * @param rsz number of nodes on right side",
            "     * @time O(n + m * sqrt(n)) n = lsz + rsz",
            "     * @space this allocates member vectors which are O(lsz + rsz)",
            "     */",
            "    hopcroft_karp(const vector<vector<int>>& adj, int rsz) : l_to_r(sz(adj), -1), r_to_l(rsz, -1) {",
            "        int lsz = sz(adj);",
            "        while (1) {",
            "            queue<int> q;",
            "            vector level(lsz, -1);",
            "            for (int i = 0; i < lsz; i++)",
            "                if (l_to_r[i] == -1) level[i] = 0, q.push(i);",
            "            bool found = 0;",
            "            mvc_l.assign(lsz, 1);",
            "            mvc_r.assign(rsz, 0);",
            "            while (!empty(q)) {",
            "                int u = q.front();",
            "                q.pop();",
            "                mvc_l[u] = 0;",
            "                for (int v : adj[u]) {",
            "                    mvc_r[v] = 1;",
            "                    int w = r_to_l[v];",
            "                    if (w == -1) found = 1;",
            "                    else if (level[w] == -1) {",
            "                        level[w] = level[u] + 1;",
            "                        q.push(w);",
            "                    }",
            "                }",
            "            }",
            "            if (!found) break;",
            "            auto dfs = [&](auto&& self, int u) -> bool {",
            "                for (int v : adj[u]) {",
            "                    int w = r_to_l[v];",
            "                    if (w == -1 || (level[u] + 1 == level[w] && self(self, w))) {",
            "                        l_to_r[u] = v;",
            "                        r_to_l[v] = u;",
            "                        return 1;",
            "                    }",
            "                }",
            "                level[u] = INT_MAX;",
            "                return 0;",
            "            };",
            "            for (int i = 0; i < lsz; i++)",
            "                size_of_matching += (l_to_r[i] == -1 && dfs(dfs, i));",
            "        }",
            "    }",
            "};",
            "#if 0",
            "//0 <= node_left < lsz",
            "//0 <= node_right < rsz",
            "//for every edge node_left <=> node_right",
            "adj[node_left].push_back(node_right);",
            "auto [size_of_matching, l_to_r, r_to_l, mvc_l, mvc_r] = hopcroft_karp(adj, rsz);",
            "#endif"
        ],
        "description": ""
    },
    "subtree_isomorphism": {
        "scope": "cpp",
        "prefix": [
            "lrv_subtree_isomorphism"
        ],
        "body": [
            "struct subtree_iso {",
            "    int num_distinct_subtrees; /**< number of classes (by iso.) of subtrees */",
            "    /**",
            "     * - 0 <= iso_id[u] < num_distinct_subtrees",
            "     * - iso_id[u] == iso_id[v] iff subtree u is isomorphic to subtree v",
            "     */",
            "    vector<int> iso_id;",
            "    /**",
            "     * @param adj rooted forest (rooted or unrooted)",
            "     * @time O(n log n)",
            "     * @space `iso_id` and `hashes` both are O(n)",
            "     */",
            "    subtree_iso(const vector<vector<int>>& adj) : iso_id(sz(adj), -1) {",
            "        map<vector<int>, int> hashes;",
            "        auto dfs = [&](auto&& self, int u, int p) -> int {",
            "            vector<int> ch_ids;",
            "            ch_ids.reserve(sz(adj[u]));",
            "            for (int v : adj[u])",
            "                if (v != p) ch_ids.push_back(self(self, v, u));",
            "            sort(begin(ch_ids), end(ch_ids));",
            "            return iso_id[u] = hashes.try_emplace(ch_ids, sz(hashes)).first->second;",
            "        };",
            "        for (int i = 0; i < sz(adj); i++)",
            "            if (iso_id[i] == -1) dfs(dfs, i, i);",
            "        num_distinct_subtrees = sz(hashes);",
            "    }",
            "};",
            "#if 0",
            "auto [num_distinct_subtrees, iso_id] = subtree_iso(adj);",
            "#endif"
        ],
        "description": ""
    },
    "dijkstra": {
        "scope": "cpp",
        "prefix": [
            "lrv_dijkstra"
        ],
        "body": [
            "vector<long long> dijkstra(const vector<vector<pair<int, long long>>>& adj, int s) {",
            "    using node = pair<long long, int>;",
            "    vector d(sz(adj), LLONG_MAX);",
            "    d[s] = 0;",
            "    priority_queue<node, vector<node>, greater<node>> pq;",
            "    pq.emplace(0, s);",
            "    while (!empty(pq)) {",
            "        auto [d_u, u] = pq.top();",
            "        pq.pop();",
            "        if (d[u] < d_u) continue;//important check: O(n*m) without it",
            "        for (auto [v, w] : adj[u])",
            "            if (d[v] > w + d[u]) {",
            "                d[v] = w + d[u];",
            "                pq.emplace(d[v], v);",
            "            }",
            "    }",
            "    return d;",
            "}"
        ],
        "description": ""
    },
    "random": {
        "scope": "cpp",
        "prefix": [
            "lrv_random"
        ],
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "template <class T> inline T get_rand(T le, T ri) {",
            "    assert(le <= ri);",
            "    return uniform_int_distribution<T>(le, ri)(rng);",
            "}",
            "#if 0",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "unsigned long long x = rng();",
            "// fixed seed for debugging",
            "mt19937 rng;",
            "unsigned int x = rng();",
            "//",
            "vector<int> a(n);",
            "shuffle(begin(a), end(a), rng);",
            "//",
            "int x = get_rand(0, 1);",
            "long long x = get_rand<long long>(1, 1e18);",
            "#endif"
        ],
        "description": ""
    },
    "and_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_and_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "vector<int> and_convolution(vector<int> a, vector<int> b) {",
            "    int n = __lg(sz(a));",
            "    assert(sz(a) == sz(b) && (1 << n) == sz(a));",
            "    for (int i = 0; i < n; i++)",
            "        for (int j = 0; j < (1 << n); j++)",
            "            if (!((j >> i) & 1)) {",
            "                a[j] = (a[j] + a[j ^ (1 << i)]) % mod;",
            "                b[j] = (b[j] + b[j ^ (1 << i)]) % mod;",
            "            }",
            "    vector<int> c(1 << n);",
            "    for (int i = 0; i < (1 << n); i++)",
            "        c[i] = 1LL * a[i] * b[i] % mod;",
            "    for (int i = 0; i < n; i++)",
            "        for (int j = 0; j < (1 << n); j++)",
            "            if (!((j >> i) & 1))",
            "                c[j] = (c[j] - c[j ^ (1 << i)] + mod) % mod;",
            "    return c;",
            "}"
        ],
        "description": ""
    },
    "lcm_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_lcm_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "vector<int> lcm_convolution(const vector<int>& a, const vector<int>& b) {",
            "    assert(sz(a) == sz(b));",
            "    int n = sz(a);",
            "    vector sum_a(n, 0LL), sum_b(n, 0LL);",
            "    vector<int> c(n);",
            "    for (int i = 1; i < n; i++) {",
            "        for (int j = i; j < n; j += i)",
            "            sum_a[j] += a[i], sum_b[j] += b[i];",
            "        sum_a[i] %= mod, sum_b[i] %= mod;",
            "        c[i] = (c[i] + sum_a[i] * sum_b[i]) % mod;",
            "        for (int j = i + i; j < n; j += i)",
            "            if ((c[j] -= c[i]) < 0) c[j] += mod;",
            "    }",
            "    return c;",
            "}"
        ],
        "description": ""
    },
    "gcd_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_gcd_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;",
            "vector<int> gcd_convolution(const vector<int>& a, const vector<int>& b) {",
            "    assert(sz(a) == sz(b));",
            "    int n = sz(a);",
            "    vector<int> c(n);",
            "    for (int g = n - 1; g >= 1; g--) {",
            "        auto sum_a = 0LL, sum_b = 0LL;",
            "        for (int i = g; i < n; i += g) {",
            "            sum_a += a[i], sum_b += b[i];",
            "            if ((c[g] -= c[i]) < 0) c[g] += mod;",
            "        }",
            "        sum_a %= mod, sum_b %= mod;",
            "        c[g] = (c[g] + sum_a * sum_b) % mod;",
            "    }",
            "    return c;",
            "}"
        ],
        "description": ""
    },
    "min_cost_max_flow": {
        "scope": "cpp",
        "prefix": [
            "lrv_min_cost_max_flow"
        ],
        "body": [
            "struct mcmf {",
            "    using ll = long long;",
            "    struct edge {",
            "        int u, v;",
            "        ll cap, cost, flow;",
            "        int back;",
            "    };",
            "    int n;",
            "    vector<edge> e;",
            "    vector<vector<int>> adj;",
            "    /**",
            "     * @param a_n number of nodes.",
            "     */",
            "    mcmf(int a_n) : n(a_n), adj(n) {}",
            "    void add_edge(int u, int v, ll cap, ll cost) {",
            "        edge e1 = {u, v, cap, cost, 0, sz(adj[v])};",
            "        edge e2 = {v, u, 0, -cost, 0, sz(adj[u])};",
            "        adj[u].push_back(sz(e));",
            "        e.push_back(e1);",
            "        adj[v].push_back(sz(e));",
            "        e.push_back(e2);",
            "    }",
            "    /**",
            "     * @param s source, 0 <= s < n",
            "     * @param t sink, 0 <= t < n",
            "     * @param total_flow we try to send this amount of flow through the graph",
            "     * @returns array of {flow, cost}",
            "     * - flow: (<=total_flow) is the max amount of flow we are able to send.",
            "     * - cost: minimum sum of: (edge.flow * edge.cost) over each edge (over all",
            "     *   ways to send `flow` flow)",
            "     */",
            "    array<ll, 2> get_flow(int s, int t, ll total_flow) {",
            "        ll flow = 0, cost = 0;",
            "        while (flow < total_flow) {",
            "            vector d(n, LLONG_MAX);",
            "            vector<int> p_edge(n), id(n), q(n), p(n);",
            "            int qh = 0, qt = 0;",
            "            q[qt++] = s;",
            "            d[s] = 0;",
            "            while (qh != qt) {",
            "                int u = q[qh++];",
            "                id[u] = 2;",
            "                if (qh == n) qh = 0;",
            "                for (int i = 0; i < sz(adj[u]); i++) {",
            "                    edge& r = e[adj[u][i]];",
            "                    if (r.flow < r.cap && d[u] + r.cost < d[r.v]) {",
            "                        d[r.v] = d[u] + r.cost;",
            "                        if (id[r.v] == 0) {",
            "                            q[qt++] = r.v;",
            "                            if (qt == n) qt = 0;",
            "                        } else if (id[r.v] == 2) {",
            "                            if (--qh == -1) qh = n - 1;",
            "                            q[qh] = r.v;",
            "                        }",
            "                        id[r.v] = 1;",
            "                        p[r.v] = u;",
            "                        p_edge[r.v] = i;",
            "                    }",
            "                }",
            "            }",
            "            if (d[t] == LLONG_MAX) break;",
            "            ll addflow = total_flow - flow;",
            "            for (int u = t; u != s; u = p[u]) {",
            "                int pv = p[u], pr = p_edge[u];",
            "                addflow = min(addflow, e[adj[pv][pr]].cap - e[adj[pv][pr]].flow);",
            "            }",
            "            for (int u = t; u != s; u = p[u]) {",
            "                int pv = p[u], pr = p_edge[u], r = e[adj[pv][pr]].back;",
            "                e[adj[pv][pr]].flow += addflow;",
            "                e[adj[u][r]].flow -= addflow;",
            "                cost += e[adj[pv][pr]].cost * addflow;",
            "            }",
            "            flow += addflow;",
            "        }",
            "        return {flow, cost};",
            "    }",
            "};"
        ],
        "description": ""
    },
    "hungarian": {
        "scope": "cpp",
        "prefix": [
            "lrv_hungarian"
        ],
        "body": [
            "struct hungarian {",
            "    long long min_weight; /**< sum of edge weights in matching */",
            "    vector<int> l_to_r; /**< edge v <=> l_to_r[v] is in the matching, 1<=v<=n; 1<=l_to_r[v]<=m */",
            "    /**",
            "     * @param cost (n+1)-by-(m+1) array: cost[u][v] = weight (can be negative) of",
            "     * the edge u <=> v, 1<=u<=n; 1<=v<=m, n<=m",
            "     * @time O(n^2 * m)",
            "     * @space besides the O(n * m) `cost` param, this allocates `l_to_r`",
            "     * which is O(n), and various O(m) arrays are also allocated temporarily",
            "     */",
            "    hungarian(const vector<vector<long long>>& cost) : l_to_r(sz(cost)) {",
            "        int n = sz(cost) - 1, m = sz(cost[0]) - 1;",
            "        assert(n <= m);",
            "        vector<int> p(m + 1), way(m + 1);",
            "        vector u(n + 1, 0LL), v(m + 1, 0LL);",
            "        for (int i = 1; i <= n; i++) {",
            "            p[0] = i;",
            "            int j0 = 0;",
            "            vector minv(m + 1, LLONG_MAX);",
            "            vector<bool> used(m + 1);",
            "            do {",
            "                used[j0] = 1;",
            "                int i0 = p[j0], j1 = 0;",
            "                auto delta = LLONG_MAX;",
            "                for (int j = 1; j <= m; j++)",
            "                    if (!used[j]) {",
            "                        auto cur = cost[i0][j] - u[i0] - v[j];",
            "                        if (cur < minv[j]) minv[j] = cur, way[j] = j0;",
            "                        if (minv[j] < delta) delta = minv[j], j1 = j;",
            "                    }",
            "                for (int j = 0; j <= m; j++)",
            "                    if (used[j]) u[p[j]] += delta, v[j] -= delta;",
            "                    else minv[j] -= delta;",
            "                j0 = j1;",
            "            } while (p[j0] != 0);",
            "            do {",
            "                int j1 = way[j0];",
            "                p[j0] = p[j1];",
            "                j0 = j1;",
            "            } while (j0);",
            "        }",
            "        for (int j = 1; j <= m; j++) l_to_r[p[j]] = j;",
            "        min_weight = -v[0];",
            "    }",
            "};",
            "#if 0",
            "auto [min_weight, l_to_r] = hungarian(cost);",
            "#endif"
        ],
        "description": ""
    }
}