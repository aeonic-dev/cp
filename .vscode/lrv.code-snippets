{
    "bit": {
        "scope": "cpp",
        "prefix": [
            "lrv_bit"
        ],
        "body": [
            "template <class T> struct BIT {\n",
            "    vector<T> s;\n",
            "    BIT() {}\n",
            "    /**\n",
            "     * @param n initial size\n",
            "     * @time O(n)\n",
            "     * @space O(n) for `s` vector\n",
            "     */\n",
            "    BIT(int n) : s(n) {}\n",
            "    /**\n",
            "     * @param a initial array\n",
            "     * @time O(n)\n",
            "     * @space O(n) for `s` vector\n",
            "     */\n",
            "    BIT(const vector<T>& a) : s(a) {\n",
            "        for (int i = 0; i < ssize(a); i++) {\n",
            "            int j = i | (i + 1);\n",
            "            if (j < ssize(a)) s[j] += s[i];\n",
            "        }\n",
            "    }\n",
            "    /**\n",
            "     * @param i index\n",
            "     * @param d delta\n",
            "     * @time O(log n)\n",
            "     * @space O(1)\n",
            "     */\n",
            "    inline void update(int i, T d) {\n",
            "        assert(0 <= i && i < ssize(s));\n",
            "        for (; i < ssize(s); i |= i + 1) s[i] += d;\n",
            "    }\n",
            "    /**\n",
            "     * @param ri defines range [0, ri)\n",
            "     * @returns a[0] + a[1] + ... + a[ri - 1]\n",
            "     * @time O(log n)\n",
            "     * @space O(1)\n",
            "     */\n",
            "    inline T sum(int ri) {\n",
            "        assert(0 <= ri && ri <= ssize(s));\n",
            "        T ret = 0;\n",
            "        for (; ri > 0; ri &= ri - 1) ret += s[ri - 1];\n",
            "        return ret;\n",
            "    }\n",
            "    /**\n",
            "     * @param le,ri defines range [le, ri)\n",
            "     * @returns a[le] + a[le + 1] + ... + a[ri - 1]\n",
            "     * @time O(log n)\n",
            "     * @space O(1)\n",
            "     */\n",
            "    inline T sum(int le, int ri) {\n",
            "        assert(le <= ri);\n",
            "        return sum(ri) - sum(le);\n",
            "    }\n",
            "};\n"
        ],
        "description": "Binary Indexed Tree"
    },
    "rmq": {
        "scope": "cpp",
        "prefix": [
            "lrv_rmq"
        ],
        "body": [
            "       vector<long long> a;\n",
            "       RMQ rmq(a, ranges::min); // -std=c++20\n",
            "       RMQ rmq(a, [&](auto& x, auto& y) { return min(x, y); });\n",
            "template <class T, class F> struct RMQ {\n",
            "    vector<vector<T>> dp;\n",
            "    F op;\n",
            "    RMQ() {}\n",
            "    /**\n",
            "     * @param a static array\n",
            "     * @param a_op any associative, communative, idempotent operation\n",
            "     * @time O(n log n)\n",
            "     * @space O(n log n) for `dp` vector\n",
            "     */\n",
            "    RMQ(const vector<T>& a, F a_op) : dp(1, a), op(a_op) {\n",
            "        for (int i = 0; (2 << i) <= ssize(a); i++) {\n",
            "            dp.emplace_back(ssize(a) - (2 << i) + 1);\n",
            "            transform(begin(dp[i]), end(dp[i]) - (1 << i), begin(dp[i]) + (1 << i), begin(dp[i + 1]), op);\n",
            "        }\n",
            "    }\n",
            "    /**\n",
            "     * @param le,ri defines range [le, ri)\n",
            "     * @returns a[le] op a[le + 1] op ... op a[ri - 1]\n",
            "     * @time O(1)\n",
            "     * @space O(1)\n",
            "     */\n",
            "    inline T query(int le, int ri) {\n",
            "        assert(0 <= le && le < ri && ri <= ssize(dp[0]));\n",
            "        int lg = __lg(ri - le);\n",
            "        return op(dp[lg][le], dp[lg][ri - (1 << lg)]);\n",
            "    }\n",
            "};\n"
        ],
        "description": "@code{.cpp} @endcode"
    },
    "seg_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_seg_tree"
        ],
        "body": [
            "inline int split(int tl, int tr) {\n",
            "    int pw2 = 1 << __lg(tr - tl);\n",
            "    return min(tl + pw2, tr - pw2 / 2);\n",
            "}\n",
            "inline long long op(long long vl, long long vr) {\n",
            "    return vl + vr;\n",
            "}\n",
            " *\n",
            "struct seg_tree {\n",
            "    int n;\n",
            "    vector<long long> tree, lazy;\n",
            "    seg_tree(int a_n) : n(a_n), tree(2 * n), lazy(n) {}\n",
            "    seg_tree(const vector<int>& a) : n(ssize(a)), tree(2 * n), lazy(n) {\n",
            "        int pw2 = 1;\n",
            "        while (pw2 < n) pw2 *= 2;\n",
            "        for (int i = 0; i < n; i++) tree[(i + pw2) % n + n] = a[i];\n",
            "        for (int i = n - 1; i >= 1; i--) tree[i] = op(tree[2 * i], tree[2 * i + 1]);\n",
            "    }\n",
            "    inline void apply(long long change, int tl, int tr, int u) {\n",
            "        tree[u] += (tr - tl) * change;\n",
            "        if (u < n) lazy[u] += change;\n",
            "    }\n",
            "    inline void push(int tl, int tm, int tr, int u) {\n",
            "        if (lazy[u]) {\n",
            "            apply(lazy[u], tl, tm, 2 * u);\n",
            "            apply(lazy[u], tm, tr, 2 * u + 1);\n",
            "            lazy[u] = 0;\n",
            "        }\n",
            "    }\n",
            "    /**\n",
            "     * @param le,ri defines range [le, ri)\n",
            "     */\n",
            "    void update(int le, int ri, long long change) {update(le, ri, change, 0, n, 1);}\n",
            "    void update(int le, int ri, long long change, int tl, int tr, int u) {\n",
            "        if (ri <= tl || tr <= le) return;\n",
            "        if (le <= tl && tr <= ri) return apply(change, tl, tr, u);\n",
            "        int tm = split(tl, tr);\n",
            "        push(tl, tm, tr, u);\n",
            "        update(le, ri, change, tl, tm, 2 * u);\n",
            "        update(le, ri, change, tm, tr, 2 * u + 1);\n",
            "        tree[u] = op(tree[2 * u], tree[2 * u + 1]);\n",
            "    }\n",
            "    /**\n",
            "     * @param le,ri defines range [le, ri)\n",
            "     */\n",
            "    long long query(int le, int ri) {return query(le, ri, 0, n, 1);}\n",
            "    long long query(int le, int ri, int tl, int tr, int u) {\n",
            "        if (ri <= tl || tr <= le) return 0;\n",
            "        if (le <= tl && tr <= ri) return tree[u];\n",
            "        int tm = split(tl, tr);\n",
            "        push(tl, tm, tr, u);\n",
            "        return op(query(le, ri, tl, tm, 2 * u),\n",
            "                  query(le, ri, tm, tr, 2 * u + 1));\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://codeforces.com/blog/entry/112755 @param tl,tr defines range [tl, tr) @returns split point of range which makes the segment tree a complete binary tree root is at tree[1] internal nodes are [1, n) leaf nodes are [n, 2 * n), but rotated such that a[0] is at tree[pw2]     where pw2 is the only power of 2 such that n <= pw2 < 2 * n"
    },
    "knuth_morris_pratt": {
        "scope": "cpp",
        "prefix": [
            "lrv_knuth_morris_pratt"
        ],
        "body": [
            "       string s;\n",
            "       KMP kmp(s);\n",
            "       vector<int> a;\n",
            "       KMP kmp(a);\n",
            "template <class T> struct KMP {\n",
            "    T needle;\n",
            "    vector<int> pi;\n",
            "    /**\n",
            "     * @param a_needle string to be searched for inside haystack\n",
            "     * @time O(|needle|)\n",
            "     * @space O(|needle|) for `needle` and `pi` arrays\n",
            "     */\n",
            "    KMP(const T& a_needle) : needle(a_needle), pi(prefix_function(needle)) {}\n",
            "    /**\n",
            "     * @param haystack usually |needle| <= |haystack|\n",
            "     * @returns array `matches` where:\n",
            "     * haystack.substr(matches[i], ssize(needle)) == needle\n",
            "     * @time O(|haystack|)\n",
            "     * @space besides O(|haystack|) param, this function allocates/returns an\n",
            "     * array of size (# matches), at worst O(|haystack|)\n",
            "     */\n",
            "    vector<int> find_str(const T& haystack) {\n",
            "        vector<int> matches;\n",
            "        for (int i = 0, j = 0; i < ssize(haystack); i++) {\n",
            "            while (j > 0 && needle[j] != haystack[i]) j = pi[j - 1];\n",
            "            j += (needle[j] == haystack[i]);\n",
            "            if (j == ssize(needle)) {\n",
            "                matches.push_back(i - ssize(needle) + 1);\n",
            "                j = pi[j - 1];\n",
            "            }\n",
            "        }\n",
            "        return matches;\n",
            "    }\n",
            "};\n"
        ],
        "description": "@code{.cpp} @endcode kmp with one array as the needle and the other array doubled (excluding the first & last characters) as the haystack or just use kactl's min rotation code."
    },
    "trie": {
        "scope": "cpp",
        "prefix": [
            "lrv_trie"
        ],
        "body": [
            "const int mn = 'A', max_val = 26; // mn <= s[i] < mn + max_val\n",
            "struct trie {\n",
            "    struct node {\n",
            "        array<int, max_val> next;\n",
            "        int cnt_words = 0, par = -1;\n",
            "        char ch;\n",
            "        node(int a_par = -1, char a_ch = '#') : par(a_par), ch(a_ch) {\n",
            "            fill(begin(next), end(next), -1);\n",
            "        }\n",
            "    };\n",
            "    vector<node> t;\n",
            "    trie() : t(1) {}\n",
            "    void insert(const string& s) {\n",
            "        int u = 0;\n",
            "        for (char ch : s) {\n",
            "            int v = ch - mn;\n",
            "            if (t[u].next[v] == -1) {\n",
            "                t[u].next[v] = ssize(t);\n",
            "                t.emplace_back(u, ch);\n",
            "            }\n",
            "            u = t[u].next[v];\n",
            "        }\n",
            "        t[u].cnt_words++;\n",
            "    }\n",
            "    int find(const string& s) {\n",
            "        int u = 0;\n",
            "        for (char ch : s) {\n",
            "            int v = ch - mn;\n",
            "            if (t[u].next[v] == -1) return 0;\n",
            "            u = t[u].next[v];\n",
            "        }\n",
            "        return t[u].cnt_words;\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://cp-algorithms.com/string /aho_corasick.html#construction-of-the-trie"
    },
    "prefix_function": {
        "scope": "cpp",
        "prefix": [
            "lrv_prefix_function"
        ],
        "body": [
            "template <class T> vector<int> prefix_function(const T& s) {\n",
            "    vector<int> pi(ssize(s));\n",
            "    for (int i = 1; i < ssize(s); i++) {\n",
            "        int j = pi[i - 1];\n",
            "        while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n",
            "        pi[i] = j + (s[i] == s[j]);\n",
            "    }\n",
            "    return pi;\n",
            "}\n"
        ],
        "description": "@see https://cp-algorithms.com/string /prefix-function.html#implementation @param s string/array @returns prefix function @time O(n) @space this function allocates/returns a O(n) vector"
    },
    "count_rectangles": {
        "scope": "cpp",
        "prefix": [
            "lrv_count_rectangles"
        ],
        "body": [
            "vector<vector<int>> count_rectangles(const vector<vector<bool>>& grid) {\n",
            "    int n = ssize(grid), m = ssize(grid[0]);\n",
            "    vector cnt(n + 1, vector(m + 1, 0));\n",
            "    vector<int> h(m);\n",
            "    for (const auto& row : grid) {\n",
            "        transform(begin(h), end(h), begin(row), begin(h), [](int a, bool g) {\n",
            "            return g * (a + 1);\n",
            "        });\n",
            "        auto ri = mono_st(h, less()), le = mono_range(ri);\n",
            "        for (int j = 0; j < m; j++) {\n",
            "            int cnt_l = j - le[j] - 1, cnt_r = ri[j] - j - 1;\n",
            "            cnt[h[j]][cnt_l + cnt_r + 1]++;\n",
            "            cnt[h[j]][cnt_l]--;\n",
            "            cnt[h[j]][cnt_r]--;\n",
            "        }\n",
            "    }\n",
            "    for (int i = 1; i <= n; i++)\n",
            "        for (int k = 0; k < 2; k++)\n",
            "            for (int j = m; j > 1; j--)\n",
            "                cnt[i][j - 1] += cnt[i][j];\n",
            "    for (int i = n; i > 1; i--)\n",
            "        for (int j = 1; j <= m; j++)\n",
            "            cnt[i - 1][j] += cnt[i][j];\n",
            "    return cnt;\n",
            "}\n"
        ],
        "description": "@param grid an n-by-m boolean array @returns an (n+1)-by-(m+1) array cnt where cnt[i][j] = the number of times an i-by-j sub rectangle appears in the matrix such that all i*j cells in the sub rectangle are 1. cnt[i][0] and cnt[0][j] will contain garbage values. @time O(n * m) @space this function allocates/returns a O(n * m) vector"
    },
    "cartesian_k_ary_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_cartesian_k_ary_tree"
        ],
        "body": [
            " *\n",
            " *\n",
            " *\n",
            "       auto ri = mono_st(a, less_equal()), p = cart_k_ary_tree(a, ri); // min cart tree\n",
            "       auto ri = mono_st(a, greater_equal()), p = cart_k_ary_tree(a, ri); // max cart tree\n",
            "       bool is_node = (p[i] > i || a[i] != a[p[i]]);\n",
            " *\n",
            "template <class T> vector<int> cart_k_ary_tree(const vector<T>& a, const vector<int>& ri) {\n",
            "    vector<int> p(ri);\n",
            "    for (int i = 0; i < ssize(a); i++)\n",
            "        for (int j = i + 1; j != ri[i]; j = ri[j])\n",
            "            if (ri[j] == ri[i] || a[i] == a[ri[j]])\n",
            "                p[j] = (p[i] > i || a[i] != a[p[i]] ? i : p[i]);\n",
            "    return p;\n",
            "}\n"
        ],
        "description": "  when cmp is less_equal():   a = {2, 1, 3, 1, 1, 0, 2, 2, 1, 0, 2}       (---------------x---------------)       (---x---------) | (------x)   (x)       (x) | (x)       | (x---) |     |        |  |  |        |  |     |     | nodes are the left-most min of their subarray: p[0] = p[2] = 1 p[6] = 8 p[1] = p[8] = p[10] = 5 p[5] = 11 = n (root) indexes 3, 4, 7, 9 are not nodes; here p maps i to left-most min in their subarray: p[3] = p[4] = 1 p[7] = 6 p[9] = 5 @code{.cpp} @endcode @param a,ri array and its monotonic stack @returns parent array @time O(n) @space a O(n) vector is allocated and returned"
    },
    "monotonic_range": {
        "scope": "cpp",
        "prefix": [
            "lrv_monotonic_range"
        ],
        "body": [
            "       vector<long long> a;\n",
            "       auto ri = mono_st(a, less()), le = mono_range(ri); // greater(), less_equal(), greater_equal()\n",
            "vector<int> mono_range(const vector<int>& ri) {\n",
            "    vector le(ssize(ri), -1);\n",
            "    for (int i = 0; i < ssize(ri); i++)\n",
            "        for (int j = i + 1; j != ri[i]; j = ri[j]) le[j] = i;\n",
            "    return le;\n",
            "}\n"
        ],
        "description": "@code{.cpp} @endcode @param ri monotonic stack array of a @returns (if you use less()) vector le such that:     - le[i] < i < ri[i]     - a[i] is the min of exclusive-exclusive range (le[i], ri[i])     - le[i] is the max index such that a[le[i]] < a[i], or -1     - ri[i] is the min index such that a[i] >= a[ri[i]], or n @time O(n) @space two O(n) vectors are allocated and returned"
    },
    "cartesian_binary_tree": {
        "scope": "cpp",
        "prefix": [
            "lrv_cartesian_binary_tree"
        ],
        "body": [
            " *\n",
            "       auto ri = mono_st(a, less()), p = cart_binary_tree(ri); // right-most min is root\n",
            "       auto ri = mono_st(a, less_equal()), p = cart_binary_tree(ri); // left-most min is root\n",
            "       auto ri = mono_st(a, greater()), p = cart_binary_tree(ri); // right-most max is root\n",
            "       auto ri = mono_st(a, greater_equal()), p = cart_binary_tree(ri); // left-most max is root\n",
            "vector<int> cart_binary_tree(const vector<int>& ri) {\n",
            "    vector<int> p(ri);\n",
            "    for (int i = 0; i < ssize(p); i++)\n",
            "        for (int j = i + 1; j != ri[i]; j = ri[j])\n",
            "            if (ri[j] == ri[i]) p[j] = i;\n",
            "    return p;\n",
            "}\n"
        ],
        "description": "  when cmp is less():   a = {2, 1, 3, 1, 1, 0, 2, 2, 1, 0, 2}       (---------------------------x---)       (---------------x---------)   (x)       (------------x) | (------x)    |       (---------x)    | (---x) |     |       (---x---)       | (x) |  |     |       (x) | (x)       |  |  |  |     |        |  |  |        |  |  |  |     | @code{.cpp} @endcode @param ri monotonic stack of array `a` @returns parent array @time O(n) @space a O(n) vector is allocated and returned"
    },
    "max_rect_histogram": {
        "scope": "cpp",
        "prefix": [
            "lrv_max_rect_histogram"
        ],
        "body": [
            "long long max_rect_histogram(const vector<int>& a) {\n",
            "    auto ri = mono_st(a, less()), le = mono_range(ri);\n",
            "    auto max_area = 0LL;\n",
            "    for (int i = 0; i < ssize(a); i++)\n",
            "        max_area = max(max_area, 1LL * a[i] * (ri[i] - le[i] - 1));\n",
            "    return max_area;\n",
            "}\n"
        ],
        "description": "@param a contains positive integers @returns largest integer x such that there exists a subarray a[le,ri) @time O(n) @space besides O(n) param `a`, O(n) extra space is allocated temporarily"
    },
    "monotonic_stack": {
        "scope": "cpp",
        "prefix": [
            "lrv_monotonic_stack"
        ],
        "body": [
            "       vector<long long> a;\n",
            "       auto ri = mono_st(a, less()); // greater(), less_equal(), greater_equal()\n",
            "       for (int i = n - 1; i >= 0; i--)\n",
            "           for (int j = i + 1; j != ri[i]; j = ri[j])\n",
            "               // for all k in [j, ri[j]): cmp(a[i], a[k])\n",
            "               // these ranges are disjoint, and union to [i + 1, ri[i])\n",
            "template <class T, class F> vector<int> mono_st(const vector<T>& a, F cmp) {\n",
            "    vector<int> ri(ssize(a));\n",
            "    for (int i = ssize(a) - 1; i >= 0; i--)\n",
            "        for (ri[i] = i + 1; ri[i] < ssize(a) && cmp(a[i], a[ri[i]]);) ri[i] = ri[ri[i]];\n",
            "    return ri;\n",
            "}\n"
        ],
        "description": "@code{.cpp} @endcode @param a array @param cmp any transitive compare operator @returns array ri where ri[i] = max integer such that: @time O(n) @space a O(n) vector is allocated and returned"
    },
    "partitions": {
        "scope": "cpp",
        "prefix": [
            "lrv_partitions"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "vector<long long> partitions(int n) {\n",
            "    vector dp(n, 1LL);\n",
            "    for (int i = 1; i < n; i++) {\n",
            "        auto sum = 0LL;\n",
            "        for (int j = 1, pent = 1, sign = 1; pent <= i; j++, pent += 3 * j - 2, sign = -sign) {\n",
            "            if (pent + j <= i) sum += dp[i - pent - j] * sign + mod;\n",
            "            sum += dp[i - pent] * sign + mod;\n",
            "        }\n",
            "        dp[i] = sum % mod;\n",
            "    }\n",
            "    return dp;\n",
            "}\n"
        ],
        "description": "@see https://oeis.org/A000041 @param n an integer @returns array p where p[i] = number of partitions of i numbers @time O(n sqrt n) note there does exist a O(n log n) solution as well @space O(n) for `dp` vector"
    },
    "num_distinct_subsequences": {
        "scope": "cpp",
        "prefix": [
            "lrv_num_distinct_subsequences"
        ],
        "body": [
            "int num_subsequences(const vector<int>& a, int mod) {\n",
            "    vector dp(ssize(a) + 1, 1);\n",
            "    map<int, int> last;\n",
            "    for (int i = 0; i < ssize(a); i++) {\n",
            "        int& curr = dp[i + 1] = 2 * dp[i];\n",
            "        if (curr >= mod) curr -= mod;\n",
            "        auto it = last.find(a[i]);\n",
            "        if (it != end(last)) {\n",
            "            curr -= dp[it->second];\n",
            "            if (curr < 0) curr += mod;\n",
            "            it->second = i;\n",
            "        } else last[a[i]] = i;\n",
            "    }\n",
            "    return dp.back();\n",
            "}\n"
        ],
        "description": "@param a,mod self explanatory @returns the number of distinct subsequences of `a`. The empty subsequence is counted. @time O(n log n) @space besides O(n) `a` param, O(n) extra space is allocated temporarily"
    },
    "binary_exponentiation_mod": {
        "scope": "cpp",
        "prefix": [
            "lrv_binary_exponentiation_mod"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "long long bin_exp(long long b, long long e) {\n",
            "    assert(0 <= e);\n",
            "    auto res = 1LL;\n",
            "    if ((b %= mod) < 0) b += mod;\n",
            "    for (; e; b = b * b % mod, e /= 2)\n",
            "        if (e & 1) res = res * b % mod;\n",
            "    return res;\n",
            "}\n"
        ],
        "description": "@see https://github.com/kth-competitive-programming/kactl /blob/main/content/number-theory/ModPow.h @param b base @param e exponent @returns (b^e)%mod, 1 for 0^0. @time O(log e) @space O(1)"
    },
    "tetration_mod": {
        "scope": "cpp",
        "prefix": [
            "lrv_tetration_mod"
        ],
        "body": [
            "long long bin_exp(long long b, long long e, int mod) {\n",
            "    assert(0 <= e);\n",
            "    auto res = 1LL;\n",
            "    if ((b %= mod) < 0) b += mod;\n",
            "    for (; e; b = b * b % mod, e /= 2)\n",
            "        if (e & 1) res = res * b % mod;\n",
            "    return res;\n",
            "}\n",
            " *\n",
            " *\n",
            "long long tetration(long long b, long long e, int mod) {\n",
            "    if (mod == 1) return 0;\n",
            "    if (b == 0) return (e + 1) % 2 % mod;\n",
            "    if (b == 1 || e == 0) return 1;\n",
            "    if (e == 1) return b % mod;\n",
            "    if (b == 2 && e == 2) return 4 % mod;\n",
            "    if (b == 2 && e == 3) return 16 % mod;\n",
            "    if (b == 3 && e == 2) return 27 % mod;\n",
            "    int t = totient(mod);\n",
            "    auto exp = tetration(b, e - 1, t);\n",
            "    return bin_exp(b, exp + t, mod);\n",
            "}\n"
        ],
        "description": "@see https://github.com/kth-competitive-programming/kactl /blob/main/content/number-theory/ModPow.h @param b base @param e exponent @param mod modulo @returns (b^e)%mod, 1 for 0^0. @time O(log e) @space O(1) @see https://cp-algorithms.com/algebra /phi-function.html#generalization Let t = totient(mod). If log2(mod) <= e then (b^e)%mod == (b^(t+(e%t)))%mod So you need enough base cases to cover when log2(mod) > e @param b,e,mod see return @returns b ^ (b ^ (b ^ ... )) % mod, where the height of the tower is e. @time O(sqrt(mod) * log(mod)) @space O(log(mod)) for recursion stack, since totient(totient(mod)) <= mod/2"
    },
    "fibonacci": {
        "scope": "cpp",
        "prefix": [
            "lrv_fibonacci"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "       auto val = fib(n)[0];\n",
            "       //n=0 -> val=0\n",
            "       //n=1 -> val=1\n",
            "       //n=2 -> val=1\n",
            "       //n=3 -> val=2\n",
            "       //n=4 -> val=3\n",
            "       //n=5 -> val=5\n",
            "array<long long, 2> fib(long long n) {\n",
            "    if (n == 0) return {0LL, 1LL};\n",
            "    auto [x, y] = fib(n >> 1);\n",
            "    auto c = x * (2 * y - x + mod) % mod, d = (x * x + y * y) % mod;\n",
            "    if (n & 1) return {d, (c + d) % mod};\n",
            "    return {c, d};\n",
            "}\n"
        ],
        "description": "@see https://codeforces.com/blog/entry/14516 https://cp-algorithms.com/algebra /fibonacci-numbers.html#fast-doubling-method @code{.cpp} @endcode @param n an integer @returns a array of {nth fibonacci number, (n+1)th fibonacci number} @time O(log n) @space O(log n) for recursion stack"
    },
    "derangements": {
        "scope": "cpp",
        "prefix": [
            "lrv_derangements"
        ],
        "body": [
            "vector<long long> derangements(int n, int mod) {\n",
            "    vector dp(n, 0LL);\n",
            "    dp[0] = 1;\n",
            "    for (int i = 2; i < n; i++)\n",
            "        dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2]) % mod;\n",
            "    return dp;\n",
            "}\n"
        ],
        "description": "@see https://oeis.org/A000166 @param n size @param mod an integer @return number of permutations p such that p[i] != i @time O(n) @space O(n) for `dp` vector"
    },
    "totient": {
        "scope": "cpp",
        "prefix": [
            "lrv_totient"
        ],
        "body": [
            "int totient(int n) {\n",
            "    int res = n;\n",
            "    for (int i = 2; i * i <= n; i++)\n",
            "        if (n % i == 0) {\n",
            "            while (n % i == 0) n /= i;\n",
            "            res -= res / i;\n",
            "        }\n",
            "    if (n > 1) res -= res / n;\n",
            "    return res;\n",
            "}\n"
        ],
        "description": "@param n an integer @returns number of integers x (1<=x<=n) such that gcd(x, n) = 1 @time O(sqrt n) but can be improved with Pollard-rho @space O(1)"
    },
    "mobius": {
        "scope": "cpp",
        "prefix": [
            "lrv_mobius"
        ],
        "body": [
            "const int mx_n = 1'000'005;\n",
            "int mobius[mx_n];\n",
            "void calc_mobius() {\n",
            "    mobius[1] = 1;\n",
            "    for (int i = 1; i < mx_n; i++)\n",
            "        for (int j = i + i; j < mx_n; j += i)\n",
            "            mobius[j] -= mobius[i];\n",
            "}\n"
        ],
        "description": "mobius[i] = 0 iff there exists a prime p s.t. i%(p^2)=0 mobius[i] = -1 iff i has an odd number of distinct prime factors mobius[i] = 1 iff i has an even number of distinct prime factors @time O(mx_n log mx_n) @space O(mx_n)"
    },
    "supermasks": {
        "scope": "cpp",
        "prefix": [
            "lrv_supermasks"
        ],
        "body": [
            "template <class F> void supermasks(int mask, int n, F f) {\n",
            "    for (int supermask = mask; supermask < (1 << n); supermask = (supermask + 1) | mask)\n",
            "        f(supermask);\n",
            "}\n"
        ],
        "description": "@param mask a submask of (2^n)-1 @param n total number of bits @param f called on all supermasks of mask @time O(3^n) to iterate every supermask of every mask of size n @space O(1)"
    },
    "chooses": {
        "scope": "cpp",
        "prefix": [
            "lrv_chooses"
        ],
        "body": [
            "inline int next_subset(int mask) {\n",
            "    int c = mask & -mask, r = mask + c;\n",
            "    return r | (((r ^ mask) >> 2) / c);\n",
            "}\n",
            "template <class F> void chooses(int n, int k, F f) {\n",
            "    for (int mask = (1 << k) - 1; mask < (1 << n); mask = next_subset(mask))\n",
            "        f(mask);\n",
            "}\n"
        ],
        "description": "@see https://github.com/kth-competitive-programming /kactl/blob/main/content/various/chapter.tex @param mask a number with k bits set @returns the smallest number x such that: - x has k bits set - x > mask @time O(1) @space O(1) @param n,k defines which bitmasks @param f called on all bitmasks of size n with k bits set @time O(n choose k) @space O(1)"
    },
    "submasks": {
        "scope": "cpp",
        "prefix": [
            "lrv_submasks"
        ],
        "body": [
            "template <class F> void submasks(int mask, F f) {\n",
            "    for (int submask = mask; submask; submask = (submask - 1) & mask)\n",
            "        f(submask);\n",
            "}\n"
        ],
        "description": "@param mask represents a bitmask @param f called on all submasks of mask @time O(3^n) to iterate every submask of every mask of size n @space O(1)"
    },
    "quotients": {
        "scope": "cpp",
        "prefix": [
            "lrv_quotients"
        ],
        "body": [
            "template <class F> void quotients(long long n, F f) {\n",
            "    for (long long le = 1, ri; le <= n; le = ri + 1) {\n",
            "        ri = n / (n / le);\n",
            "        /**\n",
            "         * i-th iteration gives an interval [le_i, ri_i], we have:\n",
            "         *     - for all i in [le_i, ri_i]: n / i has the same value\n",
            "         *     - le_0 = 1\n",
            "         *     - ri_last = n\n",
            "         *     - ri_i + 1 = le_(i+1)\n",
            "         */\n",
            "        f(le, ri);\n",
            "    }\n",
            "}\n"
        ],
        "description": "@see https://github.com/tfg50/Competitive-Programming/ blob/master/Biblioteca/Math/DivisionTrick.cpp division trick @param n,f number and helper function @time O(sqrt(n)) @space O(1)"
    },
    "enumerate_triangles": {
        "scope": "cpp",
        "prefix": [
            "lrv_enumerate_triangles"
        ],
        "body": [
            "       enumerate_triangles(edges, n, [&](int u, int v, int w) {\n",
            "           //u, v, w form a triangle\n",
            "       });\n",
            "template <class F> void enumerate_triangles(const vector<array<int, 2>>& edges, int n, F f) {\n",
            "    vector<int> deg(n);\n",
            "    for (auto [u, v] : edges) deg[u]++, deg[v]++;\n",
            "    vector<vector<int>> adj(n);\n",
            "    for (auto [u, v] : edges) {\n",
            "        if (tie(deg[u], u) > tie(deg[v], v)) swap(u, v);\n",
            "        adj[u].push_back(v);\n",
            "    }\n",
            "    vector<bool> seen(n);\n",
            "    for (auto [u, v] : edges) {\n",
            "        for (int w : adj[u]) seen[w] = 1;\n",
            "        for (int w : adj[v]) if (seen[w]) f(u, v, w);\n",
            "        for (int w : adj[u]) seen[w] = 0;\n",
            "    }\n",
            "}\n"
        ],
        "description": "@code{.cpp} @endcode @param edges simple undirected graph @param n number of nodes @param f a function run on all length-3-cycles exactly once @time O(n + m ^ (3/2)) @space besides the O(m) `edges` param, this function allocates a O(n + m) vector temporarily"
    },
    "ladder_decomposition": {
        "scope": "cpp",
        "prefix": [
            "lrv_ladder_decomposition"
        ],
        "body": [
            "       ladder ld(adj);\n",
            "       // KACTL functions\n",
            "       int kth_par = jmp(ld.b_tbl, u, k);\n",
            "       int curr_lca = lca(ld.b_tbl, ld.d, u, v);\n",
            "struct ladder {\n",
            "    int n;\n",
            "    vector<vector<int>> b_tbl, l_tbl;\n",
            "    vector<int> dl/*deepest leaf*/, d, p;\n",
            "    /**\n",
            "     * @param adj forest (rooted or unrooted)\n",
            "     * @time O(n log n)\n",
            "     * @space O(n log n) for b_tbl. Everything else is O(n)\n",
            "     */\n",
            "    ladder(const vector<vector<int>>& adj) : n(ssize(adj)), l_tbl(n), dl(n), d(n), p(n, -1) {\n",
            "        iota(begin(dl), end(dl), 0);\n",
            "        for (int i = 0; i < n; i++)\n",
            "            if (p[i] == -1)\n",
            "                p[i] = i, dfs(adj, i);\n",
            "        b_tbl = treeJump(p);\n",
            "        for (int i = 0; i < n; i++)\n",
            "            if (p[i] == i || dl[p[i]] != dl[i]) {\n",
            "                int leaf = dl[i];\n",
            "                auto& lad = l_tbl[leaf];\n",
            "                lad.resize(min(2 * (d[leaf] - d[i]), d[leaf]) + 1, leaf);\n",
            "                for (int j = 1; j < ssize(lad); j++)\n",
            "                    lad[j] = p[lad[j - 1]];\n",
            "            }\n",
            "    }\n",
            "    void dfs(const vector<vector<int>>& adj, int u) {\n",
            "        for (int v : adj[u])\n",
            "            if (v != p[u]) {\n",
            "                d[v] = d[p[v] = u] + 1;\n",
            "                dfs(adj, v);\n",
            "                if (d[dl[v]] > d[dl[u]]) dl[u] = dl[v];\n",
            "            }\n",
            "    }\n",
            "    /**\n",
            "     * @param u query node\n",
            "     * @param k number of edges\n",
            "     * @returns a node k edges up from u. With k=1, this returns u's parent.\n",
            "     * @time O(1)\n",
            "     * @space O(1)\n",
            "     */\n",
            "    inline int kth_par(int u, int k) {\n",
            "        assert(0 <= k && k <= d[u]);\n",
            "        if (k == 0) return u;\n",
            "        int bit = __lg(k);\n",
            "        u = b_tbl[bit][u], k -= (1 << bit);\n",
            "        int leaf = dl[u];\n",
            "        return l_tbl[leaf][k + d[leaf] - d[u]];\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://codeforces.com/blog/entry/71567#comment-559299 https://youtu.be/0rCFkuQS968 @code{.cpp} @endcode"
    },
    "hopcroft_karp": {
        "scope": "cpp",
        "prefix": [
            "lrv_hopcroft_karp"
        ],
        "body": [
            "       //0 <= node_left < lsz\n",
            "       //0 <= node_right < rsz\n",
            "       //for every edge node_left <=> node_right\n",
            "       adj[node_left].push_back(node_right);\n",
            "       auto [size_of_matching, l_to_r, r_to_l, mvc_l, mvc_r] = hopcroft_karp(adj, rsz);\n",
            "struct hopcroft_karp {\n",
            "    int size_of_matching = 0; /**< # of edges in max matching (which = size of min vertex cover by K\u00f6nig's theorem) */\n",
            "    /**\n",
            "     * edge node_left <=> l_to_r[node_left] in matching iff l_to_r[node_left] != -1\n",
            "     * ditto r_to_l[node_right] <=> node_right\n",
            "     * @{\n",
            "     */\n",
            "    vector<int> l_to_r, r_to_l;\n",
            "    /** @} */\n",
            "    /**\n",
            "     * mvc_l[node_left] = 1 iff node_left is in the min vertex cover; ditto mvc_r[node_right]\n",
            "     * mvc_l[node_left] = 0 iff node_left is in the max independent set\n",
            "     * @{\n",
            "     */\n",
            "    vector<bool> mvc_l, mvc_r;\n",
            "    /** @} */\n",
            "    /**\n",
            "     * @param adj bipartite graph\n",
            "     * @param rsz number of nodes on right side\n",
            "     * @time O(n + m * sqrt(n)) n = lsz + rsz\n",
            "     * @space this allocates member vectors which are O(lsz + rsz)\n",
            "     */\n",
            "    hopcroft_karp(const vector<vector<int>>& adj, int rsz) : l_to_r(ssize(adj), -1), r_to_l(rsz, -1) {\n",
            "        int lsz = ssize(adj);\n",
            "        while (1) {\n",
            "            queue<int> q;\n",
            "            vector level(lsz, -1);\n",
            "            for (int i = 0; i < lsz; i++)\n",
            "                if (l_to_r[i] == -1) level[i] = 0, q.push(i);\n",
            "            bool found = 0;\n",
            "            mvc_l.assign(lsz, 1);\n",
            "            mvc_r.assign(rsz, 0);\n",
            "            while (!empty(q)) {\n",
            "                int u = q.front();\n",
            "                q.pop();\n",
            "                mvc_l[u] = 0;\n",
            "                for (int v : adj[u]) {\n",
            "                    mvc_r[v] = 1;\n",
            "                    int w = r_to_l[v];\n",
            "                    if (w == -1) found = 1;\n",
            "                    else if (level[w] == -1) {\n",
            "                        level[w] = level[u] + 1;\n",
            "                        q.push(w);\n",
            "                    }\n",
            "                }\n",
            "            }\n",
            "            if (!found) break;\n",
            "            auto dfs = [&](auto&& self, int u) -> bool {\n",
            "                for (int v : adj[u]) {\n",
            "                    int w = r_to_l[v];\n",
            "                    if (w == -1 || (level[u] + 1 == level[w] && self(self, w))) {\n",
            "                        l_to_r[u] = v;\n",
            "                        r_to_l[v] = u;\n",
            "                        return 1;\n",
            "                    }\n",
            "                }\n",
            "                level[u] = INT_MAX;\n",
            "                return 0;\n",
            "            };\n",
            "            for (int i = 0; i < lsz; i++)\n",
            "                size_of_matching += (l_to_r[i] == -1 && dfs(dfs, i));\n",
            "        }\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://github.com/foreverbell/acm-icpc-cheat-sheet /blob/master/src/graph-algorithm/hopcroft-karp.cpp @code{.cpp} @endcode"
    },
    "subtree_isomorphism": {
        "scope": "cpp",
        "prefix": [
            "lrv_subtree_isomorphism"
        ],
        "body": [
            "       auto [num_distinct_subtrees, iso_id] = subtree_iso(adj);\n",
            "struct subtree_iso {\n",
            "    int num_distinct_subtrees; /**< number of classes (by iso.) of subtrees */\n",
            "    /**\n",
            "     * - 0 <= iso_id[u] < num_distinct_subtrees\n",
            "     * - iso_id[u] == iso_id[v] iff subtree u is isomorphic to subtree v\n",
            "     */\n",
            "    vector<int> iso_id;\n",
            "    /**\n",
            "     * @param adj rooted forest (rooted or unrooted)\n",
            "     * @time O(n log n)\n",
            "     * @space `iso_id` and `hashes` both are O(n)\n",
            "     */\n",
            "    subtree_iso(const vector<vector<int>>& adj) : iso_id(ssize(adj), -1) {\n",
            "        map<vector<int>, int> hashes;\n",
            "        auto dfs = [&](auto&& self, int u, int p) -> int {\n",
            "            vector<int> ch_ids;\n",
            "            ch_ids.reserve(ssize(adj[u]));\n",
            "            for (int v : adj[u])\n",
            "                if (v != p) ch_ids.push_back(self(self, v, u));\n",
            "            sort(begin(ch_ids), end(ch_ids));\n",
            "            return iso_id[u] = hashes.try_emplace(ch_ids, ssize(hashes)).first->second;\n",
            "        };\n",
            "        for (int i = 0; i < ssize(adj); i++)\n",
            "            if (iso_id[i] == -1) dfs(dfs, i, i);\n",
            "        num_distinct_subtrees = ssize(hashes);\n",
            "    }\n",
            "};\n"
        ],
        "description": "@code{.cpp} @endcode"
    },
    "dijkstra": {
        "scope": "cpp",
        "prefix": [
            "lrv_dijkstra"
        ],
        "body": [
            "vector<long long> dijkstra(const vector<vector<pair<int, long long>>>& adj, int s) {\n",
            "    using node = pair<long long, int>;\n",
            "    vector d(ssize(adj), LLONG_MAX);\n",
            "    d[s] = 0;\n",
            "    priority_queue<node, vector<node>, greater<node>> pq;\n",
            "    pq.emplace(0, s);\n",
            "    while (!empty(pq)) {\n",
            "        auto [d_u, u] = pq.top();\n",
            "        pq.pop();\n",
            "        if (d[u] < d_u) continue;//important check: O(n*m) without it\n",
            "        for (auto [v, w] : adj[u])\n",
            "            if (d[v] > w + d[u]) {\n",
            "                d[v] = w + d[u];\n",
            "                pq.emplace(d[v], v);\n",
            "            }\n",
            "    }\n",
            "    return d;\n",
            "}\n"
        ],
        "description": "@param adj directed or undirected, weighted graph @param s a node @returns array `d` where `d[i]` = shortest path from node `s` to node `i`. `d[s]` is always 0. @time O((n + m) log n) Note log(m) < log(n^2) = 2*log(n), so O(log n) == O(log m) @space besides the O(n + m) param `adj`, this function allocates/returns a O(n) distance array. The (temporary) priority queue can grow to size O(n+m)"
    },
    "random": {
        "scope": "cpp",
        "prefix": [
            "lrv_random"
        ],
        "body": [
            "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n",
            "       mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n",
            "       unsigned long long x = rng();\n",
            "       // fixed seed for debugging\n",
            "       mt19937 rng;\n",
            "       unsigned int x = rng();\n",
            "       //\n",
            "       vector<int> a(n);\n",
            "       shuffle(begin(a), end(a), rng);\n",
            "       //\n",
            "       int x = get_rand(0, 1);\n",
            "       long long x = get_rand<long long>(1, 1e18);\n",
            "template <class T> inline T get_rand(T le, T ri) {\n",
            "    assert(le <= ri);\n",
            "    return uniform_int_distribution<T>(le, ri)(rng);\n",
            "}\n"
        ],
        "description": "@see https://codeforces.com/blog/entry/61675 @code{.cpp} @endcode @param le,ri defines range [le, ri] @returns random number in range, chosen with probability 1/(ri - le + 1)"
    },
    "and_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_and_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "vector<int> and_convolution(vector<int> a, vector<int> b) {\n",
            "    int n = __lg(ssize(a));\n",
            "    assert(ssize(a) == ssize(b) && (1 << n) == ssize(a));\n",
            "    for (int i = 0; i < n; i++)\n",
            "        for (int j = 0; j < (1 << n); j++)\n",
            "            if (!((j >> i) & 1)) {\n",
            "                a[j] = (a[j] + a[j ^ (1 << i)]) % mod;\n",
            "                b[j] = (b[j] + b[j ^ (1 << i)]) % mod;\n",
            "            }\n",
            "    vector<int> c(1 << n);\n",
            "    for (int i = 0; i < (1 << n); i++)\n",
            "        c[i] = 1LL * a[i] * b[i] % mod;\n",
            "    for (int i = 0; i < n; i++)\n",
            "        for (int j = 0; j < (1 << n); j++)\n",
            "            if (!((j >> i) & 1))\n",
            "                c[j] = (c[j] - c[j ^ (1 << i)] + mod) % mod;\n",
            "    return c;\n",
            "}\n"
        ],
        "description": "@param a,b arrays of the same length, where the length is a power of 2 @returns array `c` where `c[k]` = the sum of (a[i] * b[j]) for all pairs (i,j) where i & j == k @time O(2^n * n) @space a size O(2^n) vector is allocated and returned"
    },
    "lcm_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_lcm_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "vector<int> lcm_convolution(const vector<int>& a, const vector<int>& b) {\n",
            "    assert(ssize(a) == ssize(b));\n",
            "    int n = ssize(a);\n",
            "    vector sum_a(n, 0LL), sum_b(n, 0LL);\n",
            "    vector<int> c(n);\n",
            "    for (int i = 1; i < n; i++) {\n",
            "        for (int j = i; j < n; j += i)\n",
            "            sum_a[j] += a[i], sum_b[j] += b[i];\n",
            "        sum_a[i] %= mod, sum_b[i] %= mod;\n",
            "        c[i] = (c[i] + sum_a[i] * sum_b[i]) % mod;\n",
            "        for (int j = i + i; j < n; j += i)\n",
            "            if ((c[j] -= c[i]) < 0) c[j] += mod;\n",
            "    }\n",
            "    return c;\n",
            "}\n"
        ],
        "description": "@param a,b arrays of the same length @returns array `c` where `c[k]` = the sum of (a[i] * b[j]) for all pairs (i,j) where lcm(i,j) == k @time O(n log n) @space this function allocates/returns various O(n) vectors"
    },
    "gcd_convolution": {
        "scope": "cpp",
        "prefix": [
            "lrv_gcd_convolution"
        ],
        "body": [
            "const int mod = 998'244'353;\n",
            "vector<int> gcd_convolution(const vector<int>& a, const vector<int>& b) {\n",
            "    assert(ssize(a) == ssize(b));\n",
            "    int n = ssize(a);\n",
            "    vector<int> c(n);\n",
            "    for (int g = n - 1; g >= 1; g--) {\n",
            "        auto sum_a = 0LL, sum_b = 0LL;\n",
            "        for (int i = g; i < n; i += g) {\n",
            "            sum_a += a[i], sum_b += b[i];\n",
            "            if ((c[g] -= c[i]) < 0) c[g] += mod;\n",
            "        }\n",
            "        sum_a %= mod, sum_b %= mod;\n",
            "        c[g] = (c[g] + sum_a * sum_b) % mod;\n",
            "    }\n",
            "    return c;\n",
            "}\n"
        ],
        "description": "@param a,b arrays of the same length @returns array `c` where `c[k]` = the sum of (a[i] * b[j]) for all pairs (i,j) where gcd(i,j) == k @time O(n log n) @space a size O(n) vector is allocated and returned"
    },
    "min_cost_max_flow": {
        "scope": "cpp",
        "prefix": [
            "lrv_min_cost_max_flow"
        ],
        "body": [
            "struct mcmf {\n",
            "    using ll = long long;\n",
            "    struct edge {\n",
            "        int u, v;\n",
            "        ll cap, cost, flow;\n",
            "        int back;\n",
            "    };\n",
            "    int n;\n",
            "    vector<edge> e;\n",
            "    vector<vector<int>> adj;\n",
            "    /**\n",
            "     * @param a_n number of nodes.\n",
            "     */\n",
            "    mcmf(int a_n) : n(a_n), adj(n) {}\n",
            "    void add_edge(int u, int v, ll cap, ll cost) {\n",
            "        edge e1 = {u, v, cap, cost, 0, ssize(adj[v])};\n",
            "        edge e2 = {v, u, 0, -cost, 0, ssize(adj[u])};\n",
            "        adj[u].push_back(ssize(e));\n",
            "        e.push_back(e1);\n",
            "        adj[v].push_back(ssize(e));\n",
            "        e.push_back(e2);\n",
            "    }\n",
            "    /**\n",
            "     * @param s source, 0 <= s < n\n",
            "     * @param t sink, 0 <= t < n\n",
            "     * @param total_flow we try to send this amount of flow through the graph\n",
            "     * @returns array of {flow, cost}\n",
            "     * - flow: (<=total_flow) is the max amount of flow we are able to send.\n",
            "     * - cost: minimum sum of: (edge.flow * edge.cost) over each edge (over all\n",
            "     *   ways to send `flow` flow)\n",
            "     */\n",
            "    array<ll, 2> get_flow(int s, int t, ll total_flow) {\n",
            "        ll flow = 0, cost = 0;\n",
            "        while (flow < total_flow) {\n",
            "            vector d(n, LLONG_MAX);\n",
            "            vector<int> p_edge(n), id(n), q(n), p(n);\n",
            "            int qh = 0, qt = 0;\n",
            "            q[qt++] = s;\n",
            "            d[s] = 0;\n",
            "            while (qh != qt) {\n",
            "                int u = q[qh++];\n",
            "                id[u] = 2;\n",
            "                if (qh == n) qh = 0;\n",
            "                for (int i = 0; i < ssize(adj[u]); i++) {\n",
            "                    edge& r = e[adj[u][i]];\n",
            "                    if (r.flow < r.cap && d[u] + r.cost < d[r.v]) {\n",
            "                        d[r.v] = d[u] + r.cost;\n",
            "                        if (id[r.v] == 0) {\n",
            "                            q[qt++] = r.v;\n",
            "                            if (qt == n) qt = 0;\n",
            "                        } else if (id[r.v] == 2) {\n",
            "                            if (--qh == -1) qh = n - 1;\n",
            "                            q[qh] = r.v;\n",
            "                        }\n",
            "                        id[r.v] = 1;\n",
            "                        p[r.v] = u;\n",
            "                        p_edge[r.v] = i;\n",
            "                    }\n",
            "                }\n",
            "            }\n",
            "            if (d[t] == LLONG_MAX) break;\n",
            "            ll addflow = total_flow - flow;\n",
            "            for (int u = t; u != s; u = p[u]) {\n",
            "                int pv = p[u], pr = p_edge[u];\n",
            "                addflow = min(addflow, e[adj[pv][pr]].cap - e[adj[pv][pr]].flow);\n",
            "            }\n",
            "            for (int u = t; u != s; u = p[u]) {\n",
            "                int pv = p[u], pr = p_edge[u], r = e[adj[pv][pr]].back;\n",
            "                e[adj[pv][pr]].flow += addflow;\n",
            "                e[adj[u][r]].flow -= addflow;\n",
            "                cost += e[adj[pv][pr]].cost * addflow;\n",
            "            }\n",
            "            flow += addflow;\n",
            "        }\n",
            "        return {flow, cost};\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://e-maxx.ru/algo/min_cost_flow"
    },
    "hungarian": {
        "scope": "cpp",
        "prefix": [
            "lrv_hungarian"
        ],
        "body": [
            "       auto [min_weight, l_to_r] = hungarian(cost);\n",
            "struct hungarian {\n",
            "    long long min_weight; /**< sum of edge weights in matching */\n",
            "    vector<int> l_to_r; /**< edge v <=> l_to_r[v] is in the matching, 1<=v<=n; 1<=l_to_r[v]<=m */\n",
            "    /**\n",
            "     * @param cost (n+1)-by-(m+1) array: cost[u][v] = weight (can be negative) of\n",
            "     * the edge u <=> v, 1<=u<=n; 1<=v<=m, n<=m\n",
            "     * @time O(n^2 * m)\n",
            "     * @space besides the O(n * m) `cost` param, this allocates `l_to_r`\n",
            "     * which is O(n), and various O(m) arrays are also allocated temporarily\n",
            "     */\n",
            "    hungarian(const vector<vector<long long>>& cost) : l_to_r(ssize(cost)) {\n",
            "        int n = ssize(cost) - 1, m = ssize(cost[0]) - 1;\n",
            "        assert(n <= m);\n",
            "        vector<int> p(m + 1), way(m + 1);\n",
            "        vector u(n + 1, 0LL), v(m + 1, 0LL);\n",
            "        for (int i = 1; i <= n; i++) {\n",
            "            p[0] = i;\n",
            "            int j0 = 0;\n",
            "            vector minv(m + 1, LLONG_MAX);\n",
            "            vector<bool> used(m + 1);\n",
            "            do {\n",
            "                used[j0] = 1;\n",
            "                int i0 = p[j0], j1 = 0;\n",
            "                auto delta = LLONG_MAX;\n",
            "                for (int j = 1; j <= m; j++)\n",
            "                    if (!used[j]) {\n",
            "                        auto cur = cost[i0][j] - u[i0] - v[j];\n",
            "                        if (cur < minv[j]) minv[j] = cur, way[j] = j0;\n",
            "                        if (minv[j] < delta) delta = minv[j], j1 = j;\n",
            "                    }\n",
            "                for (int j = 0; j <= m; j++)\n",
            "                    if (used[j]) u[p[j]] += delta, v[j] -= delta;\n",
            "                    else minv[j] -= delta;\n",
            "                j0 = j1;\n",
            "            } while (p[j0] != 0);\n",
            "            do {\n",
            "                int j1 = way[j0];\n",
            "                p[j0] = p[j1];\n",
            "                j0 = j1;\n",
            "            } while (j0);\n",
            "        }\n",
            "        for (int j = 1; j <= m; j++) l_to_r[p[j]] = j;\n",
            "        min_weight = -v[0];\n",
            "    }\n",
            "};\n"
        ],
        "description": "@see https://e-maxx.ru/algo/assignment_hungary @code{.cpp} @endcode complete bipartite graph with n <= m, this matching always has size n. Of all ways to do this, sum of edge weights is minimized."
    }
}