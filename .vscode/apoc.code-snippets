{
    "MinRotation": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinRotation"
        ],
        "body": [
            "\n",
            "int minRotation(string s) {\n",
            "\tint a=0, N=sz(s); s += s;\n",
            "\trep(b,0,N) rep(k,0,N) {\n",
            "\t\tif (a+k == b || s[a+k] < s[b+k]) {b += max(0, k-1); break;}\n",
            "\t\tif (s[a+k] > s[b+k]) { a = b; break; }\n",
            "\t}\n",
            "\treturn a;\n",
            "}\n"
        ],
        "description": "O(N) | Finds the lexicographically smallest rotation of a string."
    },
    "SuffixAutomaton": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixAutomaton"
        ],
        "body": [
            "\n",
            "struct st { int len, pos, term; st *link; map<char, st*> next; };\n",
            "st *suffixAutomaton(string &str) {\n",
            "\tst *last = new st(), *root = last;\n",
            "\tfor(auto c : str) {\n",
            "\t\tst *p = last, *cur = last = new st{last->len + 1, last->len};\n",
            "\t\twhile(p && !p->next.count(c))\n",
            "\t\t\tp->next[c] = cur, p = p->link;\n",
            "\t\tif (!p) cur->link = root;\n",
            "\t\telse {\n",
            "\t\t\tst *q = p->next[c];\n",
            "\t\t\tif (p->len + 1 == q->len) cur->link = q;\n",
            "\t\t\telse {\n",
            "\t\t\t\tst *clone = new st{p->len+1, q->pos, 0, q->link, q->next};\n",
            "\t\t\t\tfor (; p && p->next[c] == q; p = p->link)\n",
            "\t\t\t\t\tp->next[c] = clone;\n",
            "\t\t\t\tq->link = cur->link = clone;\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t}\n",
            "\twhile(last) last->term = 1, last = last->link;\n",
            "\treturn root;\n",
            "}\n"
        ],
        "description": "construction takes $O(N\\log K)$, where $K =$ Alphabet Size. | Creates a partial DFA (DAG) that accepts all suffixes, with suffix links."
    },
    "AhoCorasick": {
        "scope": "cpp",
        "prefix": [
            "apoc_AhoCorasick"
        ],
        "body": [
            "\n",
            "struct AhoCorasick {\n",
            "\tenum {alpha = 26, first = 'A'}; // change this!\n",
            "\tstruct Node {\n",
            "\t\t// (nmatches is optional)\n",
            "\t\tint back, next[alpha], start = -1, end = -1, nmatches = 0;\n",
            "\t\tNode(int v) { memset(next, v, sizeof(next)); }\n",
            "\t};\n",
            "\tvector<Node> N;\n",
            "\tvi backp;\n",
            "\tvoid insert(string& s, int j) {\n",
            "\t\tassert(!s.empty());\n",
            "\t\tint n = 0;\n",
            "\t\tfor (char c : s) {\n",
            "\t\t\tint& m = N[n].next[c - first];\n",
            "\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }\n",
            "\t\t\telse n = m;\n",
            "\t\t}\n",
            "\t\tif (N[n].end == -1) N[n].start = j;\n",
            "\t\tbackp.push_back(N[n].end);\n",
            "\t\tN[n].end = j;\n",
            "\t\tN[n].nmatches++;\n",
            "\t}\n",
            "\tAhoCorasick(vector<string>& pat) : N(1, -1) {\n",
            "\t\trep(i,0,sz(pat)) insert(pat[i], i);\n",
            "\t\tN[0].back = sz(N);\n",
            "\t\tN.emplace_back(0);\n",
            "\n",
            "\t\tqueue<int> q;\n",
            "\t\tfor (q.push(0); !q.empty(); q.pop()) {\n",
            "\t\t\tint n = q.front(), prev = N[n].back;\n",
            "\t\t\trep(i,0,alpha) {\n",
            "\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];\n",
            "\t\t\t\tif (ed == -1) ed = y;\n",
            "\t\t\t\telse {\n",
            "\t\t\t\t\tN[ed].back = y;\n",
            "\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])\n",
            "\t\t\t\t\t\t= N[y].end;\n",
            "\t\t\t\t\tN[ed].nmatches += N[y].nmatches;\n",
            "\t\t\t\t\tq.push(ed);\n",
            "\t\t\t\t}\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t}\n",
            "\tvi find(string word) {\n",
            "\t\tint n = 0;\n",
            "\t\tvi res; // ll count = 0;\n",
            "\t\tfor (char c : word) {\n",
            "\t\t\tn = N[n].next[c - first];\n",
            "\t\t\tres.push_back(N[n].end);\n",
            "\t\t\t// count += N[n].nmatches;\n",
            "\t\t}\n",
            "\t\treturn res;\n",
            "\t}\n",
            "\tvector<vi> findAll(vector<string>& pat, string word) {\n",
            "\t\tvi r = find(word);\n",
            "\t\tvector<vi> res(sz(word));\n",
            "\t\trep(i,0,sz(word)) {\n",
            "\t\t\tint ind = r[i];\n",
            "\t\t\twhile (ind != -1) {\n",
            "\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);\n",
            "\t\t\t\tind = backp[ind];\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\treturn res;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "construction takes $O(26N)$, where $N =$ sum of length of patterns. | Aho-Corasick automaton, used for multiple pattern matching."
    },
    "Manacher": {
        "scope": "cpp",
        "prefix": [
            "apoc_Manacher"
        ],
        "body": [
            "\n",
            "array<vi, 2> manacher(const string& s) {\n",
            "\tint n = sz(s);\n",
            "\tarray<vi,2> p = {vi(n+1), vi(n)};\n",
            "\trep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {\n",
            "\t\tint t = r-i+!z;\n",
            "\t\tif (i<r) p[z][i] = min(t, p[z][l+t]);\n",
            "\t\tint L = i-p[z][i], R = i+p[z][i]-!z;\n",
            "\t\twhile (L>=1 && R+1<n && s[L-1] == s[R+1])\n",
            "\t\t\tp[z][i]++, L--, R++;\n",
            "\t\tif (R>r) l=L, r=R;\n",
            "\t}\n",
            "\treturn p;\n",
            "}\n"
        ],
        "description": "O(N) | For each position in a string, computes p[0][i] = half length of"
    },
    "Zfunc": {
        "scope": "cpp",
        "prefix": [
            "apoc_Zfunc"
        ],
        "body": [
            "\n",
            "vi Z(string S) {\n",
            "\tvi z(sz(S));\n",
            "\tint l = -1, r = -1;\n",
            "\trep(i,1,sz(S)) {\n",
            "\t\tz[i] = i >= r ? 0 : min(r - i, z[i - l]);\n",
            "\t\twhile (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])\n",
            "\t\t\tz[i]++;\n",
            "\t\tif (i + z[i] > r)\n",
            "\t\t\tl = i, r = i + z[i];\n",
            "\t}\n",
            "\treturn z;\n",
            "}\n"
        ],
        "description": "O(n) | z[x] computes the length of the longest common prefix of s[i:] and s, except z[0] = 0. (abacaba -> 0010301)"
    },
    "KMP": {
        "scope": "cpp",
        "prefix": [
            "apoc_KMP"
        ],
        "body": [
            "\n",
            "vi pi(const string& s) {\n",
            "\tvi p(sz(s));\n",
            "\trep(i,1,sz(s)) {\n",
            "\t\tint g = p[i-1];\n",
            "\t\twhile (g && s[i] != s[g]) g = p[g-1];\n",
            "\t\tp[i] = g + (s[i] == s[g]);\n",
            "\t}\n",
            "\treturn p;\n",
            "}\n",
            "\n",
            "vi match(const string& s, const string& pat) {\n",
            "\tvi p = pi(pat + '\\0' + s), res;\n",
            "\trep(i,sz(p)-sz(s),sz(p))\n",
            "\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(n) | pi[x] computes the length of the longest prefix of s that ends at x, other than s[0...x] itself (abacaba -> 0010123)."
    },
    "Eertree": {
        "scope": "cpp",
        "prefix": [
            "apoc_Eertree"
        ],
        "body": [
            "\n",
            "\n",
            "struct Eertree {\n",
            "\tvector<int> slink = {0, 0}, len = {-1, 0};\n",
            "\tvector<vector<int>> down;\n",
            "\tint cur = 0, t = 0;\n",
            "\tEertree(string &str) : down(2, vector<int>(26, -1)) {\n",
            "\t\tfor (int i = 0; i < str.size(); i++) {\n",
            "\t\t\tchar c = str[i]; int ci = c - 'a';\n",
            "\t\t\twhile (t <= 0 || str[t-1] != c) \n",
            "\t\t\tt = i - len[cur = slink[cur]];\n",
            "\t\t\tif (down[cur][ci] == -1) {\n",
            "\t\t\tdown[cur][ci] = slink.size();\n",
            "\t\t\tdown.emplace_back(26, -1);\n",
            "\t\t\tlen.push_back(len[cur] + 2);\n",
            "\t\t\tif (len.back() > 1) {\n",
            "\t\t\t\tdo t = i - len[cur = slink[cur]];\n",
            "\t\t\t\twhile(t <= 0 || str[t-1] != c);\n",
            "\t\t\t\tslink.push_back(down[cur][ci]);\n",
            "\t\t\t} else slink.push_back(1);\n",
            "\t\t\tcur = slink.size() - 1;\n",
            "\t\t\t} else cur = down[cur][ci];\n",
            "\t\t\tt = i - len[cur] + 1;\n",
            "\t\t}\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(|S|)$ | Generates an eertree on str. $cur$ is accurate at the end of the main loop before the final assignment to $t$."
    },
    "SuffixArray": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixArray"
        ],
        "body": [
            "\n",
            "struct SuffixArray {\n",
            "\tvi sa, lcp;\n",
            "\tSuffixArray(string& s, int lim=256) { // or basic_string<int>\n",
            "\t\tint n = sz(s) + 1, k = 0, a, b;\n",
            "\t\tvi x(all(s)+1), y(n), ws(max(n, lim)), rank(n);\n",
            "\t\tsa = lcp = y, iota(all(sa), 0);\n",
            "\t\tfor (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {\n",
            "\t\t\tp = j, iota(all(y), n - j);\n",
            "\t\t\trep(i,0,n) if (sa[i] >= j) y[p++] = sa[i] - j;\n",
            "\t\t\tfill(all(ws), 0);\n",
            "\t\t\trep(i,0,n) ws[x[i]]++;\n",
            "\t\t\trep(i,1,lim) ws[i] += ws[i - 1];\n",
            "\t\t\tfor (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];\n",
            "\t\t\tswap(x, y), p = 1, x[sa[0]] = 0;\n",
            "\t\t\trep(i,1,n) a = sa[i - 1], b = sa[i], x[b] =\n",
            "\t\t\t\t(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;\n",
            "\t\t}\n",
            "\t\trep(i,1,n) rank[sa[i]] = i;\n",
            "\t\tfor (int i = 0, j; i < n - 1; lcp[rank[i++]] = k)\n",
            "\t\t\tfor (k && k--, j = sa[rank[i] - 1];\n",
            "\t\t\t\t\ts[i + k] == s[j + k]; k++);\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(n \\log n) | Builds suffix array for a string."
    },
    "SuffixTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixTree"
        ],
        "body": [
            "\n",
            "struct SuffixTree {\n",
            "\tenum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10\n",
            "\tint toi(char c) { return c - 'a'; }\n",
            "\tstring a; // v = cur node, q = cur position\n",
            "\tint t[N][ALPHA],l[N],r[N],p[N],s[N],v=0,q=0,m=2;\n",
            "\n",
            "\tvoid ukkadd(int i, int c) { suff:\n",
            "\t\tif (r[v]<=q) {\n",
            "\t\t\tif (t[v][c]==-1) { t[v][c]=m;  l[m]=i;\n",
            "\t\t\t\tp[m++]=v; v=s[v]; q=r[v];  goto suff; }\n",
            "\t\t\tv=t[v][c]; q=l[v];\n",
            "\t\t}\n",
            "\t\tif (q==-1 || c==toi(a[q])) q++; else {\n",
            "\t\t\tl[m+1]=i;  p[m+1]=m;  l[m]=l[v];  r[m]=q;\n",
            "\t\t\tp[m]=p[v];  t[m][c]=m+1;  t[m][toi(a[q])]=v;\n",
            "\t\t\tl[v]=q;  p[v]=m;  t[p[m]][toi(a[l[m]])]=m;\n",
            "\t\t\tv=s[p[m]];  q=l[m];\n",
            "\t\t\twhile (q<r[m]) { v=t[v][toi(a[q])];  q+=r[v]-l[v]; }\n",
            "\t\t\tif (q==r[m])  s[m]=v;  else s[m]=m+2;\n",
            "\t\t\tq=r[v]-(q-r[m]);  m+=2;  goto suff;\n",
            "\t\t}\n",
            "\t}\n",
            "\n",
            "\tSuffixTree(string a) : a(a) {\n",
            "\t\tfill(r,r+N,sz(a));\n",
            "\t\tmemset(s, 0, sizeof s);\n",
            "\t\tmemset(t, -1, sizeof t);\n",
            "\t\tfill(t[1],t[1]+ALPHA,0);\n",
            "\t\ts[0] = 1; l[0] = l[1] = -1; r[0] = r[1] = p[0] = p[1] = 0;\n",
            "\t\trep(i,0,sz(a)) ukkadd(i, toi(a[i]));\n",
            "\t}\n",
            "\n",
            "\t// example: find longest common substring (uses ALPHA = 28)\n",
            "\tpii best;\n",
            "\tint lcs(int node, int i1, int i2, int olen) {\n",
            "\t\tif (l[node] <= i1 && i1 < r[node]) return 1;\n",
            "\t\tif (l[node] <= i2 && i2 < r[node]) return 2;\n",
            "\t\tint mask = 0, len = node ? olen + (r[node] - l[node]) : 0;\n",
            "\t\trep(c,0,ALPHA) if (t[node][c] != -1)\n",
            "\t\t\tmask |= lcs(t[node][c], i1, i2, len);\n",
            "\t\tif (mask == 3)\n",
            "\t\t\tbest = max(best, {len, r[node] - len});\n",
            "\t\treturn mask;\n",
            "\t}\n",
            "\tstatic pii LCS(string s, string t) {\n",
            "\t\tSuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));\n",
            "\t\tst.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);\n",
            "\t\treturn st.best;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(26N)$ | Ukkonen's algorithm for online suffix tree construction."
    },
    "AhoCorasick-Tyler": {
        "scope": "cpp",
        "prefix": [
            "apoc_AhoCorasick-Tyler"
        ],
        "body": [
            "\n",
            "const int ABSIZE = 26;\n",
            " \n",
            "struct node {\n",
            "    int nxt[ABSIZE];\n",
            "    vi ids = {};\n",
            "    int prv = -1, link = -1;\n",
            "    char c;\n",
            "    int linkMemo[ABSIZE];\n",
            " \n",
            "    node(int prv = -1, char c = '$'): prv(prv), c(c) {\n",
            "        fill(all(nxt), -1);\n",
            "        fill(all(linkMemo), -1);\n",
            "    }\n",
            "};\n",
            " \n",
            "vector<node> trie(1);\n",
            " \n",
            "void addWord(string &s, int id) {\n",
            "    int cur = 0;\n",
            "    for(char c: s) {\n",
            "        int idx = c - 'a';\n",
            "        if(trie[cur].nxt[idx] == -1) {\n",
            "            trie[cur].nxt[idx] = sz(trie);\n",
            "            trie.emplace_back(cur, c);\n",
            "        }\n",
            "        cur = trie[cur].nxt[idx];\n",
            "    }\n",
            "    trie[cur].ids.push_back(id);\n",
            "}\n",
            " \n",
            "int getLink(int cur);\n",
            " \n",
            "int calc(int cur, char c) {\n",
            "    int idx = c - 'a';\n",
            "    auto &ret = trie[cur].linkMemo[idx];\n",
            "    if(ret != -1) return ret;\n",
            "    if(trie[cur].nxt[idx] != -1)\n",
            "        return ret = trie[cur].nxt[idx];\n",
            "    return ret = cur == 0 ? 0 : calc(getLink(cur), c);\n",
            "}\n",
            " \n",
            "int getLink(int cur) {\n",
            "    auto &ret = trie[cur].link;\n",
            "    if(ret != -1) return ret;\n",
            "    if(cur == 0 || trie[cur].prv == 0) return ret = 0;\n",
            "    return ret = calc(getLink(trie[cur].prv), trie[cur].c);\n",
            "}"
        ],
        "description": "construction takes $O(26N)$, where $N =$ sum of length of patterns. | Aho-Corasick automaton, used for multiple pattern matching."
    },
    "Hashing-codeforces": {
        "scope": "cpp",
        "prefix": [
            "apoc_Hashing-codeforces"
        ],
        "body": [
            "\n",
            "typedef uint64_t ull;\n",
            "static int C; // initialized below\n",
            "\n",
            "// Arithmetic mod two primes and 2^32 simultaneously.\n",
            "// \"typedef uint64_t H;\" instead if Thue-Morse does not apply.\n",
            "template<int M, class B>\n",
            "struct A {\n",
            "\tint x; B b; A(int x=0) : x(x), b(x) {}\n",
            "\tA(int x, B b) : x(x), b(b) {}\n",
            "\tA operator+(A o){int y = x+o.x; return{y - (y>=M)*M, b+o.b};}\n",
            "\tA operator-(A o){int y = x-o.x; return{y + (y< 0)*M, b-o.b};}\n",
            "\tA operator*(A o) { return {(int)(1LL*x*o.x % M), b*o.b}; }\n",
            "\texplicit operator ull() { return x ^ (ull) b << 21; }\n",
            "};\n",
            "typedef A<1000000007, A<1000000009, unsigned>> H;\n",
            "\n",
            "struct HashInterval {\n",
            "\tvector<H> ha, pw;\n",
            "\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {\n",
            "\t\tpw[0] = 1;\n",
            "\t\trep(i,0,sz(str))\n",
            "\t\t\tha[i+1] = ha[i] * C + str[i],\n",
            "\t\t\tpw[i+1] = pw[i] * C;\n",
            "\t}\n",
            "\tH hashInterval(int a, int b) { // hash [a, b)\n",
            "\t\treturn ha[b] - ha[a] * pw[b - a];\n",
            "\t}\n",
            "};\n",
            "\n",
            "vector<H> getHashes(string& str, int length) {\n",
            "\tif (sz(str) < length) return {};\n",
            "\tH h = 0, pw = 1;\n",
            "\trep(i,0,length)\n",
            "\t\th = h * C + str[i], pw = pw * C;\n",
            "\tvector<H> ret = {h};\n",
            "\trep(i,length,sz(str)) {\n",
            "\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n",
            "\n",
            "H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n",
            "\n",
            "int main() {\n",
            "\ttimeval tp;\n",
            "\tgettimeofday(&tp, 0);\n",
            "\tC = (int)tp.tv_usec; // (less than modulo)\n",
            "\tassert((ull)(H(1)*2+1-3) == 0);\n",
            "\t// ...\n",
            "}\n"
        ],
        "description": "Various self-explanatory methods for string hashing."
    },
    "Hashing": {
        "scope": "cpp",
        "prefix": [
            "apoc_Hashing"
        ],
        "body": [
            "\n",
            "// Arithmetic mod 2^64-1. 2x slower than mod 2^64 and more\n",
            "// code, but works on evil test data (e.g. Thue-Morse, where\n",
            "// ABBA... and BAAB... of length 2^10 hash the same mod 2^64).\n",
            "// \"typedef ull H;\" instead if you think test data is random,\n",
            "// or work mod 10^9+7 if the Birthday paradox is not a problem.\n",
            "typedef uint64_t ull;\n",
            "struct H {\n",
            "\tull x; H(ull x=0) : x(x) {}\n",
            "\tH operator+(H o) { return x + o.x + (x + o.x < x); }\n",
            "\tH operator-(H o) { return *this + ~o.x; }\n",
            "\tH operator*(H o) { auto m = (__uint128_t)x * o.x;\n",
            "\t\treturn H((ull)m) + (ull)(m >> 64); }\n",
            "\tull get() const { return x + !~x; }\n",
            "\tbool operator==(H o) const { return get() == o.get(); }\n",
            "\tbool operator<(H o) const { return get() < o.get(); }\n",
            "};\n",
            "static const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)\n",
            "\n",
            "struct HashInterval {\n",
            "\tvector<H> ha, pw;\n",
            "\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {\n",
            "\t\tpw[0] = 1;\n",
            "\t\trep(i,0,sz(str))\n",
            "\t\t\tha[i+1] = ha[i] * C + str[i],\n",
            "\t\t\tpw[i+1] = pw[i] * C;\n",
            "\t}\n",
            "\tH hashInterval(int a, int b) { // hash [a, b)\n",
            "\t\treturn ha[b] - ha[a] * pw[b - a];\n",
            "\t}\n",
            "};\n",
            "\n",
            "vector<H> getHashes(string& str, int length) {\n",
            "\tif (sz(str) < length) return {};\n",
            "\tH h = 0, pw = 1;\n",
            "\trep(i,0,length)\n",
            "\t\th = h * C + str[i], pw = pw * C;\n",
            "\tvector<H> ret = {h};\n",
            "\trep(i,length,sz(str)) {\n",
            "\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n",
            "\n",
            "H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}\n"
        ],
        "description": "Self-explanatory methods for string hashing."
    },
    "FenwickTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_FenwickTree"
        ],
        "body": [
            "\n",
            "struct FT {\n",
            "\tvector<ll> s;\n",
            "\tFT(int n) : s(n) {}\n",
            "\tvoid update(int pos, ll dif) { // a[pos] += dif\n",
            "\t\tfor (; pos < sz(s); pos |= pos + 1) s[pos] += dif;\n",
            "\t}\n",
            "\tll query(int pos) { // sum of values in [0, pos)\n",
            "\t\tll res = 0;\n",
            "\t\tfor (; pos > 0; pos &= pos - 1) res += s[pos-1];\n",
            "\t\treturn res;\n",
            "\t}\n",
            "\tint lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum\n",
            "\t\t// Returns n if no sum is >= sum, or -1 if empty sum is.\n",
            "\t\tif (sum <= 0) return -1;\n",
            "\t\tint pos = 0;\n",
            "\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {\n",
            "\t\t\tif (pos + pw <= sz(s) && s[pos + pw-1] < sum)\n",
            "\t\t\t\tpos += pw, sum -= s[pos-1];\n",
            "\t\t}\n",
            "\t\treturn pos;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Both operations are $O(\\log N)$. | Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i],"
    },
    "Treap": {
        "scope": "cpp",
        "prefix": [
            "apoc_Treap"
        ],
        "body": [
            "\n",
            "struct node {\n",
            "    int val, prior, sz = 1;\n",
            "    node *left = nullptr, *right = nullptr;\n",
            "    node(int val = 0): val(val), prior(rand()) {}\n",
            "};\n",
            "\n",
            "int getSz(node *cur) { return cur ? cur->sz : 0; }\n",
            "void recalc(node *cur) { cur->sz = getSz(cur->left) + getSz(cur->right) + 1; }\n",
            "\n",
            "pair<node*, node*> split(node *cur, int v) {\n",
            "    if(!cur) return {nullptr, nullptr};\n",
            "    node *left, *right;\n",
            "    if(getSz(cur->left) >= v) {\n",
            "        right = cur;\n",
            "        auto [L, R] = split(cur->left, v);\n",
            "        left = L, right->left = R;\n",
            "        recalc(right);\n",
            "    }\n",
            "    else {\n",
            "        left = cur;\n",
            "        auto [L, R] = split(cur->right, v - getSz(cur->left) - 1);\n",
            "        left->right = L, right = R;\n",
            "        recalc(left);\n",
            "    } \n",
            "    return {left, right};\n",
            "}\n",
            "\n",
            "node* merge(node *t1, node *t2) {\n",
            "    if(!t1 || !t2) return t1 ? t1 : t2;\n",
            "    node *res;\n",
            "    if(t1->prior > t2->prior) {\n",
            "        res = t1;\n",
            "        res->right = merge(t1->right, t2);\n",
            "    }\n",
            "    else {\n",
            "        res = t2;\n",
            "        res->left = merge(t1, t2->left);\n",
            "    }\n",
            "    recalc(res);\n",
            "    return res;\n",
            "}"
        ],
        "description": "$O(\\log N)$ | A short self-balancing tree. It acts as a"
    },
    "LazySegmentTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_LazySegmentTree"
        ],
        "body": [
            "\n",
            "\n",
            "const int inf = 1e9;\n",
            "struct Node {\n",
            "\tNode *l = 0, *r = 0;\n",
            "\tint lo, hi, mset = inf, madd = 0, val = -inf;\n",
            "\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n",
            "\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {\n",
            "\t\tif (lo + 1 < hi) {\n",
            "\t\t\tint mid = lo + (hi - lo)/2;\n",
            "\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n",
            "\t\t\tval = max(l->val, r->val);\n",
            "\t\t}\n",
            "\t\telse val = v[lo];\n",
            "\t}\n",
            "\tint query(int L, int R) {\n",
            "\t\tif (R <= lo || hi <= L) return -inf;\n",
            "\t\tif (L <= lo && hi <= R) return val;\n",
            "\t\tpush();\n",
            "\t\treturn max(l->query(L, R), r->query(L, R));\n",
            "\t}\n",
            "\tvoid set(int L, int R, int x) {\n",
            "\t\tif (R <= lo || hi <= L) return;\n",
            "\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n",
            "\t\telse {\n",
            "\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n",
            "\t\t\tval = max(l->val, r->val);\n",
            "\t\t}\n",
            "\t}\n",
            "\tvoid add(int L, int R, int x) {\n",
            "\t\tif (R <= lo || hi <= L) return;\n",
            "\t\tif (L <= lo && hi <= R) {\n",
            "\t\t\tif (mset != inf) mset += x;\n",
            "\t\t\telse madd += x;\n",
            "\t\t\tval += x;\n",
            "\t\t}\n",
            "\t\telse {\n",
            "\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n",
            "\t\t\tval = max(l->val, r->val);\n",
            "\t\t}\n",
            "\t}\n",
            "\tvoid push() {\n",
            "\t\tif (!l) {\n",
            "\t\t\tint mid = lo + (hi - lo)/2;\n",
            "\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n",
            "\t\t}\n",
            "\t\tif (mset != inf)\n",
            "\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n",
            "\t\telse if (madd)\n",
            "\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(\\log N). | Segment tree with ability to add or set values of large intervals, and compute max of intervals."
    },
    "MoQueries": {
        "scope": "cpp",
        "prefix": [
            "apoc_MoQueries"
        ],
        "body": [
            "\n",
            "void add(int ind, int end) { ... } // add a[ind] (end = 0 or 1)\n",
            "void del(int ind, int end) { ... } // remove a[ind]\n",
            "int calc() { ... } // compute current answer\n",
            "\n",
            "vi mo(vector<pii> Q) {\n",
            "\tint L = 0, R = 0, blk = 350; // ~N/sqrt(Q)\n",
            "\tvi s(sz(Q)), res = s;\n",
            "#define K(x) pii(x.first/blk, x.second ^ -(x.first/blk & 1))\n",
            "\tiota(all(s), 0);\n",
            "\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });\n",
            "\tfor (int qi : s) {\n",
            "\t\tpii q = Q[qi];\n",
            "\t\twhile (L > q.first) add(--L, 0);\n",
            "\t\twhile (R < q.second) add(R++, 1);\n",
            "\t\twhile (L < q.first) del(L++, 0);\n",
            "\t\twhile (R > q.second) del(--R, 1);\n",
            "\t\tres[qi] = calc();\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n",
            "\n",
            "vi moTree(vector<array<int, 2>> Q, vector<vi>& ed, int root=0){\n",
            "\tint N = sz(ed), pos[2] = {}, blk = 350; // ~N/sqrt(Q)\n",
            "\tvi s(sz(Q)), res = s, I(N), L(N), R(N), in(N), par(N);\n",
            "\tadd(0, 0), in[0] = 1;\n",
            "\tauto dfs = [&](int x, int p, int dep, auto& f) -> void {\n",
            "\t\tpar[x] = p;\n",
            "\t\tL[x] = N;\n",
            "\t\tif (dep) I[x] = N++;\n",
            "\t\tfor (int y : ed[x]) if (y != p) f(y, x, !dep, f);\n",
            "\t\tif (!dep) I[x] = N++;\n",
            "\t\tR[x] = N;\n",
            "\t};\n",
            "\tdfs(root, -1, 0, dfs);\n",
            "#define K(x) pii(I[x[0]] / blk, I[x[1]] ^ -(I[x[0]] / blk & 1))\n",
            "\tiota(all(s), 0);\n",
            "\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });\n",
            "\tfor (int qi : s) rep(end,0,2) {\n",
            "\t\tint &a = pos[end], b = Q[qi][end], i = 0;\n",
            "#define step(c) { if (in[c]) { del(a, end); in[a] = 0; } \\\n",
            "                  else { add(c, end); in[c] = 1; } a = c; }\n",
            "\t\twhile (!(L[b] <= L[a] && R[a] <= R[b]))\n",
            "\t\t\tI[i++] = b, b = par[b];\n",
            "\t\twhile (a != b) step(par[a]);\n",
            "\t\twhile (i--) step(I[i]);\n",
            "\t\tif (end) res[qi] = calc();\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(N \\sqrt Q) | Answer interval or tree path queries by finding an approximate TSP through the queries,"
    },
    "Matrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_Matrix"
        ],
        "body": [
            "\n",
            "template<class T, int N> struct Matrix {\n",
            "\ttypedef Matrix M;\n",
            "\tarray<array<T, N>, N> d{};\n",
            "\tM operator*(const M& m) const {\n",
            "\t\tM a;\n",
            "\t\trep(i,0,N) rep(j,0,N)\n",
            "\t\t\trep(k,0,N) a.d[i][j] += d[i][k]*m.d[k][j];\n",
            "\t\treturn a;\n",
            "\t}\n",
            "\tvector<T> operator*(const vector<T>& vec) const {\n",
            "\t\tvector<T> ret(N);\n",
            "\t\trep(i,0,N) rep(j,0,N) ret[i] += d[i][j] * vec[j];\n",
            "\t\treturn ret;\n",
            "\t}\n",
            "\tM operator^(ll p) const {\n",
            "\t\tassert(p >= 0);\n",
            "\t\tM a, b(*this);\n",
            "\t\trep(i,0,N) a.d[i][i] = 1;\n",
            "\t\twhile (p) {\n",
            "\t\t\tif (p&1) a = a*b;\n",
            "\t\t\tb = b*b;\n",
            "\t\t\tp >>= 1;\n",
            "\t\t}\n",
            "\t\treturn a;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Basic operations on square matrices."
    },
    "HashMap": {
        "scope": "cpp",
        "prefix": [
            "apoc_HashMap"
        ],
        "body": [
            "\n",
            "// To use most bits rather than just the lowest ones:\n",
            "struct chash { // large odd number for C\n",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;\n",
            "\tll operator()(ll x) const { return __builtin_bswap64(x*C); }\n",
            "};\n",
            "__gnu_pbds::gp_hash_table<ll,int,chash> h({},{},{},{},{1<<16});\n",
            "\n",
            "\n",
            "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();\n",
            "struct chash { // To use most bits rather than just the lowest ones:\n",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number\n",
            "\tll operator()(ll x) const { return __builtin_bswap64((x^RANDOM)*C); }\n",
            "};\n",
            "__gnu_pbds::gp_hash_table<ll, int, chash> h({},{},{},{}, {1 << 16});\n",
            "*/\n"
        ],
        "description": "Hash map with mostly the same API as unordered\\_map, but \\tilde"
    },
    "SegmentTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentTree"
        ],
        "body": [
            "\n",
            "struct Tree {\n",
            "\ttypedef int T;\n",
            "\tstatic constexpr T unit = INT_MIN;\n",
            "\tT f(T a, T b) { return max(a, b); } // (any associative fn)\n",
            "\tvector<T> s; int n;\n",
            "\tTree(int n = 0, T def = unit) : s(2*n, def), n(n) {}\n",
            "\tvoid update(int pos, T val) {\n",
            "\t\tfor (s[pos += n] = val; pos /= 2;)\n",
            "\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);\n",
            "\t}\n",
            "\tT query(int b, int e) { // query [b, e)\n",
            "\t\tT ra = unit, rb = unit;\n",
            "\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {\n",
            "\t\t\tif (b % 2) ra = f(ra, s[b++]);\n",
            "\t\t\tif (e % 2) rb = f(s[--e], rb);\n",
            "\t\t}\n",
            "\t\treturn f(ra, rb);\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(\\log N) | Zero-indexed max-tree. Bounds are inclusive to the left and exclusive to the right. Can be changed by modifying T, f and unit."
    },
    "UnionFind": {
        "scope": "cpp",
        "prefix": [
            "apoc_UnionFind"
        ],
        "body": [
            "\n",
            "struct UF {\n",
            "\tvi e;\n",
            "\tUF(int n) : e(n, -1) {}\n",
            "\tbool sameSet(int a, int b) { return find(a) == find(b); }\n",
            "\tint size(int x) { return -e[find(x)]; }\n",
            "\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n",
            "\tbool join(int a, int b) {\n",
            "\t\ta = find(a), b = find(b);\n",
            "\t\tif (a == b) return false;\n",
            "\t\tif (e[a] > e[b]) swap(a, b);\n",
            "\t\te[a] += e[b]; e[b] = a;\n",
            "\t\treturn true;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(\\alpha(N))$ / | Disjoint-set data structure."
    },
    "PST": {
        "scope": "cpp",
        "prefix": [
            "apoc_PST"
        ],
        "body": [
            "\n",
            "\n",
            "struct PST {\n",
            "\tPST *l = 0, *r = 0;\n",
            "\tint lo, hi;\n",
            "\tll val = 0, lzadd = 0;\n",
            "\tPST(vl& v, int lo, int hi) : lo(lo), hi(hi) {\n",
            "\t\tif (lo + 1 < hi) {\n",
            "\t\t\tint mid = lo + (hi - lo)/2;\n",
            "\t\t\tl = new PST(v, lo, mid); r = new PST(v, mid, hi);\n",
            "\t\t}\n",
            "\t\telse val = v[lo];\n",
            "\t}\n",
            "\tll query(int L, int R) {\n",
            "\t\tif (R < lo || hi < L) return 0; // idempotent\n",
            "\t\tif (L <= lo && hi <= R) return val;\n",
            "\t\tpush();\n",
            "\t\treturn l->query(L, R) + r->query(L, R);\n",
            "\t}\n",
            "\tPST * add(int L, int R, ll v) {\n",
            "\t\tif (R <= lo || hi <= L) return this;\n",
            "\t\tPST *n;\n",
            "\t\tif (L <= lo && hi <= R) {\n",
            "\t\t\tn = new PST(*this);\n",
            "\t\t\tn->val += v;\n",
            "\t\t\tn->lzadd += v;\n",
            "\t\t} else {\n",
            "\t\t\tpush();\n",
            "\t\t\tn = new PST(*this);\n",
            "\t\t\tn->l = l->add(L, R, v);\n",
            "\t\t\tn->r = r->add(L, R, v);\n",
            "\t\t}\n",
            "\t\treturn n;\n",
            "\t}\n",
            "\tvoid push() {\n",
            "\t\tif(lzadd == 0) return;\n",
            "\t\tl = l->add(lo, hi, lzadd);\n",
            "\t\tr = r->add(lo, hi, lzadd);\n",
            "\t\tlzadd = 0;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(\\log N)$ per query, $O((n + q) \\log n)$ memory | Persistent segment tree with laziness"
    },
    "RMQ": {
        "scope": "cpp",
        "prefix": [
            "apoc_RMQ"
        ],
        "body": [
            "\n",
            "template<class T>\n",
            "struct RMQ {\n",
            "\tvector<vector<T>> jmp;\n",
            "\tRMQ(const vector<T>& V) : jmp(1, V) {\n",
            "\t\tfor (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {\n",
            "\t\t\tjmp.emplace_back(sz(V) - pw * 2 + 1);\n",
            "\t\t\trep(j,0,sz(jmp[k]))\n",
            "\t\t\t\tjmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);\n",
            "\t\t}\n",
            "\t}\n",
            "\tT query(int a, int b) {\n",
            "\t\tassert(a < b); // or return inf if a == b\n",
            "\t\tint dep = 31 - __builtin_clz(b - a);\n",
            "\t\treturn min(jmp[dep][a], jmp[dep][b - (1 << dep)]);\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(|V| \\log |V| + Q)$ | Range Minimum Queries on an array. Returns"
    },
    "FenwickTree2d": {
        "scope": "cpp",
        "prefix": [
            "apoc_FenwickTree2d"
        ],
        "body": [
            "\n",
            "\n",
            "struct FT2 {\n",
            "\tvector<vi> ys; vector<FT> ft;\n",
            "\tFT2(int limx) : ys(limx) {}\n",
            "\tvoid fakeUpdate(int x, int y) {\n",
            "\t\tfor (; x < sz(ys); x |= x + 1) ys[x].push_back(y);\n",
            "\t}\n",
            "\tvoid init() {\n",
            "\t\tfor (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));\n",
            "\t}\n",
            "\tint ind(int x, int y) {\n",
            "\t\treturn (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }\n",
            "\tvoid update(int x, int y, ll dif) {\n",
            "\t\tfor (; x < sz(ys); x |= x + 1)\n",
            "\t\t\tft[x].update(ind(x, y), dif);\n",
            "\t}\n",
            "\tll query(int x, int y) {\n",
            "\t\tll sum = 0;\n",
            "\t\tfor (; x; x &= x - 1)\n",
            "\t\t\tsum += ft[x-1].query(ind(x-1, y));\n",
            "\t\treturn sum;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(\\log^2 N)$. (Use persistent segment trees for $O(\\log N)$.) | Computes sums a[i,j] for all i<I, j<J, and increases single elements a[i,j]."
    },
    "OrderStatisticTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_OrderStatisticTree"
        ],
        "body": [
            "\n",
            "using namespace __gnu_pbds;\n",
            "\n",
            "template<class T>\n",
            "using Tree = tree<T, null_type, less<T>, rb_tree_tag,\n",
            "    tree_order_statistics_node_update>;\n",
            "\n",
            "void example() {\n",
            "\tTree<int> t, t2; t.insert(8);\n",
            "\tauto it = t.insert(10).first;\n",
            "\tassert(it == t.lower_bound(9));\n",
            "\tassert(t.order_of_key(10) == 1);\n",
            "\tassert(t.order_of_key(11) == 2);\n",
            "\tassert(*t.find_by_order(0) == 8);\n",
            "\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n",
            "}\n"
        ],
        "description": "O(\\log N) / | A set (not multiset!) with support for finding the n'th"
    },
    "UnionFindRollback": {
        "scope": "cpp",
        "prefix": [
            "apoc_UnionFindRollback"
        ],
        "body": [
            "\n",
            "struct RollbackUF {\n",
            "\tvi e; vector<pii> st;\n",
            "\tRollbackUF(int n) : e(n, -1) {}\n",
            "\tint size(int x) { return -e[find(x)]; }\n",
            "\tint find(int x) { return e[x] < 0 ? x : find(e[x]); }\n",
            "\tint time() { return sz(st); }\n",
            "\tvoid rollback(int t) {\n",
            "\t\tfor (int i = time(); i --> t;)\n",
            "\t\t\te[st[i].first] = st[i].second;\n",
            "\t\tst.resize(t);\n",
            "\t}\n",
            "\tbool join(int a, int b) {\n",
            "\t\ta = find(a), b = find(b);\n",
            "\t\tif (a == b) return false;\n",
            "\t\tif (e[a] > e[b]) swap(a, b);\n",
            "\t\tst.push_back({a, e[a]});\n",
            "\t\tst.push_back({b, e[b]});\n",
            "\t\te[a] += e[b]; e[b] = a;\n",
            "\t\treturn true;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "$O(\\log(N))$ | Disjoint-set data structure with undo."
    },
    "LineContainer": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineContainer"
        ],
        "body": [
            "\n",
            "struct Line {\n",
            "\tmutable ll k, m, p;\n",
            "\tbool operator<(const Line& o) const { return k < o.k; }\n",
            "\tbool operator<(ll x) const { return p < x; }\n",
            "};\n",
            "\n",
            "struct LineContainer : multiset<Line, less<>> {\n",
            "\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)\n",
            "\tstatic const ll inf = LLONG_MAX;\n",
            "\tll div(ll a, ll b) { // floored division\n",
            "\t\treturn a / b - ((a ^ b) < 0 && a % b); }\n",
            "\tbool isect(iterator x, iterator y) {\n",
            "\t\tif (y == end()) return x->p = inf, 0;\n",
            "\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;\n",
            "\t\telse x->p = div(y->m - x->m, x->k - y->k);\n",
            "\t\treturn x->p >= y->p;\n",
            "\t}\n",
            "\tvoid add(ll k, ll m) {\n",
            "\t\tauto z = insert({k, m, 0}), y = z++, x = y;\n",
            "\t\twhile (isect(y, z)) z = erase(z);\n",
            "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));\n",
            "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)\n",
            "\t\t\tisect(x, erase(y));\n",
            "\t}\n",
            "\tll query(ll x) {\n",
            "\t\tassert(!empty());\n",
            "\t\tauto l = *lower_bound(x);\n",
            "\t\treturn l.k * x + l.m;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(\\log N) | Container where you can add lines of the form kx+m, and query maximum values at points x."
    },
    "SubMatrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_SubMatrix"
        ],
        "body": [
            "\n",
            "template<class T>\n",
            "struct SubMatrix {\n",
            "\tvector<vector<T>> p;\n",
            "\tSubMatrix(vector<vector<T>>& v) {\n",
            "\t\tint R = sz(v), C = sz(v[0]);\n",
            "\t\tp.assign(R+1, vector<T>(C+1));\n",
            "\t\trep(r,0,R) rep(c,0,C)\n",
            "\t\t\tp[r+1][c+1] = v[r][c] + p[r][c+1] + p[r+1][c] - p[r][c];\n",
            "\t}\n",
            "\tT sum(int u, int l, int d, int r) {\n",
            "\t\treturn p[d][r] - p[d][l] - p[u][r] + p[u][l];\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(N^2 + Q) | Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open)."
    },
    "FastFourierTransformMod": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastFourierTransformMod"
        ],
        "body": [
            "\n",
            "\n",
            "typedef vector<ll> vl;\n",
            "template<int M> vl convMod(const vl &a, const vl &b) {\n",
            "\tif (a.empty() || b.empty()) return {};\n",
            "\tvl res(sz(a) + sz(b) - 1);\n",
            "\tint B=32-__builtin_clz(sz(res)), n=1<<B, cut=int(sqrt(M));\n",
            "\tvector<C> L(n), R(n), outs(n), outl(n);\n",
            "\trep(i,0,sz(a)) L[i] = C((int)a[i] / cut, (int)a[i] % cut);\n",
            "\trep(i,0,sz(b)) R[i] = C((int)b[i] / cut, (int)b[i] % cut);\n",
            "\tfft(L), fft(R);\n",
            "\trep(i,0,n) {\n",
            "\t\tint j = -i & (n - 1);\n",
            "\t\toutl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);\n",
            "\t\touts[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;\n",
            "\t}\n",
            "\tfft(outl), fft(outs);\n",
            "\trep(i,0,sz(res)) {\n",
            "\t\tll av = ll(real(outl[i])+.5), cv = ll(imag(outs[i])+.5);\n",
            "\t\tll bv = ll(imag(outl[i])+.5) + ll(real(outs[i])+.5);\n",
            "\t\tres[i] = ((av % M * cut + bv) % M * cut + cv) % M;\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(N \\log N), where $N = |A|+|B|$ (twice as slow as NTT or FFT) | Higher precision FFT, can be used for convolutions modulo arbitrary integers"
    },
    "BerlekampMassey": {
        "scope": "cpp",
        "prefix": [
            "apoc_BerlekampMassey"
        ],
        "body": [
            "\n",
            "\n",
            "vector<ll> berlekampMassey(vector<ll> s) {\n",
            "\tint n = sz(s), L = 0, m = 0;\n",
            "\tvector<ll> C(n), B(n), T;\n",
            "\tC[0] = B[0] = 1;\n",
            "\n",
            "\tll b = 1;\n",
            "\trep(i,0,n) { ++m;\n",
            "\t\tll d = s[i] % mod;\n",
            "\t\trep(j,1,L+1) d = (d + C[j] * s[i - j]) % mod;\n",
            "\t\tif (!d) continue;\n",
            "\t\tT = C; ll coef = d * modpow(b, mod-2) % mod;\n",
            "\t\trep(j,m,n) C[j] = (C[j] - coef * B[j - m]) % mod;\n",
            "\t\tif (2 * L > i) continue;\n",
            "\t\tL = i + 1 - L; B = T; b = d; m = 0;\n",
            "\t}\n",
            "\n",
            "\tC.resize(L + 1); C.erase(C.begin());\n",
            "\tfor (ll& x : C) x = (mod - x) % mod;\n",
            "\treturn C;\n",
            "}\n"
        ],
        "description": "O(N^2) | Recovers any $n$-order linear recurrence relation from the first"
    },
    "GoldenSectionSearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_GoldenSectionSearch"
        ],
        "body": [
            "\tdouble func(double x) { return 4+x+.3*x*x; }\n",
            "\tdouble xmin = gss(-1000,1000,func);\n",
            "\n",
            "/// It is important for r to be precise, otherwise we don't necessarily maintain the inequality a < x1 < x2 < b.\n",
            "double gss(double a, double b, double (*f)(double)) {\n",
            "\tdouble r = (sqrt(5)-1)/2, eps = 1e-7;\n",
            "\tdouble x1 = b - r*(b-a), x2 = a + r*(b-a);\n",
            "\tdouble f1 = f(x1), f2 = f(x2);\n",
            "\twhile (b-a > eps)\n",
            "\t\tif (f1 < f2) { //change to > to find maximum\n",
            "\t\t\tb = x2; x2 = x1; f2 = f1;\n",
            "\t\t\tx1 = b - r*(b-a); f1 = f(x1);\n",
            "\t\t} else {\n",
            "\t\t\ta = x1; x1 = x2; f1 = f2;\n",
            "\t\t\tx2 = a + r*(b-a); f2 = f(x2);\n",
            "\t\t}\n",
            "\treturn a;\n",
            "}\n"
        ],
        "description": "O(\\log((b-a) / \\epsilon)) | Finds the argument minimizing the function $f$ in the interval $[a,b]$ assuming $f$ is unimodal on the interval, i.e. has only one local minimum. The maximum error in the result is $eps$. Works equally well for maximization with a small change in the code. See TernarySearch.h in the Various chapter for a discrete version."
    },
    "SolveLinear2": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinear2"
        ],
        "body": [
            "\n",
            "\n",
            "rep(j,0,n) if (j != i) // instead of rep(j,i+1,n)\n",
            "// ... then at the end:\n",
            "x.assign(m, undefined);\n",
            "rep(i,0,rank) {\n",
            "\trep(j,rank,m) if (fabs(A[i][j]) > eps) goto fail;\n",
            "\tx[col[i]] = b[i] / A[i][i];\n",
            "fail:; }\n"
        ],
        "description": "To get all uniquely determined values of $x$ back from SolveLinear, make the following changes:"
    },
    "Polynomial": {
        "scope": "cpp",
        "prefix": [
            "apoc_Polynomial"
        ],
        "body": [
            "\n",
            "struct Poly {\n",
            "\tvector<double> a;\n",
            "\tdouble operator()(double x) const {\n",
            "\t\tdouble val = 0;\n",
            "\t\tfor (int i = sz(a); i--;) (val *= x) += a[i];\n",
            "\t\treturn val;\n",
            "\t}\n",
            "\tvoid diff() {\n",
            "\t\trep(i,1,sz(a)) a[i-1] = i*a[i];\n",
            "\t\ta.pop_back();\n",
            "\t}\n",
            "\tvoid divroot(double x0) {\n",
            "\t\tdouble b = a.back(), c; a.back() = 0;\n",
            "\t\tfor(int i=sz(a)-1; i--;) c = a[i], a[i] = a[i+1]*x0+b, b=c;\n",
            "\t\ta.pop_back();\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Description:"
    },
    "Integrate": {
        "scope": "cpp",
        "prefix": [
            "apoc_Integrate"
        ],
        "body": [
            "\n",
            "template<class F>\n",
            "double quad(double a, double b, F f, const int n = 1000) {\n",
            "\tdouble h = (b - a) / 2 / n, v = f(a) + f(b);\n",
            "\trep(i,1,n*2)\n",
            "\t\tv += f(a + i*h) * (i&1 ? 4 : 2);\n",
            "\treturn v * h / 3;\n",
            "}\n"
        ],
        "description": "Simple integration of a function over an interval using"
    },
    "HillClimbing": {
        "scope": "cpp",
        "prefix": [
            "apoc_HillClimbing"
        ],
        "body": [
            "\n",
            "typedef array<double, 2> P;\n",
            "\n",
            "template<class F> pair<double, P> hillClimb(P start, F f) {\n",
            "\tpair<double, P> cur(f(start), start);\n",
            "\tfor (double jmp = 1e9; jmp > 1e-20; jmp /= 2) {\n",
            "\t\trep(j,0,100) rep(dx,-1,2) rep(dy,-1,2) {\n",
            "\t\t\tP p = cur.second;\n",
            "\t\t\tp[0] += dx*jmp;\n",
            "\t\t\tp[1] += dy*jmp;\n",
            "\t\t\tcur = min(cur, make_pair(f(p), p));\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn cur;\n",
            "}\n"
        ],
        "description": "Poor man's optimization for unimodal functions."
    },
    "Simplex": {
        "scope": "cpp",
        "prefix": [
            "apoc_Simplex"
        ],
        "body": [
            "\n",
            "typedef double T; // long double, Rational, double + mod<P>...\n",
            "typedef vector<T> vd;\n",
            "typedef vector<vd> vvd;\n",
            "\n",
            "const T eps = 1e-8, inf = 1/.0;\n",
            "#define MP make_pair\n",
            "#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j\n",
            "\n",
            "struct LPSolver {\n",
            "\tint m, n;\n",
            "\tvi N, B;\n",
            "\tvvd D;\n",
            "\n",
            "\tLPSolver(const vvd& A, const vd& b, const vd& c) :\n",
            "\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {\n",
            "\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];\n",
            "\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}\n",
            "\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }\n",
            "\t\t\tN[n] = -1; D[m+1][n] = 1;\n",
            "\t\t}\n",
            "\n",
            "\tvoid pivot(int r, int s) {\n",
            "\t\tT *a = D[r].data(), inv = 1 / a[s];\n",
            "\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {\n",
            "\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;\n",
            "\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;\n",
            "\t\t\tb[s] = a[s] * inv2;\n",
            "\t\t}\n",
            "\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;\n",
            "\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;\n",
            "\t\tD[r][s] = inv;\n",
            "\t\tswap(B[r], N[s]);\n",
            "\t}\n",
            "\n",
            "\tbool simplex(int phase) {\n",
            "\t\tint x = m + phase - 1;\n",
            "\t\tfor (;;) {\n",
            "\t\t\tint s = -1;\n",
            "\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);\n",
            "\t\t\tif (D[x][s] >= -eps) return true;\n",
            "\t\t\tint r = -1;\n",
            "\t\t\trep(i,0,m) {\n",
            "\t\t\t\tif (D[i][s] <= eps) continue;\n",
            "\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])\n",
            "\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;\n",
            "\t\t\t}\n",
            "\t\t\tif (r == -1) return false;\n",
            "\t\t\tpivot(r, s);\n",
            "\t\t}\n",
            "\t}\n",
            "\n",
            "\tT solve(vd &x) {\n",
            "\t\tint r = 0;\n",
            "\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;\n",
            "\t\tif (D[r][n+1] < -eps) {\n",
            "\t\t\tpivot(r, n);\n",
            "\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;\n",
            "\t\t\trep(i,0,m) if (B[i] == -1) {\n",
            "\t\t\t\tint s = 0;\n",
            "\t\t\t\trep(j,1,n+1) ltj(D[i]);\n",
            "\t\t\t\tpivot(i, s);\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\tbool ok = simplex(1); x = vd(n);\n",
            "\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];\n",
            "\t\treturn ok ? D[m][n+1] : inf;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(NM * \\#pivots), where a pivot may be e.g. an edge relaxation. O(2^n) in the general case. | Returns -inf if there is no solution, inf if there are arbitrarily good solutions, or the maximum value of $c^T x$ otherwise. The input vector is set to an optimal $x$ (or in the unbounded case, an arbitrary solution fulfilling the constraints). Numerical stability is not guaranteed. For better performance, define variables such that $x = 0$ is viable. Usage: vvd A = {{1,-1}, {-1,1}, {-1,-2}}; vd b = {1,1,-4}, c = {-1,-1}, x; T val = LPSolver(A, b, c).solve(x);"
    },
    "PolyRoots": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyRoots"
        ],
        "body": [
            "\n",
            "\n",
            "vector<double> polyRoots(Poly p, double xmin, double xmax) {\n",
            "\tif (sz(p.a) == 2) { return {-p.a[0]/p.a[1]}; }\n",
            "\tvector<double> ret;\n",
            "\tPoly der = p;\n",
            "\tder.diff();\n",
            "\tauto dr = polyRoots(der, xmin, xmax);\n",
            "\tdr.push_back(xmin-1);\n",
            "\tdr.push_back(xmax+1);\n",
            "\tsort(all(dr));\n",
            "\trep(i,0,sz(dr)-1) {\n",
            "\t\tdouble l = dr[i], h = dr[i+1];\n",
            "\t\tbool sign = p(l) > 0;\n",
            "\t\tif (sign ^ (p(h) > 0)) {\n",
            "\t\t\trep(it,0,60) { // while (h - l > 1e-8)\n",
            "\t\t\t\tdouble m = (l + h) / 2, f = p(m);\n",
            "\t\t\t\tif ((f <= 0) ^ sign) l = m;\n",
            "\t\t\t\telse h = m;\n",
            "\t\t\t}\n",
            "\t\t\tret.push_back((l + h) / 2);\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n"
        ],
        "description": "O(n^2 \\log(1/\\epsilon)) / | Finds the real roots to a polynomial."
    },
    "FastFourierTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastFourierTransform"
        ],
        "body": [
            "   Accuracy bound from http://www.daemonology.net/papers/fft.pdf\n",
            "   Useful for convolution:\n",
            "   \\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.\n",
            "   For convolution of complex numbers or more than two vectors: FFT, multiply\n",
            "   pointwise, divide by n, reverse(start+1, end), FFT back.\n",
            "   Rounding is safe if $(\\sum a_i^2 + \\sum b_i^2)\\log_2{N} < 9\\cdot10^{14}$\n",
            "   (in practice $10^{16}$; higher for random inputs).\n",
            "   Otherwise, use NTT/FFTMod.\n",
            "\n",
            "typedef complex<double> C;\n",
            "typedef vector<double> vd;\n",
            "void fft(vector<C>& a) {\n",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);\n",
            "\tstatic vector<complex<long double>> R(2, 1);\n",
            "\tstatic vector<C> rt(2, 1);  // (^ 10% faster if double)\n",
            "\tfor (static int k = 2; k < n; k *= 2) {\n",
            "\t\tR.resize(n); rt.resize(n);\n",
            "\t\tauto x = polar(1.0L, acos(-1.0L) / k);\n",
            "\t\trep(i,k,2*k) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];\n",
            "\t}\n",
            "\tvi rev(n);\n",
            "\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;\n",
            "\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);\n",
            "\tfor (int k = 1; k < n; k *= 2)\n",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {\n",
            "\t\t\t// C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line\n",
            "\t\t\tauto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line\n",
            "\t\t\tC z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line\n",
            "\t\t\ta[i + j + k] = a[i + j] - z;\n",
            "\t\t\ta[i + j] += z;\n",
            "\t\t}\n",
            "}\n",
            "vd conv(const vd& a, const vd& b) {\n",
            "\tif (a.empty() || b.empty()) return {};\n",
            "\tvd res(sz(a) + sz(b) - 1);\n",
            "\tint L = 32 - __builtin_clz(sz(res)), n = 1 << L;\n",
            "\tvector<C> in(n), out(n);\n",
            "\tcopy(all(a), begin(in));\n",
            "\trep(i,0,sz(b)) in[i].imag(b[i]);\n",
            "\tfft(in);\n",
            "\tfor (C& x : in) x *= x;\n",
            "\trep(i,0,n) out[i] = in[-i & (n - 1)] - conj(in[i]);\n",
            "\tfft(out);\n",
            "\trep(i,0,sz(res)) res[i] = imag(out[i]) / (4 * n);\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(N \\log N) with $N = |A|+|B|$ ($\\tilde 1s$ for $N=2^{22}$) | fft(a) computes $\\hat f(k) = \\sum_x a[x] \\exp(2\\pi i \\cdot k x / N)$ for all $k$. N must be a power of 2."
    },
    "MatrixInverse-mod": {
        "scope": "cpp",
        "prefix": [
            "apoc_MatrixInverse-mod"
        ],
        "body": [
            "\n",
            "\n",
            "int matInv(vector<vector<ll>>& A) {\n",
            "\tint n = sz(A); vi col(n);\n",
            "\tvector<vector<ll>> tmp(n, vector<ll>(n));\n",
            "\trep(i,0,n) tmp[i][i] = 1, col[i] = i;\n",
            "\n",
            "\trep(i,0,n) {\n",
            "\t\tint r = i, c = i;\n",
            "\t\trep(j,i,n) rep(k,i,n) if (A[j][k]) {\n",
            "\t\t\tr = j; c = k; goto found;\n",
            "\t\t}\n",
            "\t\treturn i;\n",
            "found:\n",
            "\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);\n",
            "\t\trep(j,0,n) swap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);\n",
            "\t\tswap(col[i], col[c]);\n",
            "\t\tll v = modpow(A[i][i], mod - 2);\n",
            "\t\trep(j,i+1,n) {\n",
            "\t\t\tll f = A[j][i] * v % mod;\n",
            "\t\t\tA[j][i] = 0;\n",
            "\t\t\trep(k,i+1,n) A[j][k] = (A[j][k] - f*A[i][k]) % mod;\n",
            "\t\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - f*tmp[i][k]) % mod;\n",
            "\t\t}\n",
            "\t\trep(j,i+1,n) A[i][j] = A[i][j] * v % mod;\n",
            "\t\trep(j,0,n) tmp[i][j] = tmp[i][j] * v % mod;\n",
            "\t\tA[i][i] = 1;\n",
            "\t}\n",
            "\n",
            "\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {\n",
            "\t\tll v = A[j][i];\n",
            "\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - v*tmp[i][k]) % mod;\n",
            "\t}\n",
            "\n",
            "\trep(i,0,n) rep(j,0,n)\n",
            "\t\tA[col[i]][col[j]] = tmp[i][j] % mod + (tmp[i][j] < 0 ? mod : 0);\n",
            "\treturn n;\n",
            "}\n"
        ],
        "description": "O(n^3) | Invert matrix $A$ modulo a prime."
    },
    "IntDeterminant": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntDeterminant"
        ],
        "body": [
            "\n",
            "const ll mod = 12345;\n",
            "ll det(vector<vector<ll>>& a) {\n",
            "\tint n = sz(a); ll ans = 1;\n",
            "\trep(i,0,n) {\n",
            "\t\trep(j,i+1,n) {\n",
            "\t\t\twhile (a[j][i] != 0) { // gcd step\n",
            "\t\t\t\tll t = a[i][i] / a[j][i];\n",
            "\t\t\t\tif (t) rep(k,i,n)\n",
            "\t\t\t\t\ta[i][k] = (a[i][k] - a[j][k] * t) % mod;\n",
            "\t\t\t\tswap(a[i], a[j]);\n",
            "\t\t\t\tans *= -1;\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\tans = ans * a[i][i] % mod;\n",
            "\t\tif (!ans) return 0;\n",
            "\t}\n",
            "\treturn (ans + mod) % mod;\n",
            "}\n"
        ],
        "description": "$O(N^3)$ | Calculates determinant using modular arithmetics."
    },
    "integrateAdaptiveTyler": {
        "scope": "cpp",
        "prefix": [
            "apoc_integrateAdaptiveTyler"
        ],
        "body": [
            "\n",
            "#define approx(a, b) (b-a) / 6 * (f(a) + 4 * f((a+b) / 2) + f(b))\n",
            "\n",
            "template<class F>\n",
            "ld adapt (F &f, ld a, ld b, ld A, int iters) {\n",
            "    ld m = (a+b) / 2;\n",
            "    ld A1 = approx(a, m), A2 = approx(m, b);\n",
            "    if(!iters && (abs(A1 + A2 - A) < eps || b-a < eps))\n",
            "        return A;\n",
            "    ld left = adapt(f, a, m, A1, max(iters-1, 0));\n",
            "    ld right = adapt(f, m, b, A2, max(iters-1, 0));\n",
            "    return left + right;\n",
            "}\n",
            "\n",
            "template<class F>\n",
            "ld integrate(F f, ld a, ld b, int iters = 0) {\n",
            "    return adapt(f, a, b, approx(a, b), iters);\n",
            "}"
        ],
        "description": "Gets area under a curve"
    },
    "NewtonsMethod": {
        "scope": "cpp",
        "prefix": [
            "apoc_NewtonsMethod"
        ],
        "body": [
            "\n",
            "\n",
            "template<class F, class T>\n",
            "void solveNonlinear(F f, vector<T> &x){\n",
            "    int n = sz(x);\n",
            "    rep(iter, 0, 100) {\n",
            "        vector<vector<T>> J = makeJacobian(f, x);\n",
            "        matInv(J);\n",
            "        vector<T> dx = J * f(x);\n",
            "        x = x - dx;\n",
            "    }\n",
            "}\n"
        ],
        "description": "Solves a system on non-linear equations"
    },
    "Determinant": {
        "scope": "cpp",
        "prefix": [
            "apoc_Determinant"
        ],
        "body": [
            "\n",
            "double det(vector<vector<double>>& a) {\n",
            "\tint n = sz(a); double res = 1;\n",
            "\trep(i,0,n) {\n",
            "\t\tint b = i;\n",
            "\t\trep(j,i+1,n) if (fabs(a[j][i]) > fabs(a[b][i])) b = j;\n",
            "\t\tif (i != b) swap(a[i], a[b]), res *= -1;\n",
            "\t\tres *= a[i][i];\n",
            "\t\tif (res == 0) return 0;\n",
            "\t\trep(j,i+1,n) {\n",
            "\t\t\tdouble v = a[j][i] / a[i][i];\n",
            "\t\t\tif (v != 0) rep(k,i+1,n) a[j][k] -= v * a[i][k];\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "$O(N^3)$ | Calculates determinant of a matrix. Destroys the matrix."
    },
    "SolveLinearBinary": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinearBinary"
        ],
        "body": [
            "\n",
            "typedef bitset<1000> bs;\n",
            "\n",
            "int solveLinear(vector<bs>& A, vi& b, bs& x, int m) {\n",
            "\tint n = sz(A), rank = 0, br;\n",
            "\tassert(m <= sz(x));\n",
            "\tvi col(m); iota(all(col), 0);\n",
            "\trep(i,0,n) {\n",
            "\t\tfor (br=i; br<n; ++br) if (A[br].any()) break;\n",
            "\t\tif (br == n) {\n",
            "\t\t\trep(j,i,n) if(b[j]) return -1;\n",
            "\t\t\tbreak;\n",
            "\t\t}\n",
            "\t\tint bc = (int)A[br]._Find_next(i-1);\n",
            "\t\tswap(A[i], A[br]);\n",
            "\t\tswap(b[i], b[br]);\n",
            "\t\tswap(col[i], col[bc]);\n",
            "\t\trep(j,0,n) if (A[j][i] != A[j][bc]) {\n",
            "\t\t\tA[j].flip(i); A[j].flip(bc);\n",
            "\t\t}\n",
            "\t\trep(j,i+1,n) if (A[j][i]) {\n",
            "\t\t\tb[j] ^= b[i];\n",
            "\t\t\tA[j] ^= A[i];\n",
            "\t\t}\n",
            "\t\trank++;\n",
            "\t}\n",
            "\n",
            "\tx = bs();\n",
            "\tfor (int i = rank; i--;) {\n",
            "\t\tif (!b[i]) continue;\n",
            "\t\tx[col[i]] = 1;\n",
            "\t\trep(j,0,i) b[j] ^= A[j][i];\n",
            "\t}\n",
            "\treturn rank; // (multiple solutions if rank < m)\n",
            "}\n"
        ],
        "description": "O(n^2 m) | Solves $Ax = b$ over $\\mathbb F_2$. If there are multiple solutions, one is returned arbitrarily."
    },
    "PolyInterpolate": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyInterpolate"
        ],
        "body": [
            "\n",
            "typedef vector<double> vd;\n",
            "vd interpolate(vd x, vd y, int n) {\n",
            "\tvd res(n), temp(n);\n",
            "\trep(k,0,n-1) rep(i,k+1,n)\n",
            "\t\ty[i] = (y[i] - y[k]) / (x[i] - x[k]);\n",
            "\tdouble last = 0; temp[0] = 1;\n",
            "\trep(k,0,n) rep(i,0,n) {\n",
            "\t\tres[i] += y[k] * temp[i];\n",
            "\t\tswap(last, temp[i]);\n",
            "\t\ttemp[i] -= last * x[k];\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(n^2) / | Given $n$ points (x[i], y[i]), computes an n-1-degree polynomial $p$ that"
    },
    "Tridiagonal": {
        "scope": "cpp",
        "prefix": [
            "apoc_Tridiagonal"
        ],
        "body": [
            "\\[\n",
            "\\left(\\begin{array}{c}b_0\\\\b_1\\\\b_2\\\\b_3\\\\\\vdots\\\\b_{n-1}\\end{array}\\right) =\n",
            "\\left(\\begin{array}{cccccc}\n",
            "d_0 & p_0 & 0 & 0 & \\cdots & 0\\\\\n",
            "q_0 & d_1 & p_1 & 0 & \\cdots & 0\\\\\n",
            "0 & q_1 & d_2 & p_2 & \\cdots & 0\\\\\n",
            "\\vdots & \\vdots & \\ddots & \\ddots & \\ddots & \\vdots\\\\\n",
            "0 & 0 & \\cdots & q_{n-3} & d_{n-2} & p_{n-2}\\\\\n",
            "0 & 0 & \\cdots & 0 & q_{n-2} & d_{n-1}\\\\\n",
            "\\end{array}\\right)\n",
            "\\left(\\begin{array}{c}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\vdots\\\\x_{n-1}\\end{array}\\right).\n",
            "\\]\n",
            "\n",
            "This is useful for solving problems on the type\n",
            "\\[ a_i=b_ia_{i-1}+c_ia_{i+1}+d_i,\\,1\\leq i\\leq n, \\]\n",
            "where $a_0$, $a_{n+1}$, $b_i$, $c_i$ and $d_i$ are known. $a$ can then be obtained from\n",
            "\\begin{align*}\n",
            "\\{a_i\\}=\\textrm{tridiagonal}(&\\{1,-1,-1,...,-1,1\\}, \\{0,c_1,c_2,\\dots,c_n\\},\\\\\n",
            "&\\{b_1,b_2,\\dots,b_n,0\\}, \\{a_0,d_1,d_2,\\dots,d_n,a_{n+1}\\}).\n",
            "\\end{align*}\n",
            "Fails if the solution is not unique.\n",
            "\n",
            "If $|d_i| > |p_i| + |q_{i-1}|$ for all $i$, or $|d_i| > |p_{i-1}| + |q_i|$, or the matrix is positive definite,\n",
            "the algorithm is numerically stable and neither \\texttt{tr} nor the check for \\texttt{diag[i] == 0} is needed.\n",
            "\n",
            "typedef double T;\n",
            "vector<T> tridiagonal(vector<T> diag, const vector<T>& super,\n",
            "\t\tconst vector<T>& sub, vector<T> b) {\n",
            "\tint n = sz(b); vi tr(n);\n",
            "\trep(i,0,n-1) {\n",
            "\t\tif (abs(diag[i]) < 1e-9 * abs(super[i])) { // diag[i] == 0\n",
            "\t\t\tb[i+1] -= b[i] * diag[i+1] / super[i];\n",
            "\t\t\tif (i+2 < n) b[i+2] -= b[i] * sub[i+1] / super[i];\n",
            "\t\t\tdiag[i+1] = sub[i]; tr[++i] = 1;\n",
            "\t\t} else {\n",
            "\t\t\tdiag[i+1] -= super[i]*sub[i]/diag[i];\n",
            "\t\t\tb[i+1] -= b[i]*sub[i]/diag[i];\n",
            "\t\t}\n",
            "\t}\n",
            "\tfor (int i = n; i--;) {\n",
            "\t\tif (tr[i]) {\n",
            "\t\t\tswap(b[i], b[i-1]);\n",
            "\t\t\tdiag[i-1] = diag[i];\n",
            "\t\t\tb[i] /= super[i-1];\n",
            "\t\t} else {\n",
            "\t\t\tb[i] /= diag[i];\n",
            "\t\t\tif (i) b[i-1] -= b[i]*super[i-1];\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn b;\n",
            "}\n"
        ],
        "description": "O(N) | $x=\\textrm{tridiagonal}(d,p,q,b)$ solves the equation system"
    },
    "JacobianMatrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_JacobianMatrix"
        ],
        "body": [
            "\n",
            "template<class F, class T>\n",
            "vector<vector<T>> makeJacobian(F &f, vector<T> &x) {\n",
            "    int n = sz(x);\n",
            "    vector<vector<T>> J(n, vector<T>(n));\n",
            "    vector<T> fX0 = f(x);\n",
            "    rep(i, 0, n) { \n",
            "        x[i] += eps;\n",
            "        vector<T> fX1 = f(x);\n",
            "        rep(j, 0, n){\n",
            "            J[j][i] = (fX1[j] - fX0[j]) / eps;\n",
            "        }\n",
            "\tx[i] -= eps;\n",
            "    }\n",
            "    return J;\n",
            "}\n"
        ],
        "description": "Makes Jacobian Matrix using finite differences"
    },
    "SolveLinear": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinear"
        ],
        "body": [
            "\n",
            "typedef vector<double> vd;\n",
            "const double eps = 1e-12;\n",
            "\n",
            "int solveLinear(vector<vd>& A, vd& b, vd& x) {\n",
            "\tint n = sz(A), m = sz(x), rank = 0, br, bc;\n",
            "\tif (n) assert(sz(A[0]) == m);\n",
            "\tvi col(m); iota(all(col), 0);\n",
            "\n",
            "\trep(i,0,n) {\n",
            "\t\tdouble v, bv = 0;\n",
            "\t\trep(r,i,n) rep(c,i,m)\n",
            "\t\t\tif ((v = fabs(A[r][c])) > bv)\n",
            "\t\t\t\tbr = r, bc = c, bv = v;\n",
            "\t\tif (bv <= eps) {\n",
            "\t\t\trep(j,i,n) if (fabs(b[j]) > eps) return -1;\n",
            "\t\t\tbreak;\n",
            "\t\t}\n",
            "\t\tswap(A[i], A[br]);\n",
            "\t\tswap(b[i], b[br]);\n",
            "\t\tswap(col[i], col[bc]);\n",
            "\t\trep(j,0,n) swap(A[j][i], A[j][bc]);\n",
            "\t\tbv = 1/A[i][i];\n",
            "\t\trep(j,i+1,n) {\n",
            "\t\t\tdouble fac = A[j][i] * bv;\n",
            "\t\t\tb[j] -= fac * b[i];\n",
            "\t\t\trep(k,i+1,m) A[j][k] -= fac*A[i][k];\n",
            "\t\t}\n",
            "\t\trank++;\n",
            "\t}\n",
            "\n",
            "\tx.assign(m, 0);\n",
            "\tfor (int i = rank; i--;) {\n",
            "\t\tb[i] /= A[i][i];\n",
            "\t\tx[col[i]] = b[i];\n",
            "\t\trep(j,0,i) b[j] -= A[j][i] * b[i];\n",
            "\t}\n",
            "\treturn rank; // (multiple solutions if rank < m)\n",
            "}\n"
        ],
        "description": "O(n^2 m) | Solves $A * x = b$. If there are multiple solutions, an arbitrary one is returned."
    },
    "LinearRecurrence": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinearRecurrence"
        ],
        "body": [
            "\n",
            "const ll mod = 5; /** exclude-line */\n",
            "\n",
            "typedef vector<ll> Poly;\n",
            "ll linearRec(Poly S, Poly tr, ll k) {\n",
            "\tint n = sz(tr);\n",
            "\n",
            "\tauto combine = [&](Poly a, Poly b) {\n",
            "\t\tPoly res(n * 2 + 1);\n",
            "\t\trep(i,0,n+1) rep(j,0,n+1)\n",
            "\t\t\tres[i + j] = (res[i + j] + a[i] * b[j]) % mod;\n",
            "\t\tfor (int i = 2 * n; i > n; --i) rep(j,0,n)\n",
            "\t\t\tres[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;\n",
            "\t\tres.resize(n + 1);\n",
            "\t\treturn res;\n",
            "\t};\n",
            "\n",
            "\tPoly pol(n + 1), e(pol);\n",
            "\tpol[0] = e[1] = 1;\n",
            "\n",
            "\tfor (++k; k; k /= 2) {\n",
            "\t\tif (k % 2) pol = combine(pol, e);\n",
            "\t\te = combine(e, e);\n",
            "\t}\n",
            "\n",
            "\tll res = 0;\n",
            "\trep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(n^2 \\log k) | Generates the $k$'th term of an $n$-order"
    },
    "IntegrateAdaptive": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntegrateAdaptive"
        ],
        "body": [
            "\tdouble sphereVolume = quad(-1, 1, [](double x) {\n",
            "\treturn quad(-1, 1, [\\&](double y) {\n",
            "\treturn quad(-1, 1, [\\&](double z) {\n",
            "\treturn x*x + y*y + z*z < 1; });});});\n",
            "\n",
            "typedef double d;\n",
            "#define S(a,b) (f(a) + 4*f((a+b) / 2) + f(b)) * (b-a) / 6\n",
            "\n",
            "template <class F>\n",
            "d rec(F& f, d a, d b, d eps, d S) {\n",
            "\td c = (a + b) / 2;\n",
            "\td S1 = S(a, c), S2 = S(c, b), T = S1 + S2;\n",
            "\tif (abs(T - S) <= 15 * eps || b - a < 1e-10)\n",
            "\t\treturn T + (T - S) / 15;\n",
            "\treturn rec(f, a, c, eps / 2, S1) + rec(f, c, b, eps / 2, S2);\n",
            "}\n",
            "template<class F>\n",
            "d quad(d a, d b, F f, d eps = 1e-8) {\n",
            "\treturn rec(f, a, b, eps, S(a, b));\n",
            "}\n"
        ],
        "description": "Fast integration using an adaptive Simpson's rule."
    },
    "FastSubsetTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastSubsetTransform"
        ],
        "body": [
            "\n",
            "void FST(vi& a, bool inv) {\n",
            "\tfor (int n = sz(a), step = 1; step < n; step *= 2) {\n",
            "\t\tfor (int i = 0; i < n; i += 2 * step) rep(j,i,i+step) {\n",
            "\t\t\tint &u = a[j], &v = a[j + step]; tie(u, v) =\n",
            "\t\t\t\tinv ? pii(v - u, u) : pii(v, u + v); // AND\n",
            "\t\t\t\t// inv ? pii(v, u - v) : pii(u + v, u); // OR /// include-line\n",
            "\t\t\t\t// pii(u + v, u - v);                   // XOR /// include-line\n",
            "\t\t}\n",
            "\t}\n",
            "\t// if (inv) for (int& x : a) x /= sz(a); // XOR only /// include-line\n",
            "}\n",
            "vi conv(vi a, vi b) {\n",
            "\tFST(a, 0); FST(b, 0);\n",
            "\trep(i,0,sz(a)) a[i] *= b[i];\n",
            "\tFST(a, 1); return a;\n",
            "}\n"
        ],
        "description": "O(N \\log N) | Transform to a basis with fast convolutions of the form"
    },
    "RungeKutta4": {
        "scope": "cpp",
        "prefix": [
            "apoc_RungeKutta4"
        ],
        "body": [
            "\n",
            "template<class F, class T>\n",
            "T solveSystem(F f, T x, ld time, int iters) {\n",
            "    double h = time / iters;\n",
            "    for(int iter = 0; iter < iters; iter++) {\n",
            "        T k1 = f(x);\n",
            "        A k2 = f(x + 0.5 * h * k1);\n",
            "        A k3 = f(x + 0.5 * h * k2);\n",
            "        A k4 = f(x + h * k3);\n",
            "        x = x + h / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4);\n",
            "    }\n",
            "    return x;\n",
            "}\n"
        ],
        "description": "Numerically approximates the solution to a system of Differential Equations"
    },
    "NumberTheoreticTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_NumberTheoreticTransform"
        ],
        "body": [
            "   \\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.\n",
            "   For manual convolution: NTT the inputs, multiply\n",
            "   pointwise, divide by n, reverse(start+1, end), NTT back.\n",
            "\n",
            "\n",
            "const ll mod = (119 << 23) + 1, root = 62; // = 998244353\n",
            "// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21\n",
            "// and 483 << 21 (same root). The last two are > 10^9.\n",
            "typedef vector<ll> vl;\n",
            "void ntt(vl &a) {\n",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);\n",
            "\tstatic vl rt(2, 1);\n",
            "\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {\n",
            "\t\trt.resize(n);\n",
            "\t\tll z[] = {1, modpow(root, mod >> s)};\n",
            "\t\trep(i,k,2*k) rt[i] = rt[i / 2] * z[i & 1] % mod;\n",
            "\t}\n",
            "\tvi rev(n);\n",
            "\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;\n",
            "\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);\n",
            "\tfor (int k = 1; k < n; k *= 2)\n",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {\n",
            "\t\t\tll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];\n",
            "\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);\n",
            "\t\t\tai += (ai + z >= mod ? z - mod : z);\n",
            "\t\t}\n",
            "}\n",
            "vl conv(const vl &a, const vl &b) {\n",
            "\tif (a.empty() || b.empty()) return {};\n",
            "\tint s = sz(a) + sz(b) - 1, B = 32 - __builtin_clz(s), n = 1 << B;\n",
            "\tint inv = modpow(n, mod - 2);\n",
            "\tvl L(a), R(b), out(n);\n",
            "\tL.resize(n), R.resize(n);\n",
            "\tntt(L), ntt(R);\n",
            "\trep(i,0,n) out[-i & (n - 1)] = (ll)L[i] * R[i] % mod * inv % mod;\n",
            "\tntt(out);\n",
            "\treturn {out.begin(), out.begin() + s};\n",
            "}\n"
        ],
        "description": "O(N \\log N) | ntt(a) computes $\\hat f(k) = \\sum_x a[x] g^{xk}$ for all $k$, where $g=\\text{root}^{(mod-1)/N}$."
    },
    "MatrixInverse": {
        "scope": "cpp",
        "prefix": [
            "apoc_MatrixInverse"
        ],
        "body": [
            "\n",
            "int matInv(vector<vector<double>>& A) {\n",
            "\tint n = sz(A); vi col(n);\n",
            "\tvector<vector<double>> tmp(n, vector<double>(n));\n",
            "\trep(i,0,n) tmp[i][i] = 1, col[i] = i;\n",
            "\n",
            "\trep(i,0,n) {\n",
            "\t\tint r = i, c = i;\n",
            "\t\trep(j,i,n) rep(k,i,n)\n",
            "\t\t\tif (fabs(A[j][k]) > fabs(A[r][c]))\n",
            "\t\t\t\tr = j, c = k;\n",
            "\t\tif (fabs(A[r][c]) < 1e-12) return i;\n",
            "\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);\n",
            "\t\trep(j,0,n)\n",
            "\t\t\tswap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);\n",
            "\t\tswap(col[i], col[c]);\n",
            "\t\tdouble v = A[i][i];\n",
            "\t\trep(j,i+1,n) {\n",
            "\t\t\tdouble f = A[j][i] / v;\n",
            "\t\t\tA[j][i] = 0;\n",
            "\t\t\trep(k,i+1,n) A[j][k] -= f*A[i][k];\n",
            "\t\t\trep(k,0,n) tmp[j][k] -= f*tmp[i][k];\n",
            "\t\t}\n",
            "\t\trep(j,i+1,n) A[i][j] /= v;\n",
            "\t\trep(j,0,n) tmp[i][j] /= v;\n",
            "\t\tA[i][i] = 1;\n",
            "\t}\n",
            "\n",
            "\t/// forget A at this point, just eliminate tmp backward\n",
            "\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {\n",
            "\t\tdouble v = A[j][i];\n",
            "\t\trep(k,0,n) tmp[j][k] -= v*tmp[i][k];\n",
            "\t}\n",
            "\n",
            "\trep(i,0,n) rep(j,0,n) A[col[i]][col[j]] = tmp[i][j];\n",
            "\treturn n;\n",
            "}\n"
        ],
        "description": "O(n^3) | Invert matrix $A$. Returns rank; result is stored in $A$ unless singular (rank < n)."
    },
    "Unrolling": {
        "scope": "cpp",
        "prefix": [
            "apoc_Unrolling"
        ],
        "body": [
            "\n",
            "#define F {...; ++i;}\n",
            "int i = from;\n",
            "while (i&3 && i < to) F // for alignment, if needed\n",
            "while (i + 4 <= to) { F F F F }\n",
            "while (i < to) F\n"
        ],
        "description": "Description:"
    },
    "SmallPtr": {
        "scope": "cpp",
        "prefix": [
            "apoc_SmallPtr"
        ],
        "body": [
            "\n",
            "\n",
            "template<class T> struct ptr {\n",
            "\tunsigned ind;\n",
            "\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {\n",
            "\t\tassert(ind < sizeof buf);\n",
            "\t}\n",
            "\tT& operator*() const { return *(T*)(buf + ind); }\n",
            "\tT* operator->() const { return &**this; }\n",
            "\tT& operator[](int a) const { return (&**this)[a]; }\n",
            "\texplicit operator bool() const { return ind; }\n",
            "};\n"
        ],
        "description": "A 32-bit pointer that points into BumpAllocator memory."
    },
    "FastKnapsack": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastKnapsack"
        ],
        "body": [
            "\n",
            "int knapsack(vi w, int t) {\n",
            "\tint a = 0, b = 0, x;\n",
            "\twhile (b < sz(w) && a + w[b] <= t) a += w[b++];\n",
            "\tif (b == sz(w)) return a;\n",
            "\tint m = *max_element(all(w));\n",
            "\tvi u, v(2*m, -1);\n",
            "\tv[a+m-t] = b;\n",
            "\trep(i,b,sz(w)) {\n",
            "\t\tu = v;\n",
            "\t\trep(x,0,m) v[x+w[i]] = max(v[x+w[i]], u[x]);\n",
            "\t\tfor (x = 2*m; --x > m;) rep(j, max(0,u[x]), v[x])\n",
            "\t\t\tv[x-w[j]] = max(v[x-w[j]], j);\n",
            "\t}\n",
            "\tfor (a = t; v[a+m-t] < 0; a--) ;\n",
            "\treturn a;\n",
            "}\n"
        ],
        "description": "O(N \\max(w_i)) | Given N non-negative integer weights w and a non-negative target t,"
    },
    "KnuthDP": {
        "scope": "cpp",
        "prefix": [
            "apoc_KnuthDP"
        ],
        "body": [],
        "description": "O(N^2) / |  one can solve intervals in increasing order of length, and search $k = p[i][j]$ for $a[i][j]$ only between $p[i][j-1]$ and $p[i+1][j]$.  This is known as Knuth DP. Sufficient criteria for this are if $f(b,c) \\le f(a,d)$ and $f(a,c) + f(b,d) \\le f(a,d) + f(b,c)$ for all $a \\le b \\le c \\le d$."
    },
    "BumpAllocatorSTL": {
        "scope": "cpp",
        "prefix": [
            "apoc_BumpAllocatorSTL"
        ],
        "body": [
            "\n",
            "char buf[450 << 20] alignas(16);\n",
            "size_t buf_ind = sizeof buf;\n",
            "\n",
            "template<class T> struct small {\n",
            "\ttypedef T value_type;\n",
            "\tsmall() {}\n",
            "\ttemplate<class U> small(const U&) {}\n",
            "\tT* allocate(size_t n) {\n",
            "\t\tbuf_ind -= n * sizeof(T);\n",
            "\t\tbuf_ind &= 0 - alignof(T);\n",
            "\t\treturn (T*)(buf + buf_ind);\n",
            "\t}\n",
            "\tvoid deallocate(T*, size_t) {}\n",
            "};\n"
        ],
        "description": "BumpAllocator for STL containers."
    },
    "IntervalContainer": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntervalContainer"
        ],
        "body": [
            "\n",
            "set<pii>::iterator addInterval(set<pii>& is, int L, int R) {\n",
            "\tif (L == R) return is.end();\n",
            "\tauto it = is.lower_bound({L, R}), before = it;\n",
            "\twhile (it != is.end() && it->first <= R) {\n",
            "\t\tR = max(R, it->second);\n",
            "\t\tbefore = it = is.erase(it);\n",
            "\t}\n",
            "\tif (it != is.begin() && (--it)->second >= L) {\n",
            "\t\tL = min(L, it->first);\n",
            "\t\tR = max(R, it->second);\n",
            "\t\tis.erase(it);\n",
            "\t}\n",
            "\treturn is.insert(before, {L,R});\n",
            "}\n",
            "\n",
            "void removeInterval(set<pii>& is, int L, int R) {\n",
            "\tif (L == R) return;\n",
            "\tauto it = addInterval(is, L, R);\n",
            "\tauto r2 = it->second;\n",
            "\tif (it->first == L) is.erase(it);\n",
            "\telse (int&)it->second = L;\n",
            "\tif (R != r2) is.emplace(R, r2);\n",
            "}\n"
        ],
        "description": "O(\\log N) | Add and remove intervals from a set of disjoint intervals."
    },
    "FastInput": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastInput"
        ],
        "body": [
            "\n",
            "inline char gc() { // like getchar()\n",
            "\tstatic char buf[1 << 16];\n",
            "\tstatic size_t bc, be;\n",
            "\tif (bc >= be) {\n",
            "\t\tbuf[0] = 0, bc = 0;\n",
            "\t\tbe = fread(buf, 1, sizeof(buf), stdin);\n",
            "\t}\n",
            "\treturn buf[bc++]; // returns 0 on EOF\n",
            "}\n",
            "\n",
            "int readInt() {\n",
            "\tint a, c;\n",
            "\twhile ((a = gc()) < 40);\n",
            "\tif (a == '-') return -readInt();\n",
            "\twhile ((c = gc()) >= 48) a = a * 10 + c - 480;\n",
            "\treturn a - 48;\n",
            "}\n"
        ],
        "description": "About 5x as fast as cin/scanf. | Read an integer from stdin. Usage requires your program to pipe in"
    },
    "BumpAllocator": {
        "scope": "cpp",
        "prefix": [
            "apoc_BumpAllocator"
        ],
        "body": [
            "\n",
            "// Either globally or in a single class:\n",
            "static char buf[450 << 20];\n",
            "void* operator new(size_t s) {\n",
            "\tstatic size_t i = sizeof buf;\n",
            "\tassert(s < i);\n",
            "\treturn (void*)&buf[i -= s];\n",
            "}\n",
            "void operator delete(void*) {}\n"
        ],
        "description": "When you need to dynamically allocate many objects and don't care about freeing them."
    },
    "ConstantIntervals": {
        "scope": "cpp",
        "prefix": [
            "apoc_ConstantIntervals"
        ],
        "body": [
            "\n",
            "template<class F, class G, class T>\n",
            "void rec(int from, int to, F& f, G& g, int& i, T& p, T q) {\n",
            "\tif (p == q) return;\n",
            "\tif (from == to) {\n",
            "\t\tg(i, to, p);\n",
            "\t\ti = to; p = q;\n",
            "\t} else {\n",
            "\t\tint mid = (from + to) >> 1;\n",
            "\t\trec(from, mid, f, g, i, p, f(mid));\n",
            "\t\trec(mid+1, to, f, g, i, p, q);\n",
            "\t}\n",
            "}\n",
            "template<class F, class G>\n",
            "void constantIntervals(int from, int to, F f, G g) {\n",
            "\tif (to <= from) return;\n",
            "\tint i = from; auto p = f(i), q = f(to-1);\n",
            "\trec(from, to-1, f, g, i, p, q);\n",
            "\tg(i, to, q);\n",
            "}\n"
        ],
        "description": "O(k\\log\\frac{n}{k}) | Split a monotone function on [from, to) into a minimal set of half-open intervals on which it has the same value."
    },
    "SIMD": {
        "scope": "cpp",
        "prefix": [
            "apoc_SIMD"
        ],
        "body": [
            "\n",
            "\n",
            "typedef __m256i mi;\n",
            "#define L(x) _mm256_loadu_si256((mi*)&(x))\n",
            "\n",
            "// High-level/specific methods:\n",
            "// load(u)?_si256, store(u)?_si256, setzero_si256, _mm_malloc\n",
            "// blendv_(epi8|ps|pd) (z?y:x), movemask_epi8 (hibits of bytes)\n",
            "// i32gather_epi32(addr, x, 4): map addr[] over 32-b parts of x\n",
            "// sad_epu8: sum of absolute differences of u8, outputs 4xi64\n",
            "// maddubs_epi16: dot product of unsigned i7's, outputs 16xi15\n",
            "// madd_epi16: dot product of signed i16's, outputs 8xi32\n",
            "// extractf128_si256(, i) (256->128), cvtsi128_si32 (128->lo32)\n",
            "// permute2f128_si256(x,x,1) swaps 128-bit lanes\n",
            "// shuffle_epi32(x, 3*64+2*16+1*4+0) == x for each lane\n",
            "// shuffle_epi8(x, y) takes a vector instead of an imm\n",
            "\n",
            "// Methods that work with most data types (append e.g. _epi32):\n",
            "// set1, blend (i8?x:y), add, adds (sat.), mullo, sub, and/or,\n",
            "// andnot, abs, min, max, sign(1,x), cmp(gt|eq), unpack(lo|hi)\n",
            "\n",
            "int sumi32(mi m) { union {int v[8]; mi m;} u; u.m = m;\n",
            "\tint ret = 0; rep(i,0,8) ret += u.v[i]; return ret; }\n",
            "mi zero() { return _mm256_setzero_si256(); }\n",
            "mi one() { return _mm256_set1_epi32(-1); }\n",
            "bool all_zero(mi m) { return _mm256_testz_si256(m, m); }\n",
            "bool all_one(mi m) { return _mm256_testc_si256(m, one()); }\n",
            "\n",
            "ll example_filteredDotProduct(int n, short* a, short* b) {\n",
            "\tint i = 0; ll r = 0;\n",
            "\tmi zero = _mm256_setzero_si256(), acc = zero;\n",
            "\twhile (i + 16 <= n) {\n",
            "\t\tmi va = L(a[i]), vb = L(b[i]); i += 16;\n",
            "\t\tva = _mm256_and_si256(_mm256_cmpgt_epi16(vb, va), va);\n",
            "\t\tmi vp = _mm256_madd_epi16(va, vb);\n",
            "\t\tacc = _mm256_add_epi64(_mm256_unpacklo_epi32(vp, zero),\n",
            "\t\t\t_mm256_add_epi64(acc, _mm256_unpackhi_epi32(vp, zero)));\n",
            "\t}\n",
            "\tunion {ll v[4]; mi m;} u; u.m = acc; rep(i,0,4) r += u.v[i];\n",
            "\tfor (;i<n;++i) if (a[i] < b[i]) r += a[i]*b[i]; // <- equiv\n",
            "\treturn r;\n",
            "}\n"
        ],
        "description": "Cheat sheet of SSE/AVX intrinsics, for doing arithmetic on several numbers at once."
    },
    "FastMod": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastMod"
        ],
        "body": [
            "\n",
            "typedef unsigned long long ull;\n",
            "struct FastMod {\n",
            "\tull b, m;\n",
            "\tFastMod(ull b) : b(b), m(-1ULL / b) {}\n",
            "\tull reduce(ull a) { // a % b + (0 or b)\n",
            "\t\treturn a - (ull)((__uint128_t(m) * a) >> 64) * b;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Compute $a \\% b$ about 5 times faster than usual, where $b$ is constant but not known at compile time."
    },
    "IntervalCover": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntervalCover"
        ],
        "body": [
            "\n",
            "template<class T>\n",
            "vi cover(pair<T, T> G, vector<pair<T, T>> I) {\n",
            "\tvi S(sz(I)), R;\n",
            "\tiota(all(S), 0);\n",
            "\tsort(all(S), [&](int a, int b) { return I[a] < I[b]; });\n",
            "\tT cur = G.first;\n",
            "\tint at = 0;\n",
            "\twhile (cur < G.second) { // (A)\n",
            "\t\tpair<T, int> mx = make_pair(cur, -1);\n",
            "\t\twhile (at < sz(I) && I[S[at]].first <= cur) {\n",
            "\t\t\tmx = max(mx, make_pair(I[S[at]].second, S[at]));\n",
            "\t\t\tat++;\n",
            "\t\t}\n",
            "\t\tif (mx.second == -1) return {};\n",
            "\t\tcur = mx.first;\n",
            "\t\tR.push_back(mx.second);\n",
            "\t}\n",
            "\treturn R;\n",
            "}\n"
        ],
        "description": "O(N \\log N) | Compute indices of smallest set of intervals covering another interval."
    },
    "LIS": {
        "scope": "cpp",
        "prefix": [
            "apoc_LIS"
        ],
        "body": [
            "\n",
            "template<class I> vi lis(const vector<I>& S) {\n",
            "\tif (S.empty()) return {};\n",
            "\tvi prev(sz(S));\n",
            "\ttypedef pair<I, int> p;\n",
            "\tvector<p> res;\n",
            "\trep(i,0,sz(S)) {\n",
            "\t\t// change 0 -> i for longest non-decreasing subsequence\n",
            "\t\tauto it = lower_bound(all(res), p{S[i], 0});\n",
            "\t\tif (it == res.end()) res.emplace_back(), it = res.end()-1;\n",
            "\t\t*it = {S[i], i};\n",
            "\t\tprev[i] = it == res.begin() ? 0 : (it-1)->second;\n",
            "\t}\n",
            "\tint L = sz(res), cur = res.back().second;\n",
            "\tvi ans(L);\n",
            "\twhile (L--) ans[L] = cur, cur = prev[cur];\n",
            "\treturn ans;\n",
            "}\n"
        ],
        "description": "$O(N \\log N)$ | Compute indices for the longest increasing subsequence."
    },
    "DivideAndConquerDP": {
        "scope": "cpp",
        "prefix": [
            "apoc_DivideAndConquerDP"
        ],
        "body": [
            "\n",
            "struct DP { // Modify at will:\n",
            "\tint lo(int ind) { return 0; }\n",
            "\tint hi(int ind) { return ind; }\n",
            "\tll f(int ind, int k) { return dp[ind][k]; }\n",
            "\tvoid store(int ind, int k, ll v) { res[ind] = pii(k, v); }\n",
            "\n",
            "\tvoid rec(int L, int R, int LO, int HI) {\n",
            "\t\tif (L >= R) return;\n",
            "\t\tint mid = (L + R) >> 1;\n",
            "\t\tpair<ll, int> best(LLONG_MAX, LO);\n",
            "\t\trep(k, max(LO,lo(mid)), min(HI,hi(mid)))\n",
            "\t\t\tbest = min(best, make_pair(f(mid, k), k));\n",
            "\t\tstore(mid, best.second, best.first);\n",
            "\t\trec(L, mid, LO, best.second+1);\n",
            "\t\trec(mid+1, R, best.second, HI);\n",
            "\t}\n",
            "\tvoid solve(int L, int R) { rec(L, R, INT_MIN, INT_MAX); }\n",
            "};\n"
        ],
        "description": "O((N + (hi-lo)) \\log N) | Given $a[i] = \\min_{lo(i) \\le k < hi(i)}(f(i, k))$ where the (minimal) optimal $k$ increases with $i$, computes $a[i]$ for $i = L..R-1$."
    },
    "TernarySearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_TernarySearch"
        ],
        "body": [
            "\tint ind = ternSearch(0,n-1,[\\&](int i){return a[i];});\n",
            "\n",
            "template<class F>\n",
            "int ternSearch(int a, int b, F f) {\n",
            "\tassert(a <= b);\n",
            "\twhile (b - a >= 5) {\n",
            "\t\tint mid = (a + b) / 2;\n",
            "\t\tif (f(mid) < f(mid+1)) a = mid; // (A)\n",
            "\t\telse b = mid+1;\n",
            "\t}\n",
            "\trep(i,a+1,b+1) if (f(a) < f(i)) a = i; // (B)\n",
            "\treturn a;\n",
            "}\n"
        ],
        "description": "O(\\log(b-a)) | Description: Find the smallest i in $[a,b]$ that maximizes $f(i)$, assuming that $f(a) < \\dots < f(i) \\ge \\dots \\ge f(b)$. To reverse which of the sides allows non-strict inequalities, change the < marked with (A) to <=, and reverse the loop at (B). To minimize $f$, change it to >, also at (B). Usage:"
    },
    "FastEratosthenes": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastEratosthenes"
        ],
        "body": [
            " *\n",
            " *\n",
            "\n",
            "const int LIM = 1e6;\n",
            "bitset<LIM> isPrime;\n",
            "vi eratosthenes() {\n",
            "\tconst int S = (int)round(sqrt(LIM)), R = LIM / 2;\n",
            "\tvi pr = {2}, sieve(S+1); pr.reserve(int(LIM/log(LIM)*1.1));\n",
            "\tvector<pii> cp;\n",
            "\tfor (int i = 3; i <= S; i += 2) if (!sieve[i]) {\n",
            "\t\tcp.push_back({i, i * i / 2});\n",
            "\t\tfor (int j = i * i; j <= S; j += 2 * i) sieve[j] = 1;\n",
            "\t}\n",
            "\tfor (int L = 1; L <= R; L += S) {\n",
            "\t\tarray<bool, S> block{};\n",
            "\t\tfor (auto &[p, idx] : cp)\n",
            "\t\t\tfor (int i=idx; i < S+L; idx = (i+=p)) block[i-L] = 1;\n",
            "\t\trep(i,0,min(S, R - L))\n",
            "\t\t\tif (!block[i]) pr.push_back((L + i) * 2 + 1);\n",
            "\t}\n",
            "\tfor (int i : pr) isPrime[i] = 1;\n",
            "\treturn pr;\n",
            "}\n"
        ],
        "description": "LIM=1e9 $\\approx$ 1.5s | Prime sieve for generating all primes smaller than LIM."
    },
    "ModPow": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModPow"
        ],
        "body": [
            "\n",
            "const ll mod = 1000000007; // faster if const\n",
            "\n",
            "ll modpow(ll b, ll e) {\n",
            "\tll ans = 1;\n",
            "\tfor (; e; b = b * b % mod, e /= 2)\n",
            "\t\tif (e & 1) ans = ans * b % mod;\n",
            "\treturn ans;\n",
            "}\n"
        ],
        "description": "Description:"
    },
    "ModSqrt": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModSqrt"
        ],
        "body": [
            "\n",
            "\n",
            "ll sqrt(ll a, ll p) {\n",
            "\ta %= p; if (a < 0) a += p;\n",
            "\tif (a == 0) return 0;\n",
            "\tassert(modpow(a, (p-1)/2, p) == 1); // else no solution\n",
            "\tif (p % 4 == 3) return modpow(a, (p+1)/4, p);\n",
            "\t// a^(n+3)/8 or 2^(n+3)/8 * 2^(n-1)/4 works if p % 8 == 5\n",
            "\tll s = p - 1, n = 2;\n",
            "\tint r = 0, m;\n",
            "\twhile (s % 2 == 0)\n",
            "\t\t++r, s /= 2;\n",
            "\t/// find a non-square mod p\n",
            "\twhile (modpow(n, (p - 1) / 2, p) != p - 1) ++n;\n",
            "\tll x = modpow(a, (s + 1) / 2, p);\n",
            "\tll b = modpow(a, s, p), g = modpow(n, s, p);\n",
            "\tfor (;; r = m) {\n",
            "\t\tll t = b;\n",
            "\t\tfor (m = 0; m < r && t != 1; ++m)\n",
            "\t\t\tt = t * t % p;\n",
            "\t\tif (m == 0) return x;\n",
            "\t\tll gs = modpow(g, 1LL << (r - m - 1), p);\n",
            "\t\tg = gs * gs % p;\n",
            "\t\tx = x * gs % p;\n",
            "\t\tb = b * g % p;\n",
            "\t}\n",
            "}\n"
        ],
        "description": "O(\\log^2 p) worst case, O(\\log p) for most $p$ | Tonelli-Shanks algorithm for modular square roots. Finds $x$ s.t. $x^2 = a \\pmod p$ ($-x$ gives the other solution)."
    },
    "ModSum": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModSum"
        ],
        "body": [
            " *\n",
            "\n",
            "typedef unsigned long long ull;\n",
            "ull sumsq(ull to) { return to / 2 * ((to-1) | 1); }\n",
            "/// ^ written in a weird way to deal with overflows correctly\n",
            "\n",
            "ull divsum(ull to, ull c, ull k, ull m) {\n",
            "\tull res = k / m * sumsq(to) + c / m * to;\n",
            "\tk %= m; c %= m;\n",
            "\tif (!k) return res;\n",
            "\tull to2 = (to * k + c) / m;\n",
            "\treturn res + (to - 1) * to2 - divsum(to2, m-1 - c, m, k);\n",
            "}\n",
            "\n",
            "ll modsum(ull to, ll c, ll k, ll m) {\n",
            "\tc = ((c % m) + m) % m;\n",
            "\tk = ((k % m) + m) % m;\n",
            "\treturn to * c + k * sumsq(to) - m * divsum(to, c, k, m);\n",
            "}\n"
        ],
        "description": "$\\log(m)$, with a large constant. | Sums of mod'ed arithmetic progressions."
    },
    "ModLog": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModLog"
        ],
        "body": [
            " *\n",
            " *\n",
            " *\n",
            " *\n",
            "\n",
            "ll modLog(ll a, ll b, ll m) {\n",
            "\tll n = (ll) sqrt(m) + 1, e = 1, f = 1, j = 1;\n",
            "\tunordered_map<ll, ll> A;\n",
            "\twhile (j <= n && (e = f = e * a % m) != b % m)\n",
            "\t\tA[e * b % m] = j++;\n",
            "\tif (e == b % m) return j;\n",
            "\tif (__gcd(m, e) == __gcd(m, b)) \n",
            "\t\trep(i,2,n+2) if (A.count(e = e * f % m))\n",
            "\t\t\treturn n * i - A[e];\n",
            "\treturn -1;\n",
            "}\n"
        ],
        "description": "$O(\\sqrt m)$ | Returns the smallest $x > 0$ s.t. $a^x = b \\pmod m$, or"
    },
    "MillerRabin": {
        "scope": "cpp",
        "prefix": [
            "apoc_MillerRabin"
        ],
        "body": [
            "\n",
            "\n",
            "bool isPrime(ull n) {\n",
            "\tif (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;\n",
            "\tull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},\n",
            "\t    s = __builtin_ctzll(n-1), d = n >> s;\n",
            "\tfor (ull a : A) {   // ^ count trailing zeroes\n",
            "\t\tull p = modpow(a%n, d, n), i = s;\n",
            "\t\twhile (p != 1 && p != n - 1 && a % n && i--)\n",
            "\t\t\tp = modmul(p, p, n);\n",
            "\t\tif (p != n-1 && i != s) return 0;\n",
            "\t}\n",
            "\treturn 1;\n",
            "}\n"
        ],
        "description": "7 times the complexity of $a^b \\mod c$. | Deterministic Miller-Rabin primality test."
    },
    "Factor": {
        "scope": "cpp",
        "prefix": [
            "apoc_Factor"
        ],
        "body": [
            " *\n",
            " *\n",
            " *\n",
            " *\n",
            " *\n",
            "\n",
            "\n",
            "ull pollard(ull n) {\n",
            "\tauto f = [n](ull x) { return modmul(x, x, n) + 1; };\n",
            "\tull x = 0, y = 0, t = 30, prd = 2, i = 1, q;\n",
            "\twhile (t++ % 40 || __gcd(prd, n) == 1) {\n",
            "\t\tif (x == y) x = ++i, y = f(x);\n",
            "\t\tif ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;\n",
            "\t\tx = f(x), y = f(f(y));\n",
            "\t}\n",
            "\treturn __gcd(prd, n);\n",
            "}\n",
            "vector<ull> factor(ull n) {\n",
            "\tif (n == 1) return {};\n",
            "\tif (isPrime(n)) return {n};\n",
            "\tull x = pollard(n);\n",
            "\tauto l = factor(x), r = factor(n / x);\n",
            "\tl.insert(l.end(), all(r));\n",
            "\treturn l;\n",
            "}\n"
        ],
        "description": "$O(n^{1/4})$, less for numbers with small factors. | Pollard-rho randomized factorization algorithm. Returns prime"
    },
    "euclid": {
        "scope": "cpp",
        "prefix": [
            "apoc_euclid"
        ],
        "body": [
            "\n",
            "ll euclid(ll a, ll b, ll &x, ll &y) {\n",
            "\tif (!b) return x = 1, y = 0, a;\n",
            "\tll d = euclid(b, a % b, y, x);\n",
            "\treturn y -= a/b * x, d;\n",
            "}\n"
        ],
        "description": "Finds two integers $x$ and $y$, such that $ax+by=\\gcd(a,b)$. If"
    },
    "ModMulLL": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModMulLL"
        ],
        "body": [
            "\n",
            "typedef unsigned long long ull;\n",
            "ull modmul(ull a, ull b, ull M) {\n",
            "\tll ret = a * b - M * ull(1.L / M * a * b);\n",
            "\treturn ret + M * (ret < 0) - M * (ret >= (ll)M);\n",
            "}\n",
            "ull modpow(ull b, ull e, ull mod) {\n",
            "\tull ans = 1;\n",
            "\tfor (; e; b = modmul(b, b, mod), e /= 2)\n",
            "\t\tif (e & 1) ans = modmul(ans, b, mod);\n",
            "\treturn ans;\n",
            "}\n"
        ],
        "description": "O(1) for \\texttt{modmul}, O(\\log b) for \\texttt{modpow} | Calculate $a\\cdot b\\bmod c$ (or $a^b \\bmod c$) for $0 \\le a, b \\le c \\le 7.2\\cdot 10^{18}$."
    },
    "Eratosthenes": {
        "scope": "cpp",
        "prefix": [
            "apoc_Eratosthenes"
        ],
        "body": [
            "\n",
            "const int MAX_PR = 5'000'000;\n",
            "bitset<MAX_PR> isprime;\n",
            "vi eratosthenesSieve(int lim) {\n",
            "\tisprime.set(); isprime[0] = isprime[1] = 0;\n",
            "\tfor (int i = 4; i < lim; i += 2) isprime[i] = 0;\n",
            "\tfor (int i = 3; i*i < lim; i += 2) if (isprime[i])\n",
            "\t\tfor (int j = i*i; j < lim; j += i*2) isprime[j] = 0;\n",
            "\tvi pr;\n",
            "\trep(i,2,lim) if (isprime[i]) pr.push_back(i);\n",
            "\treturn pr;\n",
            "}\n"
        ],
        "description": "lim=100'000'000 $\\approx$ 0.8 s. Runs 30\\% faster if only odd indices are stored. | Prime sieve for generating all primes up to a certain limit. isprime$[i]$ is true iff $i$ is a prime."
    },
    "phiFunction": {
        "scope": "cpp",
        "prefix": [
            "apoc_phiFunction"
        ],
        "body": [
            " *\n",
            " *\n",
            " *\n",
            "\n",
            "const int LIM = 5000000;\n",
            "int phi[LIM];\n",
            "\n",
            "void calculatePhi() {\n",
            "\trep(i,0,LIM) phi[i] = i&1 ? i : i/2;\n",
            "\tfor (int i = 3; i < LIM; i += 2) if(phi[i] == i)\n",
            "\t\tfor (int j = i; j < LIM; j += i) phi[j] -= phi[j] / i;\n",
            "}\n"
        ],
        "description": "\\emph{Euler's $\\phi$} function is defined as $\\phi(n):=\\#$ of positive integers $\\leq n$ that are coprime with $n$."
    },
    "ContinuedFractions": {
        "scope": "cpp",
        "prefix": [
            "apoc_ContinuedFractions"
        ],
        "body": [
            " *\n",
            "\n",
            "typedef double d; // for N ~ 1e7; long double for N ~ 1e9\n",
            "pair<ll, ll> approximate(d x, ll N) {\n",
            "\tll LP = 0, LQ = 1, P = 1, Q = 0, inf = LLONG_MAX; d y = x;\n",
            "\tfor (;;) {\n",
            "\t\tll lim = min(P ? (N-LP) / P : inf, Q ? (N-LQ) / Q : inf),\n",
            "\t\t   a = (ll)floor(y), b = min(a, lim),\n",
            "\t\t   NP = b*P + LP, NQ = b*Q + LQ;\n",
            "\t\tif (a > b) {\n",
            "\t\t\t// If b > a/2, we have a semi-convergent that gives us a\n",
            "\t\t\t// better approximation; if b = a/2, we *may* have one.\n",
            "\t\t\t// Return {P, Q} here for a more canonical approximation.\n",
            "\t\t\treturn (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q)) ?\n",
            "\t\t\t\tmake_pair(NP, NQ) : make_pair(P, Q);\n",
            "\t\t}\n",
            "\t\tif (abs(y = 1/(y - (d)a)) > 3*N) {\n",
            "\t\t\treturn {NP, NQ};\n",
            "\t\t}\n",
            "\t\tLP = P; P = NP;\n",
            "\t\tLQ = Q; Q = NQ;\n",
            "\t}\n",
            "}\n"
        ],
        "description": "O(\\log N) | Given $N$ and a real number $x \\ge 0$, finds the closest rational approximation $p/q$ with $p, q \\le N$."
    },
    "GetFactors": {
        "scope": "cpp",
        "prefix": [
            "apoc_GetFactors"
        ],
        "body": [
            "\n",
            "void getFactors(auto &pF, auto &primes, auto &factors, int i = 0, int n = 1) {\n",
            "    if(i == sz(pF)) {\n",
            "        factors.push_back(n);\n",
            "        return;\n",
            "    }\n",
            "\n",
            "    for(int j = 0, pow = 1; i <= pF[j]; j++, pow *= primes[j])\n",
            "        getFactors(pF, primes, factors, i+1, n * pow);\n",
            "}\n"
        ],
        "description": "$O(\\sqrt[3]{N})$ | Gets all factors of a number $N$ given the prime factorization of the number."
    },
    "CRT": {
        "scope": "cpp",
        "prefix": [
            "apoc_CRT"
        ],
        "body": [
            " *\n",
            "\n",
            "\n",
            "ll crt(ll a, ll m, ll b, ll n) {\n",
            "\tif (n > m) swap(a, b), swap(m, n);\n",
            "\tll x, y, g = euclid(m, n, x, y);\n",
            "\tassert((a - b) % g == 0); // else no solution\n",
            "\tx = (b - a) % n * x % n / g * m + a;\n",
            "\treturn x < 0 ? x + m*n/g : x;\n",
            "}\n"
        ],
        "description": "$\\log(n)$ | Chinese Remainder Theorem."
    },
    "FracBinarySearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_FracBinarySearch"
        ],
        "body": [
            "\n",
            "struct Frac { ll p, q; };\n",
            "\n",
            "template<class F>\n",
            "Frac fracBS(F f, ll N) {\n",
            "\tbool dir = 1, A = 1, B = 1;\n",
            "\tFrac lo{0, 1}, hi{1, 1}; // Set hi to 1/0 to search (0, N]\n",
            "\tif (f(lo)) return lo;\n",
            "\tassert(f(hi));\n",
            "\twhile (A || B) {\n",
            "\t\tll adv = 0, step = 1; // move hi if dir, else lo\n",
            "\t\tfor (int si = 0; step; (step *= 2) >>= si) {\n",
            "\t\t\tadv += step;\n",
            "\t\t\tFrac mid{lo.p * adv + hi.p, lo.q * adv + hi.q};\n",
            "\t\t\tif (abs(mid.p) > N || mid.q > N || dir == !f(mid)) {\n",
            "\t\t\t\tadv -= step; si = 2;\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\thi.p += lo.p * adv;\n",
            "\t\thi.q += lo.q * adv;\n",
            "\t\tdir = !dir;\n",
            "\t\tswap(lo, hi);\n",
            "\t\tA = B; B = !!adv;\n",
            "\t}\n",
            "\treturn dir ? hi : lo;\n",
            "}\n"
        ],
        "description": "O(\\log(N)) | Given $f$ and $N$, finds the smallest fraction $p/q \\in [0, 1]$"
    },
    "ModularArithmetic": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModularArithmetic"
        ],
        "body": [
            "\n",
            "\n",
            "const ll mod = 17; // change to something else\n",
            "struct Mod {\n",
            "\tll x;\n",
            "\tMod(ll xx) : x(xx) {}\n",
            "\tMod operator+(Mod b) { return Mod((x + b.x) % mod); }\n",
            "\tMod operator-(Mod b) { return Mod((x - b.x + mod) % mod); }\n",
            "\tMod operator*(Mod b) { return Mod((x * b.x) % mod); }\n",
            "\tMod operator/(Mod b) { return *this * invert(b); }\n",
            "\tMod invert(Mod a) {\n",
            "\t\tll x, y, g = euclid(a.x, mod, x, y);\n",
            "\t\tassert(g == 1); return Mod((x + mod) % mod);\n",
            "\t}\n",
            "\tMod operator^(ll e) {\n",
            "\t\tif (!e) return Mod(1);\n",
            "\t\tMod r = *this ^ (e / 2); r = r * r;\n",
            "\t\treturn e&1 ? *this * r : r;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Operators for modular arithmetic. You need to set {\\tt mod} to"
    },
    "ModInverse": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModInverse"
        ],
        "body": [
            "\n",
            "// const ll mod = 1000000007, LIM = 200000; ///include-line\n",
            "ll* inv = new ll[LIM] - 1; inv[1] = 1;\n",
            "rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;\n"
        ],
        "description": "Pre-computation of modular inverses. Assumes LIM $\\le$ mod and that mod is a prime."
    },
    "LinearSieve": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinearSieve"
        ],
        "body": [
            "\n",
            "const int LIM = 1000000;\n",
            "vi lp(LIM+1), primes;\n",
            "\n",
            "rep(i, 2, LIM + 1) {\n",
            "\tif (lp[i] == 0) primes.push_back(lp[i] = i);\n",
            "\tfor (int j = 0; j < sz(primes) && i * primes[j] <= LIM && primes[j] <= lp[i]; ++j) \n",
            "\t\tlp[i * primes[j]] = primes[j];\n",
            "}"
        ],
        "description": "$O(N)$ | Finds smallest prime factor of each integer"
    },
    "MinCostMaxFlowDijkstra": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCostMaxFlowDijkstra"
        ],
        "body": [
            "\n",
            "bool findPath(int s, int t) {\n",
            "\tfill(all(dist), inf);\n",
            "\tfill(all(seen), 0);\n",
            "\tdist[s] = 0;\n",
            "\t__gnu_pbds::priority_queue<pair<ll, int>> pq;\n",
            "\tvector<decltype(pq)::point_iterator> its(n);\n",
            "\tpq.push({0, s});\n",
            "\twhile(!pq.empty()) {\n",
            "\t\tauto [d, cur] = pq.top(); pq.pop(); d *= -1;\n",
            "\t\tseen[cur] = 1;\n",
            "\t\tif(dist[cur] < d) continue;\n",
            "\t\tfor(int idx: adj[cur]) {\n",
            "\t\t\tauto [nxt, cap, f, wt] = edges[idx];\n",
            "\t\t\tll nxtD = d + wt + pi[cur] - pi[nxt];\n",
            "\t\t\tif(f >= cap || nxtD >= dist[nxt] || seen[nxt]) continue;\n",
            "\t\t\tdist[nxt] = nxtD;\n",
            "\t\t\tpar[nxt] = {cur, idx};\n",
            "\t\t\tif(its[nxt] == pq.end()) its[nxt] = pq.push({-nxtD, nxt});\n",
            "\t\t\telse pq.modify(its[nxt], {-nxtD, nxt});\n",
            "\t\t}\n",
            "\t}\n",
            "\trep(i, 0, n) pi[i] = min(pi[i] + dist[i], inf);\n",
            "\treturn seen[t];\n",
            "}"
        ],
        "description": "If SPFA TLEs, swap the find\\_path function in MCMF"
    },
    "FloydWarshall": {
        "scope": "cpp",
        "prefix": [
            "apoc_FloydWarshall"
        ],
        "body": [
            "\n",
            "const ll inf = 1LL << 62;\n",
            "void floydWarshall(vector<vector<ll>>& m) {\n",
            "\tint n = sz(m);\n",
            "\trep(i,0,n) m[i][i] = min(m[i][i], 0LL);\n",
            "\trep(k,0,n) rep(i,0,n) rep(j,0,n)\n",
            "\t\tif (m[i][k] != inf && m[k][j] != inf) {\n",
            "\t\t\tauto newDist = max(m[i][k] + m[k][j], -inf);\n",
            "\t\t\tm[i][j] = min(m[i][j], newDist);\n",
            "\t\t}\n",
            "\trep(k,0,n) if (m[k][k] < 0) rep(i,0,n) rep(j,0,n)\n",
            "\t\tif (m[i][k] != inf && m[k][j] != inf) m[i][j] = -inf;\n",
            "}\n"
        ],
        "description": "O(N^3) | Calculates all-pairs shortest path in a directed graph that might have negative edge weights."
    },
    "EulerWalk": {
        "scope": "cpp",
        "prefix": [
            "apoc_EulerWalk"
        ],
        "body": [
            "\n",
            "vi eulerWalk(vector<vector<pii>>& gr, int nedges, int src=0) {\n",
            "\tint n = sz(gr);\n",
            "\tvi D(n), its(n), eu(nedges), ret, s = {src};\n",
            "\tD[src]++; // to allow Euler paths, not just cycles\n",
            "\twhile (!s.empty()) {\n",
            "\t\tint x = s.back(), y, e, &it = its[x], end = sz(gr[x]);\n",
            "\t\tif (it == end){ ret.push_back(x); s.pop_back(); continue; }\n",
            "\t\ttie(y, e) = gr[x][it++];\n",
            "\t\tif (!eu[e]) {\n",
            "\t\t\tD[x]--, D[y]++;\n",
            "\t\t\teu[e] = 1; s.push_back(y);\n",
            "\t\t}}\n",
            "\tfor (int x : D) if (x < 0 || sz(ret) != nedges+1) return {};\n",
            "\treturn {ret.rbegin(), ret.rend()};\n",
            "}\n"
        ],
        "description": "O(V + E) | Eulerian undirected/directed path/cycle algorithm."
    },
    "CompressTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_CompressTree"
        ],
        "body": [
            "\n",
            "\n",
            "typedef vector<pair<int, int>> vpi;\n",
            "vpi compressTree(LCA& lca, const vi& subset) {\n",
            "\tstatic vi rev; rev.resize(sz(lca.time));\n",
            "\tvi li = subset, &T = lca.time;\n",
            "\tauto cmp = [&](int a, int b) { return T[a] < T[b]; };\n",
            "\tsort(all(li), cmp);\n",
            "\tint m = sz(li)-1;\n",
            "\trep(i,0,m) {\n",
            "\t\tint a = li[i], b = li[i+1];\n",
            "\t\tli.push_back(lca.lca(a, b));\n",
            "\t}\n",
            "\tsort(all(li), cmp);\n",
            "\tli.erase(unique(all(li)), li.end());\n",
            "\trep(i,0,sz(li)) rev[li[i]] = i;\n",
            "\tvpi ret = {pii(0, li[0])};\n",
            "\trep(i,0,sz(li)-1) {\n",
            "\t\tint a = li[i], b = li[i+1];\n",
            "\t\tret.emplace_back(rev[lca.lca(a, b)], b);\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n"
        ],
        "description": "$O(|S| \\log |S|)$ | Given a rooted tree and a subset S of nodes, compute the minimal"
    },
    "HLD": {
        "scope": "cpp",
        "prefix": [
            "apoc_HLD"
        ],
        "body": [
            "\n",
            "\n",
            "template <bool VALS_EDGES> struct HLD {\n",
            "\tint N, tim = 0;\n",
            "\tvector<vi> adj;\n",
            "\tvi par, siz, depth, rt, pos;\n",
            "\tNode *tree;\n",
            "\tHLD(vector<vi> adj_)\n",
            "\t\t: N(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1), depth(N),\n",
            "\t\t  rt(N),pos(N),tree(new Node(0, N)){ dfsSz(0); dfsHld(0); }\n",
            "\tvoid dfsSz(int v) {\n",
            "\t\tif (par[v] != -1) adj[v].erase(find(all(adj[v]), par[v]));\n",
            "\t\tfor (int& u : adj[v]) {\n",
            "\t\t\tpar[u] = v, depth[u] = depth[v] + 1;\n",
            "\t\t\tdfsSz(u);\n",
            "\t\t\tsiz[v] += siz[u];\n",
            "\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);\n",
            "\t\t}\n",
            "\t}\n",
            "\tvoid dfsHld(int v) {\n",
            "\t\tpos[v] = tim++;\n",
            "\t\tfor (int u : adj[v]) {\n",
            "\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);\n",
            "\t\t\tdfsHld(u);\n",
            "\t\t}\n",
            "\t}\n",
            "\ttemplate <class B> void process(int u, int v, B op) {\n",
            "\t\tfor (; rt[u] != rt[v]; v = par[rt[v]]) {\n",
            "\t\t\tif (depth[rt[u]] > depth[rt[v]]) swap(u, v);\n",
            "\t\t\top(pos[rt[v]], pos[v] + 1);\n",
            "\t\t}\n",
            "\t\tif (depth[u] > depth[v]) swap(u, v);\n",
            "\t\top(pos[u] + VALS_EDGES, pos[v] + 1);\n",
            "\t}\n",
            "\tvoid modifyPath(int u, int v, int val) {\n",
            "\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });\n",
            "\t}\n",
            "\tint queryPath(int u, int v) { // Modify depending on problem\n",
            "\t\tint res = -1e9;\n",
            "\t\tprocess(u, v, [&](int l, int r) {\n",
            "\t\t\t\tres = max(res, tree->query(l, r));\n",
            "\t\t});\n",
            "\t\treturn res;\n",
            "\t}\n",
            "\tint querySubtree(int v) { // modifySubtree is similar\n",
            "\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O((\\log N)^2) | Decomposes a tree into vertex disjoint heavy paths and light"
    },
    "DominatorTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_DominatorTree"
        ],
        "body": [
            "\n",
            "struct DominatorTree {\n",
            "\tvector<vi> adj, ans; // input edges, edges of dominator tree (directed tree downwards from root)\n",
            "\tvector<vi> radj, child, sdomChild;\n",
            "\tvi label, rlabel, sdom, dom;\n",
            "\tvi par, bes;\n",
            "\tint co = 0;\n",
            "\tDominatorTree(int n) {\n",
            "\t\tn += n;\n",
            "\t\tadj = ans = radj = child = sdomChild =\n",
            "\t\t\tvector<vector<int>>(n);\n",
            "\t\tlabel = rlabel = sdom = dom = par = bes = vector<int>(n);\n",
            "\t}\n",
            "\tvoid add_edge(int a, int b) { adj[a].pb(b); }\n",
            "\tint get(int x) {\n",
            "\t\tif (par[x] != x) {\n",
            "\t\t\tint t = get(par[x]);\n",
            "\t\t\tpar[x] = par[par[x]];\n",
            "\t\t\tif (sdom[t] < sdom[bes[x]]) bes[x] = t;\n",
            "\t\t}\n",
            "\t\treturn bes[x];\n",
            "\t}\n",
            "\tvoid dfs(int x) { // create DFS tree\n",
            "\t\tlabel[x] = ++co;\n",
            "\t\trlabel[co] = x;\n",
            "\t\tsdom[co] = par[co] = bes[co] = co;\n",
            "\t\tfor (auto y : adj[x]) {\n",
            "\t\t\tif (!label[y]) {\n",
            "\t\t\t\tdfs(y);\n",
            "\t\t\t\tchild[label[x]].pb(label[y]);\n",
            "\t\t\t}\n",
            "\t\t\tradj[label[y]].pb(label[x]);\n",
            "\t\t}\n",
            "\t}\n",
            "\tvoid init(int root) {\n",
            "\t\tdfs(root);\n",
            "\t\tfor (int i = co; i >= 1; --i) {\n",
            "\t\t\tfor (auto j : radj[i])\n",
            "\t\t\t\tsdom[i] = min(sdom[i], sdom[get(j)]);\n",
            "\t\t\tif (i > 1) sdomChild[sdom[i]].pb(i);\n",
            "\t\t\tfor (auto j : sdomChild[i]) {\n",
            "\t\t\t\tint k = get(j);\n",
            "\t\t\t\tif (sdom[j] == sdom[k]) dom[j] = sdom[j];\n",
            "\t\t\t\telse dom[j] = k;\n",
            "\t\t\t}\n",
            "\t\t\tfor (auto j : child[i]) par[j] = i;\n",
            "\t\t}\n",
            "\t\tfor (int i = 2; i < co + 1; ++i) {\n",
            "\t\t\tif (dom[i] != sdom[i]) dom[i] = dom[dom[i]];\n",
            "\t\t\tans[rlabel[dom[i]]].pb(rlabel[i]);\n",
            "\t\t}\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(V+E) | Builds a dominator tree on a DAG. Output tree is in adj, directed down from the root."
    },
    "LinkCutTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinkCutTree"
        ],
        "body": [
            "\n",
            "struct Node { // Splay tree. Root's pp contains tree's parent.\n",
            "\tNode *p = 0, *pp = 0, *c[2];\n",
            "\tbool flip = 0;\n",
            "\tNode() { c[0] = c[1] = 0; fix(); }\n",
            "\tvoid fix() {\n",
            "\t\tif (c[0]) c[0]->p = this;\n",
            "\t\tif (c[1]) c[1]->p = this;\n",
            "\t\t// (+ update sum of subtree elements etc. if wanted)\n",
            "\t}\n",
            "\tvoid pushFlip() {\n",
            "\t\tif (!flip) return;\n",
            "\t\tflip = 0; swap(c[0], c[1]);\n",
            "\t\tif (c[0]) c[0]->flip ^= 1;\n",
            "\t\tif (c[1]) c[1]->flip ^= 1;\n",
            "\t}\n",
            "\tint up() { return p ? p->c[1] == this : -1; }\n",
            "\tvoid rot(int i, int b) {\n",
            "\t\tint h = i ^ b;\n",
            "\t\tNode *x = c[i], *y = b == 2 ? x : x->c[h], *z = b ? y : x;\n",
            "\t\tif ((y->p = p)) p->c[up()] = y;\n",
            "\t\tc[i] = z->c[i ^ 1];\n",
            "\t\tif (b < 2) {\n",
            "\t\t\tx->c[h] = y->c[h ^ 1];\n",
            "\t\t\tz->c[h ^ 1] = b ? x : this;\n",
            "\t\t}\n",
            "\t\ty->c[i ^ 1] = b ? this : x;\n",
            "\t\tfix(); x->fix(); y->fix();\n",
            "\t\tif (p) p->fix();\n",
            "\t\tswap(pp, y->pp);\n",
            "\t}\n",
            "\tvoid splay() { /// Splay this up to the root. Always finishes without flip set.\n",
            "\t\tfor (pushFlip(); p; ) {\n",
            "\t\t\tif (p->p) p->p->pushFlip();\n",
            "\t\t\tp->pushFlip(); pushFlip();\n",
            "\t\t\tint c1 = up(), c2 = p->up();\n",
            "\t\t\tif (c2 == -1) p->rot(c1, 2);\n",
            "\t\t\telse p->p->rot(c2, c1 != c2);\n",
            "\t\t}\n",
            "\t}\n",
            "\tNode* first() { /// Return the min element of the subtree rooted at this, splayed to the top.\n",
            "\t\tpushFlip();\n",
            "\t\treturn c[0] ? c[0]->first() : (splay(), this);\n",
            "\t}\n",
            "};\n",
            "\n",
            "struct LinkCut {\n",
            "\tvector<Node> node;\n",
            "\tLinkCut(int N) : node(N) {}\n",
            "\n",
            "\tvoid link(int u, int v) { // add an edge (u, v)\n",
            "\t\tassert(!connected(u, v));\n",
            "\t\tmakeRoot(&node[u]);\n",
            "\t\tnode[u].pp = &node[v];\n",
            "\t}\n",
            "\tvoid cut(int u, int v) { // remove an edge (u, v)\n",
            "\t\tNode *x = &node[u], *top = &node[v];\n",
            "\t\tmakeRoot(top); x->splay();\n",
            "\t\tassert(top == (x->pp ?: x->c[0]));\n",
            "\t\tif (x->pp) x->pp = 0;\n",
            "\t\telse {\n",
            "\t\t\tx->c[0] = top->p = 0;\n",
            "\t\t\tx->fix();\n",
            "\t\t}\n",
            "\t}\n",
            "\tbool connected(int u, int v) { // are u, v in the same tree?\n",
            "\t\tNode* nu = access(&node[u])->first();\n",
            "\t\treturn nu == access(&node[v])->first();\n",
            "\t}\n",
            "\tvoid makeRoot(Node* u) { /// Move u to root of represented tree.\n",
            "\t\taccess(u);\n",
            "\t\tu->splay();\n",
            "\t\tif(u->c[0]) {\n",
            "\t\t\tu->c[0]->p = 0;\n",
            "\t\t\tu->c[0]->flip ^= 1;\n",
            "\t\t\tu->c[0]->pp = u;\n",
            "\t\t\tu->c[0] = 0;\n",
            "\t\t\tu->fix();\n",
            "\t\t}\n",
            "\t}\n",
            "\tNode* access(Node* u) { /// Move u to root aux tree. Return the root of the root aux tree.\n",
            "\t\tu->splay();\n",
            "\t\twhile (Node* pp = u->pp) {\n",
            "\t\t\tpp->splay(); u->pp = 0;\n",
            "\t\t\tif (pp->c[1]) {\n",
            "\t\t\t\tpp->c[1]->p = 0; pp->c[1]->pp = pp; }\n",
            "\t\t\tpp->c[1] = u; pp->fix(); u = pp;\n",
            "\t\t}\n",
            "\t\treturn u;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "All operations take amortized O(\\log N). | Represents a forest of unrooted trees. You can add and remove"
    },
    "EdmondsKarp": {
        "scope": "cpp",
        "prefix": [
            "apoc_EdmondsKarp"
        ],
        "body": [
            "\n",
            "template<class T> T edmondsKarp(vector<unordered_map<int, T>>& graph, int source, int sink) {\n",
            "\tassert(source != sink);\n",
            "\tT flow = 0;\n",
            "\tvi par(sz(graph)), q = par;\n",
            "\n",
            "\tfor (;;) {\n",
            "\t\tfill(all(par), -1);\n",
            "\t\tpar[source] = 0;\n",
            "\t\tint ptr = 1;\n",
            "\t\tq[0] = source;\n",
            "\n",
            "\t\trep(i,0,ptr) {\n",
            "\t\t\tint x = q[i];\n",
            "\t\t\tfor (auto e : graph[x]) {\n",
            "\t\t\t\tif (par[e.first] == -1 && e.second > 0) {\n",
            "\t\t\t\t\tpar[e.first] = x;\n",
            "\t\t\t\t\tq[ptr++] = e.first;\n",
            "\t\t\t\t\tif (e.first == sink) goto out;\n",
            "\t\t\t\t}\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\treturn flow;\n",
            "out:\n",
            "\t\tT inc = numeric_limits<T>::max();\n",
            "\t\tfor (int y = sink; y != source; y = par[y])\n",
            "\t\t\tinc = min(inc, graph[par[y]][y]);\n",
            "\n",
            "\t\tflow += inc;\n",
            "\t\tfor (int y = sink; y != source; y = par[y]) {\n",
            "\t\t\tint p = par[y];\n",
            "\t\t\tif ((graph[p][y] -= inc) <= 0) graph[p].erase(y);\n",
            "\t\t\tgraph[y][p] += inc;\n",
            "\t\t}\n",
            "\t}\n",
            "}\n"
        ],
        "description": "Flow algorithm with guaranteed complexity $O(VE^2)$. To get edge flow values, compare"
    },
    "hopcroftKarp": {
        "scope": "cpp",
        "prefix": [
            "apoc_hopcroftKarp"
        ],
        "body": [
            "\n",
            "bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\n",
            "\tif (A[a] != L) return 0;\n",
            "\tA[a] = -1;\n",
            "\tfor (int b : g[a]) if (B[b] == L + 1) {\n",
            "\t\tB[b] = 0;\n",
            "\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n",
            "\t\t\treturn btoa[b] = a, 1;\n",
            "\t}\n",
            "\treturn 0;\n",
            "}\n",
            "\n",
            "int hopcroftKarp(vector<vi>& g, vi& btoa) {\n",
            "\tint res = 0;\n",
            "\tvi A(g.size()), B(btoa.size()), cur, next;\n",
            "\tfor (;;) {\n",
            "\t\tfill(all(A), 0);\n",
            "\t\tfill(all(B), 0);\n",
            "\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n",
            "\t\tcur.clear();\n",
            "\t\tfor (int a : btoa) if(a != -1) A[a] = -1;\n",
            "\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n",
            "\t\t/// Find all layers using bfs.\n",
            "\t\tfor (int lay = 1;; lay++) {\n",
            "\t\t\tbool islast = 0;\n",
            "\t\t\tnext.clear();\n",
            "\t\t\tfor (int a : cur) for (int b : g[a]) {\n",
            "\t\t\t\tif (btoa[b] == -1) {\n",
            "\t\t\t\t\tB[b] = lay;\n",
            "\t\t\t\t\tislast = 1;\n",
            "\t\t\t\t}\n",
            "\t\t\t\telse if (btoa[b] != a && !B[b]) {\n",
            "\t\t\t\t\tB[b] = lay;\n",
            "\t\t\t\t\tnext.push_back(btoa[b]);\n",
            "\t\t\t\t}\n",
            "\t\t\t}\n",
            "\t\t\tif (islast) break;\n",
            "\t\t\tif (next.empty()) return res;\n",
            "\t\t\tfor (int a : next) A[a] = lay;\n",
            "\t\t\tcur.swap(next);\n",
            "\t\t}\n",
            "\t\t/// Use DFS to scan for augmenting paths.\n",
            "\t\trep(a,0,sz(g))\n",
            "\t\t\tres += dfs(a, 0, g, btoa, A, B);\n",
            "\t}\n",
            "}\n"
        ],
        "description": "O(\\sqrt{V}E) | Fast bipartite matching algorithm. Graph $g$ should be a list"
    },
    "BellmanFord": {
        "scope": "cpp",
        "prefix": [
            "apoc_BellmanFord"
        ],
        "body": [
            "\n",
            "const ll inf = LLONG_MAX;\n",
            "struct Ed { int a, b, w, s() { return a < b ? a : -a; }};\n",
            "struct Node { ll dist = inf; int prev = -1; };\n",
            "\n",
            "void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {\n",
            "\tnodes[s].dist = 0;\n",
            "\tsort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });\n",
            "\n",
            "\tint lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices\n",
            "\trep(i,0,lim) for (Ed ed : eds) {\n",
            "\t\tNode cur = nodes[ed.a], &dest = nodes[ed.b];\n",
            "\t\tif (abs(cur.dist) == inf) continue;\n",
            "\t\tll d = cur.dist + ed.w;\n",
            "\t\tif (d < dest.dist) {\n",
            "\t\t\tdest.prev = ed.a;\n",
            "\t\t\tdest.dist = (i < lim-1 ? d : -inf);\n",
            "\t\t}\n",
            "\t}\n",
            "\trep(i,0,lim) for (Ed e : eds) {\n",
            "\t\tif (nodes[e.a].dist == -inf)\n",
            "\t\t\tnodes[e.b].dist = -inf;\n",
            "\t}\n",
            "}\n"
        ],
        "description": "O(VE) | Calculates shortest paths from $s$ in a graph that might have negative edge weights."
    },
    "GeneralMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_GeneralMatching"
        ],
        "body": [
            "\n",
            "\n",
            "vector<pii> generalMatching(int N, vector<pii>& ed) {\n",
            "\tvector<vector<ll>> mat(N, vector<ll>(N)), A;\n",
            "\tfor (pii pa : ed) {\n",
            "\t\tint a = pa.first, b = pa.second, r = rand() % mod;\n",
            "\t\tmat[a][b] = r, mat[b][a] = (mod - r) % mod;\n",
            "\t}\n",
            "\n",
            "\tint r = matInv(A = mat), M = 2*N - r, fi, fj;\n",
            "\tassert(r % 2 == 0);\n",
            "\n",
            "\tif (M != N) do {\n",
            "\t\tmat.resize(M, vector<ll>(M));\n",
            "\t\trep(i,0,N) {\n",
            "\t\t\tmat[i].resize(M);\n",
            "\t\t\trep(j,N,M) {\n",
            "\t\t\t\tint r = rand() % mod;\n",
            "\t\t\t\tmat[i][j] = r, mat[j][i] = (mod - r) % mod;\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t} while (matInv(A = mat) != M);\n",
            "\n",
            "\tvi has(M, 1); vector<pii> ret;\n",
            "\trep(it,0,M/2) {\n",
            "\t\trep(i,0,M) if (has[i])\n",
            "\t\t\trep(j,i+1,M) if (A[i][j] && mat[i][j]) {\n",
            "\t\t\t\tfi = i; fj = j; goto done;\n",
            "\t\t} assert(0); done:\n",
            "\t\tif (fj < N) ret.emplace_back(fi, fj);\n",
            "\t\thas[fi] = has[fj] = 0;\n",
            "\t\trep(sw,0,2) {\n",
            "\t\t\tll a = modpow(A[fi][fj], mod-2);\n",
            "\t\t\trep(i,0,M) if (has[i] && A[i][fj]) {\n",
            "\t\t\t\tll b = A[i][fj] * a % mod;\n",
            "\t\t\t\trep(j,0,M) A[i][j] = (A[i][j] - A[fi][j] * b) % mod;\n",
            "\t\t\t}\n",
            "\t\t\tswap(fi,fj);\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n"
        ],
        "description": "O(N^3) | Matching for general graphs."
    },
    "MinCostMaxFlow": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCostMaxFlow"
        ],
        "body": [
            "\n",
            "struct mcmf {\n",
            "    const ll inf = LLONG_MAX >> 2;\n",
            "    struct edge {\n",
            "        int v;\n",
            "        ll cap, flow, cost;\n",
            "    };\n",
            "    int n;\n",
            "    vector<edge> edges;\n",
            "    vvi adj; vii par; vi in_q;\n",
            "    vector<ll> dist, pi;\n",
            "    mcmf(int n): n(n), adj(n), dist(n), pi(n), par(n), in_q(n) {}\n",
            "    void add_edge(int u, int v, ll cap, ll cost) {\n",
            "        int idx = sz(edges);\n",
            "        edges.push_back({v, cap, 0, cost});\n",
            "        edges.push_back({u, cap, cap, -cost});\n",
            "        adj[u].push_back(idx);\n",
            "        adj[v].push_back(idx ^ 1);\n",
            "    }\n",
            "    bool find_path(int s, int t) {\n",
            "        fill(all(dist), inf);\n",
            "        fill(all(in_q), 0);\n",
            "        queue<int> q; q.push(s); \n",
            "        dist[s] = 0, in_q[s] = 1;\n",
            "        while(!q.empty()) {\n",
            "            int cur = q.front(); q.pop();\n",
            "            in_q[cur] = 0;\n",
            "            for(int idx: adj[cur]) {\n",
            "                auto [nxt, cap, fl, wt] = edges[idx];\n",
            "                ll nxtD = dist[cur] + wt;\n",
            "                if(fl >= cap || nxtD >= dist[nxt]) continue;\n",
            "                dist[nxt] = nxtD;\n",
            "                par[nxt] = {cur, idx};\n",
            "                if(in_q[nxt]) continue;\n",
            "                q.push(nxt); in_q[nxt] = 1;\n",
            "            }\n",
            "        }\n",
            " \n",
            "        return dist[t] < inf;\n",
            "    }\n",
            "    pair<ll, ll> calc(int s, int t) {\n",
            "        ll flow = 0, cost = 0;\n",
            "        while(find_path(s, t)) {\n",
            "            rep(i, 0, n) pi[i] = min(pi[i] + dist[i], inf);\n",
            "            ll f = inf;\n",
            "            for(int i, u, v = t; tie(u, i) = par[v], v != s; v = u)\n",
            "                f = min(f, edges[i].cap - edges[i].flow);\n",
            "            flow += f;\n",
            "            for(int i, u, v = t; tie(u, i) = par[v], v != s; v = u)\n",
            "                edges[i].flow += f, edges[i^1].flow -= f;\n",
            "        }\n",
            "        rep(i, 0, sz(edges)>>1)\n",
            "            cost += edges[i<<1].cost * edges[i<<1].flow;\n",
            " \n",
            "        return {flow, cost};\n",
            "    }\n",
            "};"
        ],
        "description": "Approximately $O(E^2)$, actually $O(FS)$ where S is the time | Min-cost max-flow. Negative cost cycles not supported."
    },
    "BinaryLifting": {
        "scope": "cpp",
        "prefix": [
            "apoc_BinaryLifting"
        ],
        "body": [
            "\n",
            "vector<vi> treeJump(vi& P){\n",
            "\tint on = 1, d = 1;\n",
            "\twhile(on < sz(P)) on *= 2, d++;\n",
            "\tvector<vi> jmp(d, P);\n",
            "\trep(i,1,d) rep(j,0,sz(P))\n",
            "\t\tjmp[i][j] = jmp[i-1][jmp[i-1][j]];\n",
            "\treturn jmp;\n",
            "}\n",
            "\n",
            "int jmp(vector<vi>& tbl, int nod, int steps){\n",
            "\trep(i,0,sz(tbl))\n",
            "\t\tif(steps&(1<<i)) nod = tbl[i][nod];\n",
            "\treturn nod;\n",
            "}\n",
            "\n",
            "int lca(vector<vi>& tbl, vi& depth, int a, int b) {\n",
            "\tif (depth[a] < depth[b]) swap(a, b);\n",
            "\ta = jmp(tbl, a, depth[a] - depth[b]);\n",
            "\tif (a == b) return a;\n",
            "\tfor (int i = sz(tbl); i--;) {\n",
            "\t\tint c = tbl[i][a], d = tbl[i][b];\n",
            "\t\tif (c != d) a = c, b = d;\n",
            "\t}\n",
            "\treturn tbl[0][a];\n",
            "}\n"
        ],
        "description": "construction $O(N \\log N)$, queries $O(\\log N)$ | Calculate power of two jumps in a tree,"
    },
    "CentroidDecomp": {
        "scope": "cpp",
        "prefix": [
            "apoc_CentroidDecomp"
        ],
        "body": [
            "\tall nodes with isIn[i] = 1 connected to root are part of root's centroid\n",
            "\n",
            "template<class G, class F>\n",
            "void centroidDecomp(G g, F f) {\n",
            "\tvi s(sz(g), 1), par(sz(g)), is(s);\n",
            "\tauto go = [&] (int u, int p, auto& go) -> void {\n",
            "\t\tif ((par[u] = p) != -1) g[u].erase(find(all(g[u]), p));\n",
            "\t\tfor (int v : g[u]) go(v, u, go), s[u] += s[v];\n",
            "\t};\n",
            "\tgo(0, -1, go); queue<int> q({0});\n",
            "\twhile (sz(q)) {\n",
            "\t\tint x = q.front(), b = x, ss, c; q.pop();\n",
            "\t\tdo for(int v : g[c = b]) if(s[v] > s[x]/2) b = v;\n",
            "\t\t\twhile(c != b);\n",
            "\t\tf(c, is);\n",
            "\t\tis[c] = 0, ss = s[c];\n",
            "\t\tfor (int v : g[c]) if (s[v] > 0) q.push(v);\n",
            "\t\tif (c != x) q.push(x);\n",
            "\t\tdo s[c] -= ss; while ((c = par[c]) != par[x]);\n",
            "\t}\n",
            "}\n"
        ],
        "description": "$O(n \\log n)$ | Computes centroid decomposition on connected tree, and runs callback function"
    },
    "BiconnectedComponents": {
        "scope": "cpp",
        "prefix": [
            "apoc_BiconnectedComponents"
        ],
        "body": [
            "\n",
            "vi num, st;\n",
            "vector<vector<pii>> ed;\n",
            "int Time;\n",
            "template<class F>\n",
            "int dfs(int at, int par, F& f) {\n",
            "\tint me = num[at] = ++Time, e, y, top = me;\n",
            "\tfor (auto pa : ed[at]) if (pa.second != par) {\n",
            "\t\ttie(y, e) = pa;\n",
            "\t\tif (num[y]) {\n",
            "\t\t\ttop = min(top, num[y]);\n",
            "\t\t\tif (num[y] < me)\n",
            "\t\t\t\tst.push_back(e);\n",
            "\t\t} else {\n",
            "\t\t\tint si = sz(st);\n",
            "\t\t\tint up = dfs(y, e, f);\n",
            "\t\t\ttop = min(top, up);\n",
            "\t\t\tif (up == me) {\n",
            "\t\t\t\tst.push_back(e);\n",
            "\t\t\t\tf(vi(st.begin() + si, st.end()));\n",
            "\t\t\t\tst.resize(si);\n",
            "\t\t\t}\n",
            "\t\t\telse if (up < me) st.push_back(e);\n",
            "\t\t\telse { /* e is a bridge */ }\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn top;\n",
            "}\n",
            "\n",
            "template<class F>\n",
            "void bicomps(F f) {\n",
            "\tnum.assign(sz(ed), 0);\n",
            "\trep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);\n",
            "}\n"
        ],
        "description": "O(E + V) | Finds all biconnected components in an undirected graph, and"
    },
    "LCA": {
        "scope": "cpp",
        "prefix": [
            "apoc_LCA"
        ],
        "body": [
            "\n",
            "\n",
            "struct LCA {\n",
            "\tint T = 0;\n",
            "\tvi time, path, ret;\n",
            "\tRMQ<int> rmq;\n",
            "\n",
            "\tLCA(vector<vi>& C) : time(sz(C)), rmq((dfs(C,0,-1), ret)) {}\n",
            "\tvoid dfs(vector<vi>& C, int v, int par) {\n",
            "\t\ttime[v] = T++;\n",
            "\t\tfor (int y : C[v]) if (y != par) {\n",
            "\t\t\tpath.push_back(v), ret.push_back(time[v]);\n",
            "\t\t\tdfs(C, y, v);\n",
            "\t\t}\n",
            "\t}\n",
            "\n",
            "\tint lca(int a, int b) {\n",
            "\t\tif (a == b) return a;\n",
            "\t\ttie(a, b) = minmax(time[a], time[b]);\n",
            "\t\treturn path[rmq.query(a, b)];\n",
            "\t}\n",
            "\t//dist(a,b){return depth[a] + depth[b] - 2*depth[lca(a,b)];}\n",
            "};\n"
        ],
        "description": "$O(N \\log N + Q)$ | Data structure for computing lowest common ancestors in a tree"
    },
    "2sat": {
        "scope": "cpp",
        "prefix": [
            "apoc_2sat"
        ],
        "body": [
            "\n",
            "struct TwoSat {\n",
            "\tint N;\n",
            "\tvector<vi> gr;\n",
            "\tvi values; // 0 = false, 1 = true\n",
            "\n",
            "\tTwoSat(int n = 0) : N(n), gr(2*n) {}\n",
            "\n",
            "\tint addVar() { // (optional)\n",
            "\t\tgr.emplace_back();\n",
            "\t\tgr.emplace_back();\n",
            "\t\treturn N++;\n",
            "\t}\n",
            "\n",
            "\tvoid either(int f, int j) {\n",
            "\t\tf = max(2*f, -1-2*f);\n",
            "\t\tj = max(2*j, -1-2*j);\n",
            "\t\tgr[f].push_back(j^1);\n",
            "\t\tgr[j].push_back(f^1);\n",
            "\t}\n",
            "\tvoid setValue(int x) { either(x, x); }\n",
            "\n",
            "\tvoid atMostOne(const vi& li) { // (optional)\n",
            "\t\tif (sz(li) <= 1) return;\n",
            "\t\tint cur = ~li[0];\n",
            "\t\trep(i,2,sz(li)) {\n",
            "\t\t\tint next = addVar();\n",
            "\t\t\teither(cur, ~li[i]);\n",
            "\t\t\teither(cur, next);\n",
            "\t\t\teither(~li[i], next);\n",
            "\t\t\tcur = ~next;\n",
            "\t\t}\n",
            "\t\teither(cur, ~li[1]);\n",
            "\t}\n",
            "\n",
            "\tvi val, comp, z; int time = 0;\n",
            "\tint dfs(int i) {\n",
            "\t\tint low = val[i] = ++time, x; z.push_back(i);\n",
            "\t\tfor(int e : gr[i]) if (!comp[e])\n",
            "\t\t\tlow = min(low, val[e] ?: dfs(e));\n",
            "\t\tif (low == val[i]) do {\n",
            "\t\t\tx = z.back(); z.pop_back();\n",
            "\t\t\tcomp[x] = low;\n",
            "\t\t\tif (values[x>>1] == -1)\n",
            "\t\t\t\tvalues[x>>1] = x&1;\n",
            "\t\t} while (x != i);\n",
            "\t\treturn val[i] = low;\n",
            "\t}\n",
            "\n",
            "\tbool solve() {\n",
            "\t\tvalues.assign(N, -1);\n",
            "\t\tval.assign(2*N, 0); comp = val;\n",
            "\t\trep(i,0,2*N) if (!comp[i]) dfs(i);\n",
            "\t\trep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;\n",
            "\t\treturn 1;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "O(N+E), where N is the number of boolean variables, and E is the number of clauses. | Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem, so that an expression of the type $(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...$ becomes true, or reports that it is unsatisfiable."
    },
    "TopSort": {
        "scope": "cpp",
        "prefix": [
            "apoc_TopSort"
        ],
        "body": [
            "\n",
            "vi topoSort(const vector<vi>& gr) {\n",
            "\tvi indeg(sz(gr)), ret;\n",
            "\tfor (auto& li : gr) for (int x : li) indeg[x]++;\n",
            "\tqueue<int> q; // use priority_queue for lexic. largest ans.\n",
            "\trep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);\n",
            "\twhile (!q.empty()) {\n",
            "\t\tint i = q.front(); // top() for priority queue\n",
            "\t\tret.push_back(i);\n",
            "\t\tq.pop();\n",
            "\t\tfor (int x : gr[i])\n",
            "\t\t\tif (--indeg[x] == 0) q.push(x);\n",
            "\t}\n",
            "\treturn ret;\n",
            "}\n"
        ],
        "description": "$O(|V|+|E|)$ | Topological sorting. Given is an oriented graph."
    },
    "WeightedMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_WeightedMatching"
        ],
        "body": [
            "\n",
            "pair<int, vi> hungarian(const vector<vi> &a) {\n",
            "\tif (a.empty()) return {0, {}};\n",
            "\tint n = sz(a) + 1, m = sz(a[0]) + 1;\n",
            "\tvi u(n), v(m), p(m), ans(n - 1);\n",
            "\trep(i,1,n) {\n",
            "\t\tp[0] = i;\n",
            "\t\tint j0 = 0; // add \"dummy\" worker 0\n",
            "\t\tvi dist(m, INT_MAX), pre(m, -1);\n",
            "\t\tvector<bool> done(m + 1);\n",
            "\t\tdo { // dijkstra\n",
            "\t\t\tdone[j0] = true;\n",
            "\t\t\tint i0 = p[j0], j1, delta = INT_MAX;\n",
            "\t\t\trep(j,1,m) if (!done[j]) {\n",
            "\t\t\t\tauto cur = a[i0 - 1][j - 1] - u[i0] - v[j];\n",
            "\t\t\t\tif (cur < dist[j]) dist[j] = cur, pre[j] = j0;\n",
            "\t\t\t\tif (dist[j] < delta) delta = dist[j], j1 = j;\n",
            "\t\t\t}\n",
            "\t\t\trep(j,0,m) {\n",
            "\t\t\t\tif (done[j]) u[p[j]] += delta, v[j] -= delta;\n",
            "\t\t\t\telse dist[j] -= delta;\n",
            "\t\t\t}\n",
            "\t\t\tj0 = j1;\n",
            "\t\t} while (p[j0]);\n",
            "\t\twhile (j0) { // update alternating path\n",
            "\t\t\tint j1 = pre[j0];\n",
            "\t\t\tp[j0] = p[j1], j0 = j1;\n",
            "\t\t}\n",
            "\t}\n",
            "\trep(j,1,m) if (p[j]) ans[p[j] - 1] = j - 1;\n",
            "\treturn {-v[0], ans}; // min cost\n",
            "}\n"
        ],
        "description": "O(N^2M) | Given a weighted bipartite graph, matches every node on"
    },
    "SCC": {
        "scope": "cpp",
        "prefix": [
            "apoc_SCC"
        ],
        "body": [
            "\n",
            "vi val, comp, z, cont;\n",
            "int Time, ncomps;\n",
            "template<class G, class F> int dfs(int j, G& g, F& f) {\n",
            "\tint low = val[j] = ++Time, x; z.push_back(j);\n",
            "\tfor (auto e : g[j]) if (comp[e] < 0)\n",
            "\t\tlow = min(low, val[e] ?: dfs(e,g,f));\n",
            "\n",
            "\tif (low == val[j]) {\n",
            "\t\tdo {\n",
            "\t\t\tx = z.back(); z.pop_back();\n",
            "\t\t\tcomp[x] = ncomps;\n",
            "\t\t\tcont.push_back(x);\n",
            "\t\t} while (x != j);\n",
            "\t\tf(cont); cont.clear();\n",
            "\t\tncomps++;\n",
            "\t}\n",
            "\treturn val[j] = low;\n",
            "}\n",
            "template<class G, class F> void scc(G& g, F f) {\n",
            "\tint n = sz(g);\n",
            "\tval.assign(n, 0); comp.assign(n, -1);\n",
            "\tTime = ncomps = 0;\n",
            "\trep(i,0,n) if (comp[i] < 0) dfs(i, g, f);\n",
            "}\n"
        ],
        "description": "O(E + V) | Finds strongly connected components in a"
    },
    "EdgeColoring": {
        "scope": "cpp",
        "prefix": [
            "apoc_EdgeColoring"
        ],
        "body": [
            "\n",
            "vi edgeColoring(int N, vector<pii> eds) {\n",
            "\tvi cc(N + 1), ret(sz(eds)), fan(N), free(N), loc;\n",
            "\tfor (pii e : eds) ++cc[e.first], ++cc[e.second];\n",
            "\tint u, v, ncols = *max_element(all(cc)) + 1;\n",
            "\tvector<vi> adj(N, vi(ncols, -1));\n",
            "\tfor (pii e : eds) {\n",
            "\t\ttie(u, v) = e;\n",
            "\t\tfan[0] = v;\n",
            "\t\tloc.assign(ncols, 0);\n",
            "\t\tint at = u, end = u, d, c = free[u], ind = 0, i = 0;\n",
            "\t\twhile (d = free[v], !loc[d] && (v = adj[u][d]) != -1)\n",
            "\t\t\tloc[d] = ++ind, cc[ind] = d, fan[ind] = v;\n",
            "\t\tcc[loc[d]] = c;\n",
            "\t\tfor (int cd = d; at != -1; cd ^= c ^ d, at = adj[at][cd])\n",
            "\t\t\tswap(adj[at][cd], adj[end = at][cd ^ c ^ d]);\n",
            "\t\twhile (adj[fan[i]][d] != -1) {\n",
            "\t\t\tint left = fan[i], right = fan[++i], e = cc[i];\n",
            "\t\t\tadj[u][e] = left;\n",
            "\t\t\tadj[left][e] = u;\n",
            "\t\t\tadj[right][e] = -1;\n",
            "\t\t\tfree[right] = e;\n",
            "\t\t}\n",
            "\t\tadj[u][d] = fan[i];\n",
            "\t\tadj[fan[i]][d] = u;\n",
            "\t\tfor (int y : {fan[0], u, end})\n",
            "\t\t\tfor (int& z = free[y] = 0; adj[y][z] != -1; z++);\n",
            "\t}\n",
            "\trep(i,0,sz(eds))\n",
            "\t\tfor (tie(u, v) = eds[i]; adj[u][ret[i]] != v;) ++ret[i];\n",
            "\treturn ret;\n",
            "}\n"
        ],
        "description": "O(NM) | Given a simple, undirected graph with max degree $D$, computes a"
    },
    "DFSMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_DFSMatching"
        ],
        "body": [
            "\n",
            "bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {\n",
            "\tif (btoa[j] == -1) return 1;\n",
            "\tvis[j] = 1; int di = btoa[j];\n",
            "\tfor (int e : g[di])\n",
            "\t\tif (!vis[e] && find(e, g, btoa, vis)) {\n",
            "\t\t\tbtoa[e] = di;\n",
            "\t\t\treturn 1;\n",
            "\t\t}\n",
            "\treturn 0;\n",
            "}\n",
            "int dfsMatching(vector<vi>& g, vi& btoa) {\n",
            "\tvi vis;\n",
            "\trep(i,0,sz(g)) {\n",
            "\t\tvis.assign(sz(btoa), 0);\n",
            "\t\tfor (int j : g[i])\n",
            "\t\t\tif (find(j, g, btoa, vis)) {\n",
            "\t\t\t\tbtoa[j] = i;\n",
            "\t\t\t\tbreak;\n",
            "\t\t\t}\n",
            "\t}\n",
            "\treturn sz(btoa) - (int)count(all(btoa), -1);\n",
            "}\n"
        ],
        "description": "O(VE) | Simple bipartite matching algorithm. Graph $g$ should be a list"
    },
    "MaximalCliques": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximalCliques"
        ],
        "body": [
            "/// Possible optimization: on the top-most\n",
            "/// recursion level, ignore 'cands', and go through nodes in order of increasing\n",
            "/// degree, where degrees go down as nodes are removed.\n",
            "/// (mostly irrelevant given MaximumClique)\n",
            "\n",
            "typedef bitset<128> B;\n",
            "template<class F>\n",
            "void cliques(vector<B>& eds, F f, B P = ~B(), B X={}, B R={}) {\n",
            "\tif (!P.any()) { if (!X.any()) f(R); return; }\n",
            "\tauto q = (P | X)._Find_first();\n",
            "\tauto cands = P & ~eds[q];\n",
            "\trep(i,0,sz(eds)) if (cands[i]) {\n",
            "\t\tR[i] = 1;\n",
            "\t\tcliques(eds, f, P & eds[i], X & eds[i], R);\n",
            "\t\tR[i] = P[i] = 0; X[i] = 1;\n",
            "\t}\n",
            "}\n"
        ],
        "description": "O(3^{n/3}), much faster for sparse graphs | Runs a callback for all maximal cliques in a graph (given as a"
    },
    "MinimumVertexCover": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinimumVertexCover"
        ],
        "body": [
            "\n",
            "\n",
            "vi cover(vector<vi>& g, int n, int m) {\n",
            "\tvi match(m, -1);\n",
            "\tint res = dfsMatching(g, match);\n",
            "\tvector<bool> lfound(n, true), seen(m);\n",
            "\tfor (int it : match) if (it != -1) lfound[it] = false;\n",
            "\tvi q, cover;\n",
            "\trep(i,0,n) if (lfound[i]) q.push_back(i);\n",
            "\twhile (!q.empty()) {\n",
            "\t\tint i = q.back(); q.pop_back();\n",
            "\t\tlfound[i] = 1;\n",
            "\t\tfor (int e : g[i]) if (!seen[e] && match[e] != -1) {\n",
            "\t\t\tseen[e] = true;\n",
            "\t\t\tq.push_back(match[e]);\n",
            "\t\t}\n",
            "\t}\n",
            "\trep(i,0,n) if (!lfound[i]) cover.push_back(i);\n",
            "\trep(i,0,m) if (seen[i]) cover.push_back(n+i);\n",
            "\tassert(sz(cover) == res);\n",
            "\treturn cover;\n",
            "}\n"
        ],
        "description": "Finds a minimum vertex cover in a bipartite graph."
    },
    "DirectedMST": {
        "scope": "cpp",
        "prefix": [
            "apoc_DirectedMST"
        ],
        "body": [
            "\n",
            "\n",
            "struct Edge { int a, b; ll w; };\n",
            "struct Node { /// lazy skew heap node\n",
            "\tEdge key;\n",
            "\tNode *l, *r;\n",
            "\tll delta;\n",
            "\tvoid prop() {\n",
            "\t\tkey.w += delta;\n",
            "\t\tif (l) l->delta += delta;\n",
            "\t\tif (r) r->delta += delta;\n",
            "\t\tdelta = 0;\n",
            "\t}\n",
            "\tEdge top() { prop(); return key; }\n",
            "};\n",
            "Node *merge(Node *a, Node *b) {\n",
            "\tif (!a || !b) return a ?: b;\n",
            "\ta->prop(), b->prop();\n",
            "\tif (a->key.w > b->key.w) swap(a, b);\n",
            "\tswap(a->l, (a->r = merge(b, a->r)));\n",
            "\treturn a;\n",
            "}\n",
            "void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }\n",
            "\n",
            "pair<ll, vi> dmst(int n, int r, vector<Edge>& g) {\n",
            "\tRollbackUF uf(n);\n",
            "\tvector<Node*> heap(n);\n",
            "\tfor (Edge e : g) heap[e.b] = merge(heap[e.b], new Node{e});\n",
            "\tll res = 0;\n",
            "\tvi seen(n, -1), path(n), par(n);\n",
            "\tseen[r] = r;\n",
            "\tvector<Edge> Q(n), in(n, {-1,-1}), comp;\n",
            "\tdeque<tuple<int, int, vector<Edge>>> cycs;\n",
            "\trep(s,0,n) {\n",
            "\t\tint u = s, qi = 0, w;\n",
            "\t\twhile (seen[u] < 0) {\n",
            "\t\t\tif (!heap[u]) return {-1,{}};\n",
            "\t\t\tEdge e = heap[u]->top();\n",
            "\t\t\theap[u]->delta -= e.w, pop(heap[u]);\n",
            "\t\t\tQ[qi] = e, path[qi++] = u, seen[u] = s;\n",
            "\t\t\tres += e.w, u = uf.find(e.a);\n",
            "\t\t\tif (seen[u] == s) { /// found cycle, contract\n",
            "\t\t\t\tNode* cyc = 0;\n",
            "\t\t\t\tint end = qi, time = uf.time();\n",
            "\t\t\t\tdo cyc = merge(cyc, heap[w = path[--qi]]);\n",
            "\t\t\t\twhile (uf.join(u, w));\n",
            "\t\t\t\tu = uf.find(u), heap[u] = cyc, seen[u] = -1;\n",
            "\t\t\t\tcycs.push_front({u, time, {&Q[qi], &Q[end]}});\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\trep(i,0,qi) in[uf.find(Q[i].b)] = Q[i];\n",
            "\t}\n",
            "\n",
            "\tfor (auto& [u,t,comp] : cycs) { // restore sol (optional)\n",
            "\t\tuf.rollback(t);\n",
            "\t\tEdge inEdge = in[u];\n",
            "\t\tfor (auto& e : comp) in[uf.find(e.b)] = e;\n",
            "\t\tin[uf.find(inEdge.b)] = inEdge;\n",
            "\t}\n",
            "\trep(i,0,n) par[i] = in[i].a;\n",
            "\treturn {res, par};\n",
            "}\n"
        ],
        "description": "O(E \\log V) | Finds a minimum spanning"
    },
    "PushRelabel": {
        "scope": "cpp",
        "prefix": [
            "apoc_PushRelabel"
        ],
        "body": [
            "\n",
            "\n",
            "struct PushRelabel {\n",
            "\tstruct Edge {\n",
            "\t\tint dest, back;\n",
            "\t\tll f, c;\n",
            "\t};\n",
            "\tvector<vector<Edge>> g;\n",
            "\tvector<ll> ec;\n",
            "\tvector<Edge*> cur;\n",
            "\tvector<vi> hs; vi H;\n",
            "\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n",
            "\n",
            "\tvoid addEdge(int s, int t, ll cap, ll rcap=0) {\n",
            "\t\tif (s == t) return;\n",
            "\t\tg[s].push_back({t, sz(g[t]), 0, cap});\n",
            "\t\tg[t].push_back({s, sz(g[s])-1, 0, rcap});\n",
            "\t}\n",
            "\n",
            "\tvoid addFlow(Edge& e, ll f) {\n",
            "\t\tEdge &back = g[e.dest][e.back];\n",
            "\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n",
            "\t\te.f += f; e.c -= f; ec[e.dest] += f;\n",
            "\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n",
            "\t}\n",
            "\tll calc(int s, int t) {\n",
            "\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n",
            "\t\tvi co(2*v); co[0] = v-1;\n",
            "\t\trep(i,0,v) cur[i] = g[i].data();\n",
            "\t\tfor (Edge& e : g[s]) addFlow(e, e.c);\n",
            "\n",
            "\t\tfor (int hi = 0;;) {\n",
            "\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n",
            "\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n",
            "\t\t\twhile (ec[u] > 0)  // discharge u\n",
            "\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n",
            "\t\t\t\t\tH[u] = 1e9;\n",
            "\t\t\t\t\tfor (Edge& e : g[u]) if (e.c && H[u] > H[e.dest]+1)\n",
            "\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n",
            "\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n",
            "\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n",
            "\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n",
            "\t\t\t\t\thi = H[u];\n",
            "\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n",
            "\t\t\t\t\taddFlow(*cur[u], min(ec[u], cur[u]->c));\n",
            "\t\t\t\telse ++cur[u];\n",
            "\t\t}\n",
            "\t}\n",
            "\tbool leftOfMinCut(int a) { return H[a] >= sz(g); }\n",
            "};\n"
        ],
        "description": "$O(V^2\\sqrt E)$ | Push-relabel using the highest label selection rule and the gap heuristic. Quite fast in practice."
    },
    "MinCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCut"
        ],
        "body": [],
        "description": "After running max-flow, the left side of a min-cut from $s$ to $t$ is given by all vertices reachable from $s$, only traversing edges with positive residual capacity."
    },
    "GomoryHu": {
        "scope": "cpp",
        "prefix": [
            "apoc_GomoryHu"
        ],
        "body": [
            " *\n",
            "\n",
            "\n",
            "typedef array<ll, 3> Edge;\n",
            "vector<Edge> gomoryHu(int N, vector<Edge> ed) {\n",
            "\tvector<Edge> tree;\n",
            "\tvi par(N);\n",
            "\trep(i,1,N) {\n",
            "\t\tPushRelabel D(N); // Dinic also works\n",
            "\t\tfor (Edge t : ed) D.addEdge(t[0], t[1], t[2], t[2]);\n",
            "\t\ttree.push_back({i, par[i], D.calc(i, par[i])});\n",
            "\t\trep(j,i+1,N)\n",
            "\t\t\tif (par[j] == par[i] && D.leftOfMinCut(j)) par[j] = i;\n",
            "\t}\n",
            "\treturn tree;\n",
            "}\n"
        ],
        "description": "$O(V)$ Flow Computations | Given a list of edges representing an undirected flow graph,"
    },
    "MaximumIndependentSet": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximumIndependentSet"
        ],
        "body": [],
        "description": "To obtain a maximum independent set of a graph, find a max"
    },
    "MaximumClique": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximumClique"
        ],
        "body": [
            "typedef vector<bitset<200>> vb;\n",
            "struct Maxclique {\n",
            "\tdouble limit=0.025, pk=0;\n",
            "\tstruct Vertex { int i, d=0; };\n",
            "\ttypedef vector<Vertex> vv;\n",
            "\tvb e;\n",
            "\tvv V;\n",
            "\tvector<vi> C;\n",
            "\tvi qmax, q, S, old;\n",
            "\tvoid init(vv& r) {\n",
            "\t\tfor (auto& v : r) v.d = 0;\n",
            "\t\tfor (auto& v : r) for (auto j : r) v.d += e[v.i][j.i];\n",
            "\t\tsort(all(r), [](auto a, auto b) { return a.d > b.d; });\n",
            "\t\tint mxD = r[0].d;\n",
            "\t\trep(i,0,sz(r)) r[i].d = min(i, mxD) + 1;\n",
            "\t}\n",
            "\tvoid expand(vv& R, int lev = 1) {\n",
            "\t\tS[lev] += S[lev - 1] - old[lev];\n",
            "\t\told[lev] = S[lev - 1];\n",
            "\t\twhile (sz(R)) {\n",
            "\t\t\tif (sz(q) + R.back().d <= sz(qmax)) return;\n",
            "\t\t\tq.push_back(R.back().i);\n",
            "\t\t\tvv T;\n",
            "\t\t\tfor(auto v:R) if (e[R.back().i][v.i]) T.push_back({v.i});\n",
            "\t\t\tif (sz(T)) {\n",
            "\t\t\t\tif (S[lev]++ / ++pk < limit) init(T);\n",
            "\t\t\t\tint j = 0, mxk = 1, mnk = max(sz(qmax) - sz(q) + 1, 1);\n",
            "\t\t\t\tC[1].clear(), C[2].clear();\n",
            "\t\t\t\tfor (auto v : T) {\n",
            "\t\t\t\t\tint k = 1;\n",
            "\t\t\t\t\tauto f = [&](int i) { return e[v.i][i]; };\n",
            "\t\t\t\t\twhile (any_of(all(C[k]), f)) k++;\n",
            "\t\t\t\t\tif (k > mxk) mxk = k, C[mxk + 1].clear();\n",
            "\t\t\t\t\tif (k < mnk) T[j++].i = v.i;\n",
            "\t\t\t\t\tC[k].push_back(v.i);\n",
            "\t\t\t\t}\n",
            "\t\t\t\tif (j > 0) T[j - 1].d = 0;\n",
            "\t\t\t\trep(k,mnk,mxk + 1) for (int i : C[k])\n",
            "\t\t\t\t\tT[j].i = i, T[j++].d = k;\n",
            "\t\t\t\texpand(T, lev + 1);\n",
            "\t\t\t} else if (sz(q) > sz(qmax)) qmax = q;\n",
            "\t\t\tq.pop_back(), R.pop_back();\n",
            "\t\t}\n",
            "\t}\n",
            "\tvi maxClique() { init(V), expand(V); return qmax; }\n",
            "\tMaxclique(vb conn) : e(conn), C(sz(e)+1), S(sz(C)), old(S) {\n",
            "\t\trep(i,0,sz(e)) V.push_back({i});\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Runs in about 1s for n=155 and worst case random graphs (p=.90). Runs | Quickly finds a maximum clique of a graph (given as symmetric bitset"
    },
    "GlobalMinCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_GlobalMinCut"
        ],
        "body": [
            "\n",
            "pair<int, vi> globalMinCut(vector<vi> mat) {\n",
            "\tpair<int, vi> best = {INT_MAX, {}};\n",
            "\tint n = sz(mat);\n",
            "\tvector<vi> co(n);\n",
            "\trep(i,0,n) co[i] = {i};\n",
            "\trep(ph,1,n) {\n",
            "\t\tvi w = mat[0];\n",
            "\t\tsize_t s = 0, t = 0;\n",
            "\t\trep(it,0,n-ph) { // O(V^2) -> O(E log V) with prio. queue\n",
            "\t\t\tw[t] = INT_MIN;\n",
            "\t\t\ts = t, t = max_element(all(w)) - w.begin();\n",
            "\t\t\trep(i,0,n) w[i] += mat[t][i];\n",
            "\t\t}\n",
            "\t\tbest = min(best, {w[t] - mat[t][t], co[t]});\n",
            "\t\tco[s].insert(co[s].end(), all(co[t]));\n",
            "\t\trep(i,0,n) mat[s][i] += mat[t][i];\n",
            "\t\trep(i,0,n) mat[i][s] = mat[s][i];\n",
            "\t\tmat[0][t] = INT_MIN;\n",
            "\t}\n",
            "\treturn best;\n",
            "}\n"
        ],
        "description": "O(V^3) | Find a global minimum cut in an undirected graph, as represented by an adjacency matrix."
    },
    "Dinic": {
        "scope": "cpp",
        "prefix": [
            "apoc_Dinic"
        ],
        "body": [
            "\n",
            "struct Dinic {\n",
            "\tstruct Edge {\n",
            "\t\tint to, rev;\n",
            "\t\tll c, oc;\n",
            "\t\tll flow() { return max(oc - c, 0LL); } // if you need flows\n",
            "\t};\n",
            "\tvi lvl, ptr, q;\n",
            "\tvector<vector<Edge>> adj;\n",
            "\tDinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}\n",
            "\tvoid addEdge(int a, int b, ll c, ll rcap = 0) {\n",
            "\t\tadj[a].push_back({b, sz(adj[b]), c, c});\n",
            "\t\tadj[b].push_back({a, sz(adj[a]) - 1, rcap, rcap});\n",
            "\t}\n",
            "\tll dfs(int v, int t, ll f) {\n",
            "\t\tif (v == t || !f) return f;\n",
            "\t\tfor (int& i = ptr[v]; i < sz(adj[v]); i++) {\n",
            "\t\t\tEdge& e = adj[v][i];\n",
            "\t\t\tif (lvl[e.to] == lvl[v] + 1)\n",
            "\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {\n",
            "\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;\n",
            "\t\t\t\t\treturn p;\n",
            "\t\t\t\t}\n",
            "\t\t}\n",
            "\t\treturn 0;\n",
            "\t}\n",
            "\tll calc(int s, int t) {\n",
            "\t\tll flow = 0; q[0] = s;\n",
            "\t\trep(L,0,31) do { // 'int L=30' maybe faster for random data\n",
            "\t\t\tlvl = ptr = vi(sz(q));\n",
            "\t\t\tint qi = 0, qe = lvl[s] = 1;\n",
            "\t\t\twhile (qi < qe && !lvl[t]) {\n",
            "\t\t\t\tint v = q[qi++];\n",
            "\t\t\t\tfor (Edge e : adj[v])\n",
            "\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))\n",
            "\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;\n",
            "\t\t\t}\n",
            "\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;\n",
            "\t\t} while (lvl[t]);\n",
            "\t\treturn flow;\n",
            "\t}\n",
            "\tbool leftOfMinCut(int a) { return lvl[a] != 0; }\n",
            "};\n"
        ],
        "description": "Flow algorithm with complexity $O(VE\\log U)$ where $U = \\max |\\text{cap}|$."
    },
    "CircleIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleIntersection"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "bool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {\n",
            "\tif (a == b) { assert(r1 != r2); return false; }\n",
            "\tP vec = b - a;\n",
            "\tdouble d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,\n",
            "\t       p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;\n",
            "\tif (sum*sum < d2 || dif*dif > d2) return false;\n",
            "\tP mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);\n",
            "\treturn true;\n",
            "}\n"
        ],
        "description": "Computes the pair of points at which two circles intersect. Returns false in case of no intersection."
    },
    "lineIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_lineIntersection"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            "If a unique intersection point of the lines going through s1,e1 and s2,e2 exists \\{1, point\\} is returned.\n",
            "If no intersection point exists \\{0, (0,0)\\} is returned and if infinitely many exists \\{-1, (0,0)\\} is returned.\n",
            "The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.\n",
            "Products of three coordinates are used in intermediate steps so watch out for overflow if using int or ll.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/lineIntersection}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "template<class P>\n",
            "pair<int, P> lineInter(P s1, P e1, P s2, P e2) {\n",
            "\tauto d = (e1 - s1).cross(e2 - s2);\n",
            "\tif (d == 0) // if parallel\n",
            "\t\treturn {-(s1.cross(e1, s2) == 0), P(0, 0)};\n",
            "\tauto p = s2.cross(e1, e2), q = s2.cross(e2, s1);\n",
            "\treturn {1, (s1 * p + e1 * q) / d};\n",
            "}\n"
        ],
        "description": "Description:\\\\ Usage: \tauto res = lineInter(s1,e1,s2,e2); \tif (res.first == 1) \t\tcout << \"intersection point at \" << res.second << endl;"
    },
    "LineHullIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineHullIntersection"
        ],
        "body": [
            "\n",
            "\n",
            "#define cmp(i,j) sgn(dir.perp().cross(poly[(i)%n]-poly[(j)%n]))\n",
            "#define extr(i) cmp(i + 1, i) >= 0 && cmp(i, i - 1 + n) < 0\n",
            "template <class P> int extrVertex(vector<P>& poly, P dir) {\n",
            "\tint n = sz(poly), lo = 0, hi = n;\n",
            "\tif (extr(0)) return 0;\n",
            "\twhile (lo + 1 < hi) {\n",
            "\t\tint m = (lo + hi) / 2;\n",
            "\t\tif (extr(m)) return m;\n",
            "\t\tint ls = cmp(lo + 1, lo), ms = cmp(m + 1, m);\n",
            "\t\t(ls < ms || (ls == ms && ls == cmp(lo, m)) ? hi : lo) = m;\n",
            "\t}\n",
            "\treturn lo;\n",
            "}\n",
            "\n",
            "#define cmpL(i) sgn(a.cross(poly[i], b))\n",
            "template <class P>\n",
            "array<int, 2> lineHull(P a, P b, vector<P>& poly) {\n",
            "\tint endA = extrVertex(poly, (a - b).perp());\n",
            "\tint endB = extrVertex(poly, (b - a).perp());\n",
            "\tif (cmpL(endA) < 0 || cmpL(endB) > 0)\n",
            "\t\treturn {-1, -1};\n",
            "\tarray<int, 2> res;\n",
            "\trep(i,0,2) {\n",
            "\t\tint lo = endB, hi = endA, n = sz(poly);\n",
            "\t\twhile ((lo + 1) % n != hi) {\n",
            "\t\t\tint m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;\n",
            "\t\t\t(cmpL(m) == cmpL(endB) ? lo : hi) = m;\n",
            "\t\t}\n",
            "\t\tres[i] = (lo + !cmpL(hi)) % n;\n",
            "\t\tswap(endA, endB);\n",
            "\t}\n",
            "\tif (res[0] == res[1]) return {res[0], -1};\n",
            "\tif (!cmpL(res[0]) && !cmpL(res[1]))\n",
            "\t\tswitch ((res[0] - res[1] + sz(poly) + 1) % sz(poly)) {\n",
            "\t\t\tcase 0: return {res[0], res[0]};\n",
            "\t\t\tcase 2: return {res[1], res[1]};\n",
            "\t\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "O(\\log n) | Line-convex polygon intersection. The polygon must be ccw and have no collinear points."
    },
    "segDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_segDistance"
        ],
        "body": [
            "\n",
            "template<class P> ld segDist(P s, P e, P p) {\n",
            "    if(s == e) return (p - s).mag();\n",
            "    auto d = (e-s).mag2(), t = min(d, max(0.0, (p-s).dot(e-s)));\n",
            "    return ((p - s)*d - (e - s)*t).mag() / d;\n",
            "}"
        ],
        "description": "Gets the distance between a point and a segment. /"
    },
    "minkowskiSum": {
        "scope": "cpp",
        "prefix": [
            "apoc_minkowskiSum"
        ],
        "body": [
            "\n",
            "template<class P> vector<P> minkSum(vector<vector<P>> &polys){\n",
            "    P init(0, 0);\n",
            "    vector<P> dir;\n",
            "    for(auto poly: polys) {\n",
            "        int n = sz(poly);\n",
            "        if(n == 0)\n",
            "            continue;\n",
            "        init = init + poly[0];\n",
            "        if(n == 1)\n",
            "            continue;\n",
            "        rep(i, 0, n)\n",
            "            dir.push_back(poly[(i+1)%n] - poly[i]);\n",
            "    }\n",
            "    if(size(dir) == 0)\n",
            "        return {init};\n",
            "    sort(all(dir), [&](P a, P b)->bool {\n",
            "        bool sideA = a.x > 0 || (a.x == 0 && a.y > 0);\n",
            "        bool sideB = b.x > 0 || (b.x == 0 && b.y > 0);\n",
            "        if(sideA != sideB)\n",
            "            return sideA;\n",
            "        return a.cross(b) > 0;\n",
            "    });\n",
            "    vector<P> sum;\n",
            "    P cur = init;\n",
            "    rep(i, 0, sz(dir)) {\n",
            "        sum.push_back(cur);\n",
            "        cur = cur + dir[i];\n",
            "    }\n",
            "    return sum;\n",
            "}\n"
        ],
        "description": "returns the minkowski sum of several polygons"
    },
    "lineDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_lineDistance"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            "Returns the signed distance between point p and the line containing points a and b. Positive value on left side and negative on right as seen from a towards b. a==b gives nan. P is supposed to be Point<T> or Point3D<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long. Using Point3D will always give a non-negative distance. For Point3D, call .dist on the result of the cross product.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/lineDistance}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "template<class P>\n",
            "double lineDist(const P& a, const P& b, const P& p) {\n",
            "\treturn (double)(b-a).cross(p-a)/(b-a).dist();\n",
            "}\n"
        ],
        "description": "Description:\\\\"
    },
    "segIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_segIntersection"
        ],
        "body": [
            "\n",
            "template<class P> vector<P> segInter(P s1, P e1, P s2, P e2) {\n",
            "    if(doSegInter(s1, e1, s2, e2)) return {lineInter(s1, e1, s2, e2)};\n",
            "\tset<P> seg;\n",
            "    if(onSeg(s1, e1, s2)) seg.insert(s2);\n",
            "    if(onSeg(s1, e1, e2)) seg.insert(e2);\n",
            "    if(onSeg(s2, e2, s1)) seg.insert(s1);\n",
            "    if(onSeg(s2, e2, e1)) seg.insert(e1);\n",
            "    return {all(seg)};\n",
            "}"
        ],
        "description": "Returns the intersection point of two segments."
    },
    "3dHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_3dHull"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point3D<double> P3;\n",
            "\n",
            "struct PR {\n",
            "\tvoid ins(int x) { (a == -1 ? a : b) = x; }\n",
            "\tvoid rem(int x) { (a == x ? a : b) = -1; }\n",
            "\tint cnt() { return (a != -1) + (b != -1); }\n",
            "\tint a, b;\n",
            "};\n",
            "\n",
            "struct F { P3 q; int a, b, c; };\n",
            "\n",
            "vector<F> hull3d(const vector<P3>& A) {\n",
            "\tassert(sz(A) >= 4);\n",
            "\tvector<vector<PR>> E(sz(A), vector<PR>(sz(A), {-1, -1}));\n",
            "#define E(x,y) E[f.x][f.y]\n",
            "\tvector<F> FS;\n",
            "\tauto mf = [&](int i, int j, int k, int l) {\n",
            "\t\tP3 q = (A[j] - A[i]).cross((A[k] - A[i]));\n",
            "\t\tif (q.dot(A[l]) > q.dot(A[i]))\n",
            "\t\t\tq = q * -1;\n",
            "\t\tF f{q, i, j, k};\n",
            "\t\tE(a,b).ins(k); E(a,c).ins(j); E(b,c).ins(i);\n",
            "\t\tFS.push_back(f);\n",
            "\t};\n",
            "\trep(i,0,4) rep(j,i+1,4) rep(k,j+1,4)\n",
            "\t\tmf(i, j, k, 6 - i - j - k);\n",
            "\n",
            "\trep(i,4,sz(A)) {\n",
            "\t\trep(j,0,sz(FS)) {\n",
            "\t\t\tF f = FS[j];\n",
            "\t\t\tif(f.q.dot(A[i]) > f.q.dot(A[f.a])) {\n",
            "\t\t\t\tE(a,b).rem(f.c);\n",
            "\t\t\t\tE(a,c).rem(f.b);\n",
            "\t\t\t\tE(b,c).rem(f.a);\n",
            "\t\t\t\tswap(FS[j--], FS.back());\n",
            "\t\t\t\tFS.pop_back();\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\tint nw = sz(FS);\n",
            "\t\trep(j,0,nw) {\n",
            "\t\t\tF f = FS[j];\n",
            "#define C(a, b, c) if (E(a,b).cnt() != 2) mf(f.a, f.b, i, f.c);\n",
            "\t\t\tC(a, b, c); C(a, c, b); C(b, c, a);\n",
            "\t\t}\n",
            "\t}\n",
            "\tfor (F& it : FS) if ((A[it.b] - A[it.a]).cross(\n",
            "\t\tA[it.c] - A[it.a]).dot(it.q) <= 0) swap(it.c, it.b);\n",
            "\treturn FS;\n",
            "};\n"
        ],
        "description": "O(n^2) | Computes all faces of the 3-dimension hull of a point set."
    },
    "PolyhedronVolume": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyhedronVolume"
        ],
        "body": [
            "\n",
            "template<class V, class L>\n",
            "double signedPolyVolume(const V& p, const L& trilist) {\n",
            "\tdouble v = 0;\n",
            "\tfor (auto i : trilist) v += p[i.a].cross(p[i.b]).dot(p[i.c]);\n",
            "\treturn v / 6;\n",
            "}\n"
        ],
        "description": "Magic formula for the volume of a polyhedron. Faces should point outwards."
    },
    "sideOf": {
        "scope": "cpp",
        "prefix": [
            "apoc_sideOf"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P>\n",
            "int sideOf(P s, P e, P p) { return sgn(s.cross(e, p)); }\n",
            "\n",
            "template<class P>\n",
            "int sideOf(const P& s, const P& e, const P& p, double eps) {\n",
            "\tauto a = (e-s).cross(p-s);\n",
            "\tdouble l = (e-s).dist()*eps;\n",
            "\treturn (a > l) - (a < -l);\n",
            "}\n"
        ],
        "description": "Returns where $p$ is as seen from $s$ towards $e$. 1/0/-1 $\\Leftrightarrow$ left/on line/right. If the optional argument $eps$ is given 0 is returned if $p$ is within distance $eps$ from the line. P is supposed to be Point<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long."
    },
    "kdTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_kdTree"
        ],
        "body": [
            "\n",
            "\n",
            "typedef long long T;\n",
            "typedef Point<T> P;\n",
            "const T INF = numeric_limits<T>::max();\n",
            "\n",
            "bool on_x(const P& a, const P& b) { return a.x < b.x; }\n",
            "bool on_y(const P& a, const P& b) { return a.y < b.y; }\n",
            "\n",
            "struct Node {\n",
            "\tP pt; // if this is a leaf, the single point in it\n",
            "\tT x0 = INF, x1 = -INF, y0 = INF, y1 = -INF; // bounds\n",
            "\tNode *first = 0, *second = 0;\n",
            "\n",
            "\tT distance(const P& p) { // min squared distance to a point\n",
            "\t\tT x = (p.x < x0 ? x0 : p.x > x1 ? x1 : p.x);\n",
            "\t\tT y = (p.y < y0 ? y0 : p.y > y1 ? y1 : p.y);\n",
            "\t\treturn (P(x,y) - p).dist2();\n",
            "\t}\n",
            "\n",
            "\tNode(vector<P>&& vp) : pt(vp[0]) {\n",
            "\t\tfor (P p : vp) {\n",
            "\t\t\tx0 = min(x0, p.x); x1 = max(x1, p.x);\n",
            "\t\t\ty0 = min(y0, p.y); y1 = max(y1, p.y);\n",
            "\t\t}\n",
            "\t\tif (vp.size() > 1) {\n",
            "\t\t\t// split on x if width >= height (not ideal...)\n",
            "\t\t\tsort(all(vp), x1 - x0 >= y1 - y0 ? on_x : on_y);\n",
            "\t\t\t// divide by taking half the array for each child (not\n",
            "\t\t\t// best performance with many duplicates in the middle)\n",
            "\t\t\tint half = sz(vp)/2;\n",
            "\t\t\tfirst = new Node({vp.begin(), vp.begin() + half});\n",
            "\t\t\tsecond = new Node({vp.begin() + half, vp.end()});\n",
            "\t\t}\n",
            "\t}\n",
            "};\n",
            "\n",
            "struct KDTree {\n",
            "\tNode* root;\n",
            "\tKDTree(const vector<P>& vp) : root(new Node({all(vp)})) {}\n",
            "\n",
            "\tpair<T, P> search(Node *node, const P& p) {\n",
            "\t\tif (!node->first) {\n",
            "\t\t\t// uncomment if we should not find the point itself:\n",
            "\t\t\t// if (p == node->pt) return {INF, P()};\n",
            "\t\t\treturn make_pair((p - node->pt).dist2(), node->pt);\n",
            "\t\t}\n",
            "\n",
            "\t\tNode *f = node->first, *s = node->second;\n",
            "\t\tT bfirst = f->distance(p), bsec = s->distance(p);\n",
            "\t\tif (bfirst > bsec) swap(bsec, bfirst), swap(f, s);\n",
            "\n",
            "\t\t// search closest side first, other side if needed\n",
            "\t\tauto best = search(f, p);\n",
            "\t\tif (bsec < best.first)\n",
            "\t\t\tbest = min(best, search(s, p));\n",
            "\t\treturn best;\n",
            "\t}\n",
            "\n",
            "\t// find nearest point to a point, and its squared distance\n",
            "\t// (requires an arbitrary operator< for Point)\n",
            "\tpair<T, P> nearest(const P& p) {\n",
            "\t\treturn search(root, p);\n",
            "\t}\n",
            "};\n"
        ],
        "description": "KD-tree (2d, can be extended to 3d)"
    },
    "polygonClipping": {
        "scope": "cpp",
        "prefix": [
            "apoc_polygonClipping"
        ],
        "body": [
            "\n",
            "template <class P> vector<P> polyClip(const vector<P>& poly, P s, P e) {\n",
            "\tvector<P> res;\n",
            "\trep(i,0,sz(poly)) {\n",
            "\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();\n",
            "\t\tbool side = s.cross(e, cur) < 0;\n",
            "\t\tif (side != (s.cross(e, prev) < 0))\n",
            "\t\t\tres.push_back(lineInter(s, e, cur, prev).second);\n",
            "\t\tif (side)\n",
            "\t\t\tres.push_back(cur);\n",
            "\t}\n",
            "\treturn res;\n",
            "}"
        ],
        "description": "O(n) | Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away."
    },
    "hullDiameter": {
        "scope": "cpp",
        "prefix": [
            "apoc_hullDiameter"
        ],
        "body": [
            "\n",
            "template<class P> pair<P, P> hullDiameter(vector<P> poly){\n",
            "    int n = sz(poly); if(n < 3) return 0;\n",
            "    int j = 1;\n",
            "    \n",
            "    pair<ld, pair<P, P>> ans(0, pair<P, P>(poly[0], poly[0]));\n",
            "    rep(i, 0, j){\n",
            "        for(;; j = (j+1)%n){\n",
            "            ans = max(ans, {(poly[i]-poly[j]).mag2(), {poly[i], poly[j]}});\n",
            "            if((poly[(j+1)%n] - poly[j]).cross(poly[i+1] - poly[i]) >= 0)\n",
            "                break;\n",
            "        }\n",
            "    }\n",
            "    return ans.second;\n",
            "}"
        ],
        "description": "O(n) | Gets the furthest set of points on a convex polygon using rotating calipers"
    },
    "SegmentDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentDistance"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            "Returns the shortest distance between point p and the line segment from point s to e.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\vspace{-10mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/SegmentDistance}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "double segDist(P& s, P& e, P& p) {\n",
            "\tif (s==e) return (p-s).dist();\n",
            "\tauto d = (e-s).dist2(), t = min(d,max(.0,(p-s).dot(e-s)));\n",
            "\treturn ((p-s)*d-(e-s)*t).dist()/d;\n",
            "}\n"
        ],
        "description": "Source: Description:\\\\ \tPoint<double> a, b(2,2), p(1,1); \tbool onSegment = segDist(a,b,p) < 1e-10;"
    },
    "Point": {
        "scope": "cpp",
        "prefix": [
            "apoc_Point"
        ],
        "body": [
            "\n",
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n",
            "template<class T>\n",
            "struct Point {\n",
            "\ttypedef Point P;\n",
            "\tT x, y;\n",
            "\texplicit Point(T x=0, T y=0) : x(x), y(y) {}\n",
            "\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }\n",
            "\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }\n",
            "\tP operator+(P p) const { return P(x+p.x, y+p.y); }\n",
            "\tP operator-(P p) const { return P(x-p.x, y-p.y); }\n",
            "\tP operator*(T d) const { return P(x*d, y*d); }\n",
            "\tP operator/(T d) const { return P(x/d, y/d); }\n",
            "\tT dot(P p) const { return x*p.x + y*p.y; }\n",
            "\tT cross(P p) const { return x*p.y - y*p.x; }\n",
            "\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }\n",
            "\tT dist2() const { return x*x + y*y; }\n",
            "\tdouble dist() const { return sqrt((double)dist2()); }\n",
            "\t// angle to x-axis in interval [-pi, pi]\n",
            "\tdouble angle() const { return atan2(y, x); }\n",
            "\tP unit() const { return *this/dist(); } // makes dist()=1\n",
            "\tP perp() const { return P(-y, x); } // rotates +90 degrees\n",
            "\tP normal() const { return perp().unit(); }\n",
            "\t// returns point rotated 'a' radians ccw around the origin\n",
            "\tP rotate(double a) const {\n",
            "\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }\n",
            "\tfriend ostream& operator<<(ostream& os, P p) {\n",
            "\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; }\n",
            "};\n"
        ],
        "description": "Class to handle points in the plane."
    },
    "MinimumEnclosingCircle": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinimumEnclosingCircle"
        ],
        "body": [
            "\n",
            "\n",
            "pair<P, double> mec(vector<P> ps) {\n",
            "\tshuffle(all(ps), mt19937(time(0)));\n",
            "\tP o = ps[0];\n",
            "\tdouble r = 0, EPS = 1 + 1e-8;\n",
            "\trep(i,0,sz(ps)) if ((o - ps[i]).dist() > r * EPS) {\n",
            "\t\to = ps[i], r = 0;\n",
            "\t\trep(j,0,i) if ((o - ps[j]).dist() > r * EPS) {\n",
            "\t\t\to = (ps[i] + ps[j]) / 2;\n",
            "\t\t\tr = (o - ps[i]).dist();\n",
            "\t\t\trep(k,0,j) if ((o - ps[k]).dist() > r * EPS) {\n",
            "\t\t\t\to = ccCenter(ps[i], ps[j], ps[k]);\n",
            "\t\t\t\tr = (o - ps[i]).dist();\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t}\n",
            "\treturn {o, r};\n",
            "}\n"
        ],
        "description": "expected O(n) | Computes the minimum circle that encloses a set of points."
    },
    "centerOfMass": {
        "scope": "cpp",
        "prefix": [
            "apoc_centerOfMass"
        ],
        "body": [
            "\n",
            "template<class P> P polygonCenter(const vector<P>& v) {\n",
            "\tP res(0, 0); double A = 0;\n",
            "\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {\n",
            "\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);\n",
            "\t\tA += v[j].cross(v[i]);\n",
            "\t}\n",
            "\treturn res / A / 3;\n",
            "}"
        ],
        "description": "O(n) | Returns the center of mass for a polygon."
    },
    "ClosestPair": {
        "scope": "cpp",
        "prefix": [
            "apoc_ClosestPair"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<ll> P;\n",
            "pair<P, P> closest(vector<P> v) {\n",
            "\tassert(sz(v) > 1);\n",
            "\tset<P> S;\n",
            "\tsort(all(v), [](P a, P b) { return a.y < b.y; });\n",
            "\tpair<ll, pair<P, P>> ret{LLONG_MAX, {P(), P()}};\n",
            "\tint j = 0;\n",
            "\tfor (P p : v) {\n",
            "\t\tP d{1 + (ll)sqrt(ret.first), 0};\n",
            "\t\twhile (v[j].y <= p.y - d.x) S.erase(v[j++]);\n",
            "\t\tauto lo = S.lower_bound(p - d), hi = S.upper_bound(p + d);\n",
            "\t\tfor (; lo != hi; ++lo)\n",
            "\t\t\tret = min(ret, {(*lo - p).dist2(), {*lo, p}});\n",
            "\t\tS.insert(p);\n",
            "\t}\n",
            "\treturn ret.second;\n",
            "}\n"
        ],
        "description": "O(n \\log n) | Finds the closest pair of points."
    },
    "OnSegment": {
        "scope": "cpp",
        "prefix": [
            "apoc_OnSegment"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P> bool onSegment(P s, P e, P p) {\n",
            "\treturn p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;\n",
            "}\n"
        ],
        "description": "Returns true iff p lies on the line segment from s to e."
    },
    "PolygonCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonCut"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            " Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\vspace{-6mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/PolygonCut}\n",
            "\\vspace{-6mm}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "vector<P> polygonCut(const vector<P>& poly, P s, P e) {\n",
            "\tvector<P> res;\n",
            "\trep(i,0,sz(poly)) {\n",
            "\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();\n",
            "\t\tbool side = s.cross(e, cur) < 0;\n",
            "\t\tif (side != (s.cross(e, prev) < 0))\n",
            "\t\t\tres.push_back(lineInter(s, e, cur, prev).second);\n",
            "\t\tif (side)\n",
            "\t\t\tres.push_back(cur);\n",
            "\t}\n",
            "\treturn res;\n",
            "}\n"
        ],
        "description": "Source: Description:\\\\ Usage: \tvector<P> p = ...; \tp = polygonCut(p, P(0,0), P(1,0));"
    },
    "CirclePolygonIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_CirclePolygonIntersection"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "#define arg(p, q) atan2(p.cross(q), p.dot(q))\n",
            "double circlePoly(P c, double r, vector<P> ps) {\n",
            "\tauto tri = [&](P p, P q) {\n",
            "\t\tauto r2 = r * r / 2;\n",
            "\t\tP d = q - p;\n",
            "\t\tauto a = d.dot(p)/d.dist2(), b = (p.dist2()-r*r)/d.dist2();\n",
            "\t\tauto det = a * a - b;\n",
            "\t\tif (det <= 0) return arg(p, q) * r2;\n",
            "\t\tauto s = max(0., -a-sqrt(det)), t = min(1., -a+sqrt(det));\n",
            "\t\tif (t < 0 || 1 <= s) return arg(p, q) * r2;\n",
            "\t\tP u = p + d * s, v = p + d * t;\n",
            "\t\treturn arg(p,u) * r2 + u.cross(v)/2 + arg(v,q) * r2;\n",
            "\t};\n",
            "\tauto sum = 0.0;\n",
            "\trep(i,0,sz(ps))\n",
            "\t\tsum += tri(ps[i] - c, ps[(i + 1) % sz(ps)] - c);\n",
            "\treturn sum;\n",
            "}\n"
        ],
        "description": "O(n) | Returns the area of the intersection of a circle with a"
    },
    "sphericalDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_sphericalDistance"
        ],
        "body": [
            "\n",
            "double sphericalDistance(double f1, double t1,\n",
            "\t\tdouble f2, double t2, double radius) {\n",
            "\tdouble dx = sin(t2)*cos(f2) - sin(t1)*cos(f1);\n",
            "\tdouble dy = sin(t2)*sin(f2) - sin(t1)*sin(f1);\n",
            "\tdouble dz = cos(t2) - cos(t1);\n",
            "\tdouble d = sqrt(dx*dx + dy*dy + dz*dz);\n",
            "\treturn radius*2*asin(d/2);\n",
            "}\n"
        ],
        "description": "Returns the shortest distance on the sphere with radius radius between the points with azimuthal angles (longitude) f1 ($\\phi_1$) and f2 ($\\phi_2$) from x axis and zenith angles (latitude) t1 ($\\theta_1$) and t2 ($\\theta_2$) from z axis (0 = north pole). All angles measured in radians. The algorithm starts by converting the spherical coordinates to cartesian coordinates so if that is what you have you can use only the two last rows. dx*radius is then the difference between the two points in the x direction and d*radius is the total distance between the points."
    },
    "Point3D": {
        "scope": "cpp",
        "prefix": [
            "apoc_Point3D"
        ],
        "body": [
            "\n",
            "template<class T> struct Point3D {\n",
            "\ttypedef Point3D P;\n",
            "\ttypedef const P& R;\n",
            "\tT x, y, z;\n",
            "\texplicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}\n",
            "\tbool operator<(R p) const {\n",
            "\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z); }\n",
            "\tbool operator==(R p) const {\n",
            "\t\treturn tie(x, y, z) == tie(p.x, p.y, p.z); }\n",
            "\tP operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }\n",
            "\tP operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }\n",
            "\tP operator*(T d) const { return P(x*d, y*d, z*d); }\n",
            "\tP operator/(T d) const { return P(x/d, y/d, z/d); }\n",
            "\tT dot(R p) const { return x*p.x + y*p.y + z*p.z; }\n",
            "\tP cross(R p) const {\n",
            "\t\treturn P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);\n",
            "\t}\n",
            "\tT dist2() const { return x*x + y*y + z*z; }\n",
            "\tdouble dist() const { return sqrt((double)dist2()); }\n",
            "\t//Azimuthal angle (longitude) to x-axis in interval [-pi, pi]\n",
            "\tdouble phi() const { return atan2(y, x); } \n",
            "\t//Zenith angle (latitude) to the z-axis in interval [0, pi]\n",
            "\tdouble theta() const { return atan2(sqrt(x*x+y*y),z); }\n",
            "\tP unit() const { return *this/(T)dist(); } //makes dist()=1\n",
            "\t//returns unit vector normal to *this and p\n",
            "\tP normal(P p) const { return cross(p).unit(); }\n",
            "\t//returns point rotated 'angle' radians ccw around axis\n",
            "\tP rotate(double angle, P axis) const {\n",
            "\t\tdouble s = sin(angle), c = cos(angle); P u = axis.unit();\n",
            "\t\treturn u*dot(u)*(1-c) + (*this)*c - cross(u)*s;\n",
            "\t}\n",
            "};\n"
        ],
        "description": "Class to handle points in 3D space."
    },
    "halfplaneIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_halfplaneIntersection"
        ],
        "body": [
            "\n",
            "const double eps = 1e-8;\n",
            "typedef Point<double> P;\n",
            "struct HalfPlane {\n",
            "    P s, e, d;\n",
            "    HalfPlane(P s = P(), P e = P()): s(s), e(e), d(e - s) {}\n",
            "    bool contains(P p) { return d.cross(p - s) > -eps; }\n",
            "    bool operator<(HalfPlane hp) {\n",
            "        if(abs(d.x) < eps && abs(hp.d.x) < eps) \n",
            "            return d.y > 0 && hp.d.y < 0;\n",
            "        bool side = d.x < eps || (abs(d.x) <= eps && d.y > 0);\n",
            "        bool sideHp = hp.d.x < eps || (abs(hp.d.x) <= eps && hp.d.y > 0);\n",
            "        if(side != sideHp) return side;\n",
            "        return d.cross(hp.d) > 0;\n",
            "    }\n",
            "    P inter(HalfPlane hp) {\n",
            "        auto p = hp.s.cross(e, hp.e), q = hp.s.cross(hp.e, s);\n",
            "\t    return (s * p + e * q) / d.cross(hp.d);\n",
            "    }\n",
            "};\n",
            "\n",
            "vector<P> hpIntersection(vector<HalfPlane> hps) {\n",
            "    sort(all(hps));\n",
            "    int n = sz(hps), l = 1, r = 0;\n",
            "    vector<HalfPlane> dq(n+1);\n",
            "    rep(i, 0, n) {\n",
            "        while(l < r && !hps[i].contains(dq[r].inter(dq[r-1]))) r--;\n",
            "        while(l < r && !hps[i].contains(dq[l].inter(dq[l+1]))) l++;\n",
            "        dq[++r] = hps[i];\n",
            "        if(l < r && abs(dq[r].d.cross(dq[r-1].d)) < eps) {\n",
            "            if(dq[r].d.dot(dq[r-1].d) < 0) return {};\n",
            "            r--;\n",
            "            if(dq[r].contains(hps[i].s)) dq[r] = hps[i];\n",
            "        }\n",
            "    }\n",
            "    while(l < r - 1 && !dq[l].contains(dq[r].inter(dq[r-1]))) r--;\n",
            "    while(l < r - 1 && !dq[r].contains(dq[l].inter(dq[l+1]))) l++;\n",
            "    if(l > r - 2) return {};\n",
            "    vector<P> poly;\n",
            "    rep(i, l, r)\n",
            "        poly.push_back(dq[i].inter(dq[i+1]));\n",
            "    poly.push_back(dq[r].inter(dq[l]));\n",
            "    return poly;\n",
            "}\n"
        ],
        "description": "O(n \\log n) | Returns the intersection of halfplanes as a polygon"
    },
    "SegmentIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentIntersection"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            "If a unique intersection point between the line segments going from s1 to e1 and from s2 to e2 exists then it is returned.\n",
            "If no intersection point exists an empty vector is returned. If infinitely many exist a vector with 2 elements is returned, containing the endpoints of the common line segment.\n",
            "The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.\n",
            "Products of three coordinates are used in intermediate steps so watch out for overflow if using int or long long.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/SegmentIntersection}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "template<class P> vector<P> segInter(P a, P b, P c, P d) {\n",
            "\tauto oa = c.cross(d, a), ob = c.cross(d, b),\n",
            "\t     oc = a.cross(b, c), od = a.cross(b, d);\n",
            "\t// Checks if intersection is single non-endpoint point.\n",
            "\tif (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)\n",
            "\t\treturn {(a * ob - b * oa) / (ob - oa)};\n",
            "\tset<P> s;\n",
            "\tif (onSegment(c, d, a)) s.insert(a);\n",
            "\tif (onSegment(c, d, b)) s.insert(b);\n",
            "\tif (onSegment(a, b, c)) s.insert(c);\n",
            "\tif (onSegment(a, b, d)) s.insert(d);\n",
            "\treturn {all(s)};\n",
            "}\n"
        ],
        "description": "Description:\\\\ Usage: vector<P> inter = segInter(s1,e1,s2,e2); if (sz(inter)==1)   cout << \"segments intersect at \" << inter[0] << endl;"
    },
    "DelaunayTriangulation": {
        "scope": "cpp",
        "prefix": [
            "apoc_DelaunayTriangulation"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P, class F>\n",
            "void delaunay(vector<P>& ps, F trifun) {\n",
            "\tif (sz(ps) == 3) { int d = (ps[0].cross(ps[1], ps[2]) < 0);\n",
            "\t\ttrifun(0,1+d,2-d); }\n",
            "\tvector<P3> p3;\n",
            "\tfor (P p : ps) p3.emplace_back(p.x, p.y, p.dist2());\n",
            "\tif (sz(ps) > 3) for(auto t:hull3d(p3)) if ((p3[t.b]-p3[t.a]).\n",
            "\t\t\tcross(p3[t.c]-p3[t.a]).dot(P3(0,0,1)) < 0)\n",
            "\t\ttrifun(t.a, t.c, t.b);\n",
            "}\n"
        ],
        "description": "O(n^2) | Computes the Delaunay triangulation of a set of points."
    },
    "ManhattanMST": {
        "scope": "cpp",
        "prefix": [
            "apoc_ManhattanMST"
        ],
        "body": [
            "\n",
            "typedef Point<int> P;\n",
            "vector<array<int, 3>> manhattanMST(vector<P> ps) {\n",
            "\tvi id(sz(ps));\n",
            "\tiota(all(id), 0);\n",
            "\tvector<array<int, 3>> edges;\n",
            "\trep(k,0,4) {\n",
            "\t\tsort(all(id), [&](int i, int j) {\n",
            "\t\t     return (ps[i]-ps[j]).x < (ps[j]-ps[i]).y;});\n",
            "\t\tmap<int, int> sweep;\n",
            "\t\tfor (int i : id) {\n",
            "\t\t\tfor (auto it = sweep.lower_bound(-ps[i].y);\n",
            "\t\t\t\t        it != sweep.end(); sweep.erase(it++)) {\n",
            "\t\t\t\tint j = it->second;\n",
            "\t\t\t\tP d = ps[i] - ps[j];\n",
            "\t\t\t\tif (d.y > d.x) break;\n",
            "\t\t\t\tedges.push_back({d.y + d.x, i, j});\n",
            "\t\t\t}\n",
            "\t\t\tsweep[-ps[i].y] = i;\n",
            "\t\t}\n",
            "\t\tfor (P& p : ps) if (k & 1) p.x = -p.x; else swap(p.x, p.y);\n",
            "\t}\n",
            "\treturn edges;\n",
            "}\n"
        ],
        "description": "O(N \\log N) | Given N points, returns up to 4*N edges, which are guaranteed"
    },
    "hullTangents": {
        "scope": "cpp",
        "prefix": [
            "apoc_hullTangents"
        ],
        "body": [
            "#define cmp(i, j) p.cross(h[i], h[j == n ? 0 : j]) * (R ?: -1)\n",
            "template<bool R, class P> int getTangent(vector<P>& h, P p) {\n",
            "\tint n = sz(h), lo = 0, hi = n - 1, md;\n",
            "\tif (cmp(0, 1) >= R && cmp(0, n - 1) >= !R) return 0;\n",
            "\twhile (md = (lo + hi + 1) / 2, lo < hi) {\n",
            "\t\tauto a = cmp(md, md + 1), b = cmp(md, lo);\n",
            "\t\tif (a >= R && cmp(md, md - 1) >= !R) return md;\n",
            "\t\tif (cmp(lo, lo + 1) < R)\n",
            "\t\t\ta < R&& b >= 0 ? lo = md : hi = md - 1;\n",
            "\t\telse a < R || b <= 0 ? lo = md : hi = md - 1;\n",
            "\t}\n",
            "\treturn -1; // point strictly inside hull\n",
            "}\n",
            "template<class P> pii hullTangents(vector<P>& h, P p) {\n",
            "\treturn {getTangent<0>(h, p), getTangent<1>(h, p)};\n",
            "}"
        ],
        "description": "O(\\log n) | Finds the left and right, respectively, tangent "
    },
    "circumcircle": {
        "scope": "cpp",
        "prefix": [
            "apoc_circumcircle"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            "The circumcirle of a triangle is the circle intersecting all three vertices. ccRadius returns the radius of the circle going through points A, B and C and ccCenter returns the center of the same circle.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\vspace{-2mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/circumcircle}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "double ccRadius(const P& A, const P& B, const P& C) {\n",
            "\treturn (B-A).dist()*(C-B).dist()*(A-C).dist()/\n",
            "\t\t\tabs((B-A).cross(C-A))/2;\n",
            "}\n",
            "P ccCenter(const P& A, const P& B, const P& C) {\n",
            "\tP b = C-A, c = B-A;\n",
            "\treturn A + (b*c.dist2()-c*b.dist2()).perp()/b.cross(c)/2;\n",
            "}\n"
        ],
        "description": "Description:\\\\"
    },
    "InsidePolygon": {
        "scope": "cpp",
        "prefix": [
            "apoc_InsidePolygon"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P>\n",
            "bool inPolygon(vector<P> &p, P a, bool strict = true) {\n",
            "\tint cnt = 0, n = sz(p);\n",
            "\trep(i,0,n) {\n",
            "\t\tP q = p[(i + 1) % n];\n",
            "\t\tif (onSegment(p[i], q, a)) return !strict;\n",
            "\t\t//or: if (segDist(p[i], q, a) <= eps) return !strict;\n",
            "\t\tcnt ^= ((a.y<p[i].y) - (a.y<q.y)) * a.cross(p[i], q) > 0;\n",
            "\t}\n",
            "\treturn cnt;\n",
            "}\n"
        ],
        "description": "O(n) | Returns true if p lies within the polygon. If strict is true,"
    },
    "PolygonUnion": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonUnion"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "double rat(P a, P b) { return sgn(b.x) ? a.x/b.x : a.y/b.y; }\n",
            "double polyUnion(vector<vector<P>>& poly) {\n",
            "\tdouble ret = 0;\n",
            "\trep(i,0,sz(poly)) rep(v,0,sz(poly[i])) {\n",
            "\t\tP A = poly[i][v], B = poly[i][(v + 1) % sz(poly[i])];\n",
            "\t\tvector<pair<double, int>> segs = {{0, 0}, {1, 0}};\n",
            "\t\trep(j,0,sz(poly)) if (i != j) {\n",
            "\t\t\trep(u,0,sz(poly[j])) {\n",
            "\t\t\t\tP C = poly[j][u], D = poly[j][(u + 1) % sz(poly[j])];\n",
            "\t\t\t\tint sc = sideOf(A, B, C), sd = sideOf(A, B, D);\n",
            "\t\t\t\tif (sc != sd) {\n",
            "\t\t\t\t\tdouble sa = C.cross(D, A), sb = C.cross(D, B);\n",
            "\t\t\t\t\tif (min(sc, sd) < 0)\n",
            "\t\t\t\t\t\tsegs.emplace_back(sa / (sa - sb), sgn(sc - sd));\n",
            "\t\t\t\t} else if (!sc && !sd && j<i && sgn((B-A).dot(D-C))>0){\n",
            "\t\t\t\t\tsegs.emplace_back(rat(C - A, B - A), 1);\n",
            "\t\t\t\t\tsegs.emplace_back(rat(D - A, B - A), -1);\n",
            "\t\t\t\t}\n",
            "\t\t\t}\n",
            "\t\t}\n",
            "\t\tsort(all(segs));\n",
            "\t\tfor (auto& s : segs) s.first = min(max(s.first, 0.0), 1.0);\n",
            "\t\tdouble sum = 0;\n",
            "\t\tint cnt = segs[0].second;\n",
            "\t\trep(j,1,sz(segs)) {\n",
            "\t\t\tif (!cnt) sum += segs[j].first - segs[j - 1].first;\n",
            "\t\t\tcnt += segs[j].second;\n",
            "\t\t}\n",
            "\t\tret += A.cross(B) * sum;\n",
            "\t}\n",
            "\treturn ret / 2;\n",
            "}\n"
        ],
        "description": "$O(N^2)$, where $N$ is the total number of points | Calculates the area of the union of $n$ polygons (not necessarily"
    },
    "convexHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_convexHull"
        ],
        "body": [
            "\n",
            "template<class P> vector<P> convexHull(vector<P> poly){\n",
            "    int n = sz(poly);\n",
            "    vector<P> hull(n+1);\n",
            "    sort(all(poly));\n",
            "    int k = 0;\n",
            "    for(int i = 0; i < n; i++){\n",
            "        while(k >= 2 && hull[k-2].cross(hull[k-1], poly[i]) <= 0) k--;\n",
            "        hull[k++] = poly[i];\n",
            "    }\n",
            "    for(int i = n-1, t = k+1; i > 0; i--){\n",
            "        while(k >= t && hull[k-2].cross(hull[k-1], poly[i-1]) <= 0) k--;\n",
            "        hull[k++] = poly[i-1];\n",
            "    }\n",
            "    hull.resize(k-1);\n",
            "    return hull;\n",
            "}\n"
        ],
        "description": "$O(n\\log{n})$ | gets the smallest convex polygon containing all points using monotone chaining."
    },
    "HullDiameter": {
        "scope": "cpp",
        "prefix": [
            "apoc_HullDiameter"
        ],
        "body": [
            "\n",
            "typedef Point<ll> P;\n",
            "array<P, 2> hullDiameter(vector<P> S) {\n",
            "\tint n = sz(S), j = n < 2 ? 0 : 1;\n",
            "\tpair<ll, array<P, 2>> res({0, {S[0], S[0]}});\n",
            "\trep(i,0,j)\n",
            "\t\tfor (;; j = (j + 1) % n) {\n",
            "\t\t\tres = max(res, {(S[i] - S[j]).dist2(), {S[i], S[j]}});\n",
            "\t\t\tif ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)\n",
            "\t\t\t\tbreak;\n",
            "\t\t}\n",
            "\treturn res.second;\n",
            "}\n"
        ],
        "description": "O(n) / | Returns the two points with max distance on a convex hull (ccw,"
    },
    "CircleLine": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleLine"
        ],
        "body": [
            "\n",
            "\n",
            "\n",
            "template<class P>\n",
            "vector<P> circleLine(P c, double r, P a, P b) {\n",
            "\tP ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();\n",
            "\tdouble s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();\n",
            "\tif (h2 < 0) return {};\n",
            "\tif (h2 == 0) return {p};\n",
            "\tP h = ab.unit() * sqrt(h2);\n",
            "\treturn {p - h, p + h};\n",
            "}\n"
        ],
        "description": "Finds the intersection between a circle and a line."
    },
    "linearTransformation": {
        "scope": "cpp",
        "prefix": [
            "apoc_linearTransformation"
        ],
        "body": [
            "\\begin{minipage}{75mm}\n",
            " Apply the linear transformation (translation, rotation and scaling) which takes line p0-p1 to line q0-q1 to point r.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\vspace{-8mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/linearTransformation}\n",
            "\\vspace{-2mm}\n",
            "\\end{minipage}\n",
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "P linearTransformation(const P& p0, const P& p1,\n",
            "\t\tconst P& q0, const P& q1, const P& r) {\n",
            "\tP dp = p1-p0, dq = q1-q0, num(dp.cross(dq), dp.dot(dq));\n",
            "\treturn q0 + P((r-p0).cross(num), (r-p0).dot(num))/dp.dist2();\n",
            "}\n"
        ],
        "description": "Source: Description:\\\\"
    },
    "polygonArea": {
        "scope": "cpp",
        "prefix": [
            "apoc_polygonArea"
        ],
        "body": [
            "\n",
            "\n",
            "template<class T> ld polyArea(vector<pnt<T>> poly) {\n",
            "    int n = sz(poly); T area = 0;\n",
            "    for(int i = 0; i < n; i++)\n",
            "        area += poly[i].cross(poly[(i+1)%n]);\n",
            "    return area / 2.0L;\n",
            "}"
        ],
        "description": "$O(n)$ | Uses shoelace theorem to find the area of a polygon. "
    },
    "Angle": {
        "scope": "cpp",
        "prefix": [
            "apoc_Angle"
        ],
        "body": [
            "\n",
            "struct Angle {\n",
            "\tint x, y;\n",
            "\tint t;\n",
            "\tAngle(int x, int y, int t=0) : x(x), y(y), t(t) {}\n",
            "\tAngle operator-(Angle b) const { return {x-b.x, y-b.y, t}; }\n",
            "\tint half() const {\n",
            "\t\tassert(x || y);\n",
            "\t\treturn y < 0 || (y == 0 && x < 0);\n",
            "\t}\n",
            "\tAngle t90() const { return {-y, x, t + (half() && x >= 0)}; }\n",
            "\tAngle t180() const { return {-x, -y, t + half()}; }\n",
            "\tAngle t360() const { return {x, y, t + 1}; }\n",
            "};\n",
            "bool operator<(Angle a, Angle b) {\n",
            "\t// add a.dist2() and b.dist2() to also compare distances\n",
            "\treturn make_tuple(a.t, a.half(), a.y * (ll)b.x) <\n",
            "\t       make_tuple(b.t, b.half(), a.x * (ll)b.y);\n",
            "}\n",
            "\n",
            "// Given two points, this calculates the smallest angle between\n",
            "// them, i.e., the angle that covers the defined line segment.\n",
            "pair<Angle, Angle> segmentAngles(Angle a, Angle b) {\n",
            "\tif (b < a) swap(a, b);\n",
            "\treturn (b < a.t180() ?\n",
            "\t        make_pair(a, b) : make_pair(b, a.t360()));\n",
            "}\n",
            "Angle operator+(Angle a, Angle b) { // point a + vector b\n",
            "\tAngle r(a.x + b.x, a.y + b.y, a.t);\n",
            "\tif (a.t180() < r) r.t--;\n",
            "\treturn r.t180() < a ? r.t360() : r;\n",
            "}\n",
            "Angle angleDiff(Angle a, Angle b) { // angle b - angle a\n",
            "\tint tu = b.t - a.t; a.t = b.t;\n",
            "\treturn {a.x*b.x + a.y*b.y, a.x*b.y - a.y*b.x, tu - (b < a)};\n",
            "}\n"
        ],
        "description": "A class for ordering angles (as represented by int points and"
    },
    "LineProjectionReflection": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineProjectionReflection"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P>\n",
            "P lineProj(P a, P b, P p, bool refl=false) {\n",
            "\tP v = b - a;\n",
            "\treturn p - v.perp()*(1+refl)*v.cross(p-a)/v.dist2();\n",
            "}\n"
        ],
        "description": "Projects point p onto line ab. Set refl=true to get reflection"
    },
    "doSegIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_doSegIntersection"
        ],
        "body": [
            "\n",
            "template<class P> bool doSegInter(P s1, P e1, P s2, P e2) {\n",
            "    return sideOf(s1, e1, s2) != sideOf(s1, e1, e2) && \n",
            "           sideOf(s2, e2, s1) != sideOf(s2, e2, e1);\n",
            "}"
        ],
        "description": "Checks if two segments intersect (inclusive of intersections at endpoints)"
    },
    "CircleTangents": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleTangents"
        ],
        "body": [
            "\n",
            "\n",
            "template<class P>\n",
            "vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {\n",
            "\tP d = c2 - c1;\n",
            "\tdouble dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;\n",
            "\tif (d2 == 0 || h2 < 0)  return {};\n",
            "\tvector<pair<P, P>> out;\n",
            "\tfor (double sign : {-1, 1}) {\n",
            "\t\tP v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;\n",
            "\t\tout.push_back({c1 + v * r1, c2 + v * r2});\n",
            "\t}\n",
            "\tif (h2 == 0) out.pop_back();\n",
            "\treturn out;\n",
            "}\n"
        ],
        "description": "Finds the external tangents of two circles, or internal if r2 is negated."
    },
    "FastDelaunay": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastDelaunay"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<ll> P;\n",
            "typedef struct Quad* Q;\n",
            "typedef __int128_t lll; // (can be ll if coords are < 2e4)\n",
            "P arb(LLONG_MAX,LLONG_MAX); // not equal to any other point\n",
            "\n",
            "struct Quad {\n",
            "\tQ rot, o; P p = arb; bool mark;\n",
            "\tP& F() { return r()->p; }\n",
            "\tQ& r() { return rot->rot; }\n",
            "\tQ prev() { return rot->o->rot; }\n",
            "\tQ next() { return r()->prev(); }\n",
            "} *H;\n",
            "\n",
            "bool circ(P p, P a, P b, P c) { // is p in the circumcircle?\n",
            "\tlll p2 = p.dist2(), A = a.dist2()-p2,\n",
            "\t    B = b.dist2()-p2, C = c.dist2()-p2;\n",
            "\treturn p.cross(a,b)*C + p.cross(b,c)*A + p.cross(c,a)*B > 0;\n",
            "}\n",
            "Q makeEdge(P orig, P dest) {\n",
            "\tQ r = H ? H : new Quad{new Quad{new Quad{new Quad{0}}}};\n",
            "\tH = r->o; r->r()->r() = r;\n",
            "\trep(i,0,4) r = r->rot, r->p = arb, r->o = i & 1 ? r : r->r();\n",
            "\tr->p = orig; r->F() = dest;\n",
            "\treturn r;\n",
            "}\n",
            "void splice(Q a, Q b) {\n",
            "\tswap(a->o->rot->o, b->o->rot->o); swap(a->o, b->o);\n",
            "}\n",
            "Q connect(Q a, Q b) {\n",
            "\tQ q = makeEdge(a->F(), b->p);\n",
            "\tsplice(q, a->next());\n",
            "\tsplice(q->r(), b);\n",
            "\treturn q;\n",
            "}\n",
            "\n",
            "pair<Q,Q> rec(const vector<P>& s) {\n",
            "\tif (sz(s) <= 3) {\n",
            "\t\tQ a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.back());\n",
            "\t\tif (sz(s) == 2) return { a, a->r() };\n",
            "\t\tsplice(a->r(), b);\n",
            "\t\tauto side = s[0].cross(s[1], s[2]);\n",
            "\t\tQ c = side ? connect(b, a) : 0;\n",
            "\t\treturn {side < 0 ? c->r() : a, side < 0 ? c : b->r() };\n",
            "\t}\n",
            "\n",
            "#define H(e) e->F(), e->p\n",
            "#define valid(e) (e->F().cross(H(base)) > 0)\n",
            "\tQ A, B, ra, rb;\n",
            "\tint half = sz(s) / 2;\n",
            "\ttie(ra, A) = rec({all(s) - half});\n",
            "\ttie(B, rb) = rec({sz(s) - half + all(s)});\n",
            "\twhile ((B->p.cross(H(A)) < 0 && (A = A->next())) ||\n",
            "\t       (A->p.cross(H(B)) > 0 && (B = B->r()->o)));\n",
            "\tQ base = connect(B->r(), A);\n",
            "\tif (A->p == ra->p) ra = base->r();\n",
            "\tif (B->p == rb->p) rb = base;\n",
            "\n",
            "#define DEL(e, init, dir) Q e = init->dir; if (valid(e)) \\\n",
            "\t\twhile (circ(e->dir->F(), H(base), e->F())) { \\\n",
            "\t\t\tQ t = e->dir; \\\n",
            "\t\t\tsplice(e, e->prev()); \\\n",
            "\t\t\tsplice(e->r(), e->r()->prev()); \\\n",
            "\t\t\te->o = H; H = e; e = t; \\\n",
            "\t\t}\n",
            "\tfor (;;) {\n",
            "\t\tDEL(LC, base->r(), o);  DEL(RC, base, prev());\n",
            "\t\tif (!valid(LC) && !valid(RC)) break;\n",
            "\t\tif (!valid(LC) || (valid(RC) && circ(H(RC), H(LC))))\n",
            "\t\t\tbase = connect(RC, base->r());\n",
            "\t\telse\n",
            "\t\t\tbase = connect(base->r(), LC->r());\n",
            "\t}\n",
            "\treturn { ra, rb };\n",
            "}\n",
            "\n",
            "vector<P> triangulate(vector<P> pts) {\n",
            "\tsort(all(pts));  assert(unique(all(pts)) == pts.end());\n",
            "\tif (sz(pts) < 2) return {};\n",
            "\tQ e = rec(pts).first;\n",
            "\tvector<Q> q = {e};\n",
            "\tint qi = 0;\n",
            "\twhile (e->o->F().cross(e->F(), e->p) < 0) e = e->o;\n",
            "#define ADD { Q c = e; do { c->mark = 1; pts.push_back(c->p); \\\n",
            "\tq.push_back(c->r()); c = c->next(); } while (c != e); }\n",
            "\tADD; pts.clear();\n",
            "\twhile (qi < sz(q)) if (!(e = q[qi++])->mark) ADD;\n",
            "\treturn pts;\n",
            "}\n"
        ],
        "description": "O(n \\log n) | Fast Delaunay triangulation."
    },
    "inHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_inHull"
        ],
        "body": [
            "\n",
            "template<class P> bool inHull(const vector<P>& l, P p, bool strict = true) {\n",
            "\tint a = 1, b = sz(l) - 1, r = !strict;\n",
            "\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);\n",
            "\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);\n",
            "\tif (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)\n",
            "\t\treturn false;\n",
            "\twhile (abs(a - b) > 1) {\n",
            "\t\tint c = (a + b) / 2;\n",
            "\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;\n",
            "\t}\n",
            "\treturn sgn(l[a].cross(l[b], p)) < r;\n",
            "}"
        ],
        "description": "O(\\log N) / | Determine whether a point t lies inside a convex hull (CCW"
    },
    "inPolygon": {
        "scope": "cpp",
        "prefix": [
            "apoc_inPolygon"
        ],
        "body": [
            "\n",
            "template<class P> int inPoly(vector<P> poly, P p) {\n",
            "    bool good = false; int n = sz(poly);\n",
            "    auto crosses = [](P s, P e, P p) { \n",
            "        return ((e.y >= p.y) - (s.y >= p.y)) * p.cross(s, e) > 0; \n",
            "    };\n",
            "    for(int i = 0; i < n; i++){\n",
            "        if(onSeg(poly[i], poly[(i+1)%n], p)) return 2;\n",
            "        good ^= crosses(poly[i], poly[(i+1)%n], p);\n",
            "    }\n",
            "    return good;\n",
            "}"
        ],
        "description": "$O(n)$ | Uses the cutting-ray test to see if a point is inside a polygon."
    },
    "onSeg": {
        "scope": "cpp",
        "prefix": [
            "apoc_onSeg"
        ],
        "body": [
            "\n",
            "template<class P> bool onSeg(P s, P e, P p) {\n",
            "    return abs(s.cross(e, p)) < eps && (s-p).dot(e-p) < eps;\n",
            "}"
        ],
        "description": "Returns whether or not a point is on a segment"
    },
    "PolygonCenter": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonCenter"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<double> P;\n",
            "P polygonCenter(const vector<P>& v) {\n",
            "\tP res(0, 0); double A = 0;\n",
            "\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {\n",
            "\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);\n",
            "\t\tA += v[j].cross(v[i]);\n",
            "\t}\n",
            "\treturn res / A / 3;\n",
            "}\n"
        ],
        "description": "O(n) | Returns the center of mass for a polygon."
    },
    "PolygonArea": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonArea"
        ],
        "body": [
            "\n",
            "\n",
            "template<class T>\n",
            "T polygonArea2(vector<Point<T>>& v) {\n",
            "\tT a = v.back().cross(v[0]);\n",
            "\trep(i,0,sz(v)-1) a += v[i].cross(v[i+1]);\n",
            "\treturn a;\n",
            "}\n"
        ],
        "description": "Returns twice the signed area of a polygon."
    },
    "ConvexHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_ConvexHull"
        ],
        "body": [
            "\\\\\\begin{minipage}{75mm}\n",
            "Returns a vector of the points of the convex hull in counter-clockwise order.\n",
            "Points on the edge of the hull between two other points are not considered part of the hull.\n",
            "\\end{minipage}\n",
            "\\begin{minipage}{15mm}\n",
            "\\vspace{-6mm}\n",
            "\\includegraphics[width=\\textwidth]{content/geometry/ConvexHull}\n",
            "\\vspace{-6mm}\n",
            "\\end{minipage}\n",
            "*/\n",
            "\n",
            "\n",
            "typedef Point<ll> P;\n",
            "vector<P> convexHull(vector<P> pts) {\n",
            "\tif (sz(pts) <= 1) return pts;\n",
            "\tsort(all(pts));\n",
            "\tvector<P> h(sz(pts)+1);\n",
            "\tint s = 0, t = 0;\n",
            "\tfor (int it = 2; it--; s = --t, reverse(all(pts)))\n",
            "\t\tfor (P p : pts) {\n",
            "\t\t\twhile (t >= s + 2 && h[t-2].cross(h[t-1], p) <= 0) t--;\n",
            "\t\t\th[t++] = p;\n",
            "\t\t}\n",
            "\treturn {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};\n",
            "}\n"
        ],
        "description": "O(n \\log n) | Description:"
    },
    "PointInsideHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_PointInsideHull"
        ],
        "body": [
            "\n",
            "\n",
            "typedef Point<ll> P;\n",
            "\n",
            "bool inHull(const vector<P>& l, P p, bool strict = true) {\n",
            "\tint a = 1, b = sz(l) - 1, r = !strict;\n",
            "\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);\n",
            "\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);\n",
            "\tif (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)\n",
            "\t\treturn false;\n",
            "\twhile (abs(a - b) > 1) {\n",
            "\t\tint c = (a + b) / 2;\n",
            "\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;\n",
            "\t}\n",
            "\treturn sgn(l[a].cross(l[b], p)) < r;\n",
            "}\n"
        ],
        "description": "O(\\log N) / | Determine whether a point t lies inside a convex hull (CCW"
    },
    "multinomial": {
        "scope": "cpp",
        "prefix": [
            "apoc_multinomial"
        ],
        "body": [
            "\n",
            "ll multinomial(vi& v) {\n",
            "\tll c = 1, m = v.empty() ? 1 : v[0];\n",
            "\trep(i,1,sz(v)) rep(j,0,v[i])\n",
            "\t\tc = c * ++m / (j+1);\n",
            "\treturn c;\n",
            "}\n"
        ],
        "description": "Computes $\\displaystyle \\binom{k_1 + \\dots + k_n}{k_1, k_2, \\dots, k_n} = \\frac{(\\sum k_i)!}{k_1!k_2!...k_n!}$."
    },
    "IntPerm": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntPerm"
        ],
        "body": [
            "\n",
            "int permToInt(vi& v) {\n",
            "\tint use = 0, i = 0, r = 0;\n",
            "\tfor(int x:v) r = r * ++i + __builtin_popcount(use & -(1<<x)),\n",
            "\t\tuse |= 1 << x;                     // (note: minus, not ~!)\n",
            "\treturn r;\n",
            "}\n"
        ],
        "description": "O(n) / | Permutation -> integer conversion. (Not order preserving.)"
    }
}