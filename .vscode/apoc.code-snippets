{
    "MinRotation": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinRotation"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " *  rotate(v.begin(), v.begin()+minRotation(v), v.end());",
            " */",
            "int minRotation(string s) {",
            "\tint a=0, N=sz(s); s += s;",
            "\trep(b,0,N) rep(k,0,N) {",
            "\t\tif (a+k == b || s[a+k] < s[b+k]) {b += max(0, k-1); break;}",
            "\t\tif (s[a+k] > s[b+k]) { a = b; break; }",
            "\t}",
            "\treturn a;",
            "}"
        ],
        "description": "O(N) | Finds the lexicographically smallest rotation of a string."
    },
    "SuffixAutomaton": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixAutomaton"
        ],
        "body": [
            "struct st { int len, pos, term; st *link; map<char, st*> next; };",
            "st *suffixAutomaton(string &str) {",
            "\tst *last = new st(), *root = last;",
            "\tfor(auto c : str) {",
            "\t\tst *p = last, *cur = last = new st{last->len + 1, last->len};",
            "\t\twhile(p && !p->next.count(c))",
            "\t\t\tp->next[c] = cur, p = p->link;",
            "\t\tif (!p) cur->link = root;",
            "\t\telse {",
            "\t\t\tst *q = p->next[c];",
            "\t\t\tif (p->len + 1 == q->len) cur->link = q;",
            "\t\t\telse {",
            "\t\t\t\tst *clone = new st{p->len+1, q->pos, 0, q->link, q->next};",
            "\t\t\t\tfor (; p && p->next[c] == q; p = p->link)",
            "\t\t\t\t\tp->next[c] = clone;",
            "\t\t\t\tq->link = cur->link = clone;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\twhile(last) last->term = 1, last = last->link;",
            "\treturn root;",
            "}"
        ],
        "description": "construction takes O(N\\log K), where K = Alphabet Size. | Creates a partial DFA (DAG) that accepts all suffixes, with suffix links. One-to-one map between a path from the root and a substring. len is the longest-length substring ending here. pos is the first index in the string matching here. term is whether this node is a terminal (aka a suffix)"
    },
    "AhoCorasick": {
        "scope": "cpp",
        "prefix": [
            "apoc_AhoCorasick"
        ],
        "body": [
            "struct AhoCorasick {",
            "\tenum {alpha = 26, first = 'A'}; // change this!",
            "\tstruct Node {",
            "\t\t// (nmatches is optional)",
            "\t\tint back, next[alpha], start = -1, end = -1, nmatches = 0;",
            "\t\tNode(int v) { memset(next, v, sizeof(next)); }",
            "\t};",
            "\tvector<Node> N;",
            "\tvi backp;",
            "\tvoid insert(string& s, int j) {",
            "\t\tassert(!s.empty());",
            "\t\tint n = 0;",
            "\t\tfor (char c : s) {",
            "\t\t\tint& m = N[n].next[c - first];",
            "\t\t\tif (m == -1) { n = m = sz(N); N.emplace_back(-1); }",
            "\t\t\telse n = m;",
            "\t\t}",
            "\t\tif (N[n].end == -1) N[n].start = j;",
            "\t\tbackp.push_back(N[n].end);",
            "\t\tN[n].end = j;",
            "\t\tN[n].nmatches++;",
            "\t}",
            "\tAhoCorasick(vector<string>& pat) : N(1, -1) {",
            "\t\trep(i,0,sz(pat)) insert(pat[i], i);",
            "\t\tN[0].back = sz(N);",
            "\t\tN.emplace_back(0);",
            "",
            "\t\tqueue<int> q;",
            "\t\tfor (q.push(0); !q.empty(); q.pop()) {",
            "\t\t\tint n = q.front(), prev = N[n].back;",
            "\t\t\trep(i,0,alpha) {",
            "\t\t\t\tint &ed = N[n].next[i], y = N[prev].next[i];",
            "\t\t\t\tif (ed == -1) ed = y;",
            "\t\t\t\telse {",
            "\t\t\t\t\tN[ed].back = y;",
            "\t\t\t\t\t(N[ed].end == -1 ? N[ed].end : backp[N[ed].start])",
            "\t\t\t\t\t\t= N[y].end;",
            "\t\t\t\t\tN[ed].nmatches += N[y].nmatches;",
            "\t\t\t\t\tq.push(ed);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvi find(string word) {",
            "\t\tint n = 0;",
            "\t\tvi res; // ll count = 0;",
            "\t\tfor (char c : word) {",
            "\t\t\tn = N[n].next[c - first];",
            "\t\t\tres.push_back(N[n].end);",
            "\t\t\t// count += N[n].nmatches;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tvector<vi> findAll(vector<string>& pat, string word) {",
            "\t\tvi r = find(word);",
            "\t\tvector<vi> res(sz(word));",
            "\t\trep(i,0,sz(word)) {",
            "\t\t\tint ind = r[i];",
            "\t\t\twhile (ind != -1) {",
            "\t\t\t\tres[i - sz(pat[ind]) + 1].push_back(ind);",
            "\t\t\t\tind = backp[ind];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "construction takes O(26N), where N = sum of length of patterns. find(x) is O(N), where N = length of x. findAll is O(NM). | Aho-Corasick automaton, used for multiple pattern matching. Initialize with AhoCorasick ac(patterns); the automaton start node will be at index 0. find(word) returns for each position the index of the longest word that ends there, or -1 if none. findAll(-, word) finds all words (up to N sqrt N many if no duplicate patterns) that start at each position (shortest first). Duplicate patterns are allowed; empty patterns are not. To find the longest words that start at each position, reverse all input. For large alphabets, split each symbol into chunks, with sentinel bits for symbol boundaries."
    },
    "Manacher": {
        "scope": "cpp",
        "prefix": [
            "apoc_Manacher"
        ],
        "body": [
            "array<vi, 2> manacher(const string& s) {",
            "\tint n = sz(s);",
            "\tarray<vi,2> p = {vi(n+1), vi(n)};",
            "\trep(z,0,2) for (int i=0,l=0,r=0; i < n; i++) {",
            "\t\tint t = r-i+!z;",
            "\t\tif (i<r) p[z][i] = min(t, p[z][l+t]);",
            "\t\tint L = i-p[z][i], R = i+p[z][i]-!z;",
            "\t\twhile (L>=1 && R+1<n && s[L-1] == s[R+1])",
            "\t\t\tp[z][i]++, L--, R++;",
            "\t\tif (R>r) l=L, r=R;",
            "\t}",
            "\treturn p;",
            "}"
        ],
        "description": "O(N) | For each position in a string, computes p[0][i] = half length of longest even palindrome around pos i, p[1][i] = longest odd (half rounded down)."
    },
    "Zfunc": {
        "scope": "cpp",
        "prefix": [
            "apoc_Zfunc"
        ],
        "body": [
            "vi Z(string S) {",
            "\tvi z(sz(S));",
            "\tint l = -1, r = -1;",
            "\trep(i,1,sz(S)) {",
            "\t\tz[i] = i >= r ? 0 : min(r - i, z[i - l]);",
            "\t\twhile (i + z[i] < sz(S) && S[i + z[i]] == S[z[i]])",
            "\t\t\tz[i]++;",
            "\t\tif (i + z[i] > r)",
            "\t\t\tl = i, r = i + z[i];",
            "\t}",
            "\treturn z;",
            "}"
        ],
        "description": "O(n) | "
    },
    "KMP": {
        "scope": "cpp",
        "prefix": [
            "apoc_KMP"
        ],
        "body": [
            "vi pi(const string& s) {",
            "\tvi p(sz(s));",
            "\trep(i,1,sz(s)) {",
            "\t\tint g = p[i-1];",
            "\t\twhile (g && s[i] != s[g]) g = p[g-1];",
            "\t\tp[i] = g + (s[i] == s[g]);",
            "\t}",
            "\treturn p;",
            "}",
            "",
            "vi match(const string& s, const string& pat) {",
            "\tvi p = pi(pat + '\\0' + s), res;",
            "\trep(i,sz(p)-sz(s),sz(p))",
            "\t\tif (p[i] == sz(pat)) res.push_back(i - 2 * sz(pat));",
            "\treturn res;",
            "}"
        ],
        "description": "O(n) | pi[x] computes the length of the longest prefix of s that ends at x, other than s[0...x] itself (abacaba -> 0010123). Can be used to find all occurrences of a string."
    },
    "Eertree": {
        "scope": "cpp",
        "prefix": [
            "apoc_Eertree"
        ],
        "body": [
            "struct Eertree {",
            "\tvector<int> slink = {0, 0}, len = {-1, 0};",
            "\tvector<vector<int>> down;",
            "\tint cur = 0, t = 0;",
            "\tEertree(string &str) : down(2, vector<int>(26, -1)) {",
            "\t\tfor (int i = 0; i < str.size(); i++) {",
            "\t\t\tchar c = str[i]; int ci = c - 'a';",
            "\t\t\twhile (t <= 0 || str[t-1] != c)",
            "\t\t\tt = i - len[cur = slink[cur]];",
            "\t\t\tif (down[cur][ci] == -1) {",
            "\t\t\tdown[cur][ci] = slink.size();",
            "\t\t\tdown.emplace_back(26, -1);",
            "\t\t\tlen.push_back(len[cur] + 2);",
            "\t\t\tif (len.back() > 1) {",
            "\t\t\t\tdo t = i - len[cur = slink[cur]];",
            "\t\t\t\twhile(t <= 0 || str[t-1] != c);",
            "\t\t\t\tslink.push_back(down[cur][ci]);",
            "\t\t\t} else slink.push_back(1);",
            "\t\t\tcur = slink.size() - 1;",
            "\t\t\t} else cur = down[cur][ci];",
            "\t\t\tt = i - len[cur] + 1;",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "O(|S|) | Generates an eertree on str. cur is accurate at the end of the main loop before the final assignment to t."
    },
    "SuffixArray": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixArray"
        ],
        "body": [
            "struct SuffixArray {",
            "\tvi sa, lcp;",
            "\tSuffixArray(string& s, int lim=256) { // or basic_string<int>",
            "\t\tint n = sz(s) + 1, k = 0, a, b;",
            "\t\tvi x(all(s)+1), y(n), ws(max(n, lim)), rank(n);",
            "\t\tsa = lcp = y, iota(all(sa), 0);",
            "\t\tfor (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {",
            "\t\t\tp = j, iota(all(y), n - j);",
            "\t\t\trep(i,0,n) if (sa[i] >= j) y[p++] = sa[i] - j;",
            "\t\t\tfill(all(ws), 0);",
            "\t\t\trep(i,0,n) ws[x[i]]++;",
            "\t\t\trep(i,1,lim) ws[i] += ws[i - 1];",
            "\t\t\tfor (int i = n; i--;) sa[--ws[x[y[i]]]] = y[i];",
            "\t\t\tswap(x, y), p = 1, x[sa[0]] = 0;",
            "\t\t\trep(i,1,n) a = sa[i - 1], b = sa[i], x[b] =",
            "\t\t\t\t(y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;",
            "\t\t}",
            "\t\trep(i,1,n) rank[sa[i]] = i;",
            "\t\tfor (int i = 0, j; i < n - 1; lcp[rank[i++]] = k)",
            "\t\t\tfor (k && k--, j = sa[rank[i] - 1];",
            "\t\t\t\t\ts[i + k] == s[j + k]; k++);",
            "\t}",
            "};"
        ],
        "description": "O(n \\log n) | Builds suffix array for a string. texttt{sa[i]} is the starting index of the suffix which is i'th in the sorted suffix array. The returned vector is of size n+1, and texttt{sa[0] = n}. The texttt{lcp} array contains longest common prefixes for"
    },
    "SuffixTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_SuffixTree"
        ],
        "body": [
            "struct SuffixTree {",
            "\tenum { N = 200010, ALPHA = 26 }; // N ~ 2*maxlen+10",
            "\tint toi(char c) { return c - 'a'; }",
            "\tstring a; // v = cur node, q = cur position",
            "\tint t[N][ALPHA],l[N],r[N],p[N],s[N],v=0,q=0,m=2;",
            "",
            "\tvoid ukkadd(int i, int c) { suff:",
            "\t\tif (r[v]<=q) {",
            "\t\t\tif (t[v][c]==-1) { t[v][c]=m;  l[m]=i;",
            "\t\t\t\tp[m++]=v; v=s[v]; q=r[v];  goto suff; }",
            "\t\t\tv=t[v][c]; q=l[v];",
            "\t\t}",
            "\t\tif (q==-1 || c==toi(a[q])) q++; else {",
            "\t\t\tl[m+1]=i;  p[m+1]=m;  l[m]=l[v];  r[m]=q;",
            "\t\t\tp[m]=p[v];  t[m][c]=m+1;  t[m][toi(a[q])]=v;",
            "\t\t\tl[v]=q;  p[v]=m;  t[p[m]][toi(a[l[m]])]=m;",
            "\t\t\tv=s[p[m]];  q=l[m];",
            "\t\t\twhile (q<r[m]) { v=t[v][toi(a[q])];  q+=r[v]-l[v]; }",
            "\t\t\tif (q==r[m])  s[m]=v;  else s[m]=m+2;",
            "\t\t\tq=r[v]-(q-r[m]);  m+=2;  goto suff;",
            "\t\t}",
            "\t}",
            "",
            "\tSuffixTree(string a) : a(a) {",
            "\t\tfill(r,r+N,sz(a));",
            "\t\tmemset(s, 0, sizeof s);",
            "\t\tmemset(t, -1, sizeof t);",
            "\t\tfill(t[1],t[1]+ALPHA,0);",
            "\t\ts[0] = 1; l[0] = l[1] = -1; r[0] = r[1] = p[0] = p[1] = 0;",
            "\t\trep(i,0,sz(a)) ukkadd(i, toi(a[i]));",
            "\t}",
            "",
            "\t// example: find longest common substring (uses ALPHA = 28)",
            "\tpii best;",
            "\tint lcs(int node, int i1, int i2, int olen) {",
            "\t\tif (l[node] <= i1 && i1 < r[node]) return 1;",
            "\t\tif (l[node] <= i2 && i2 < r[node]) return 2;",
            "\t\tint mask = 0, len = node ? olen + (r[node] - l[node]) : 0;",
            "\t\trep(c,0,ALPHA) if (t[node][c] != -1)",
            "\t\t\tmask |= lcs(t[node][c], i1, i2, len);",
            "\t\tif (mask == 3)",
            "\t\t\tbest = max(best, {len, r[node] - len});",
            "\t\treturn mask;",
            "\t}",
            "\tstatic pii LCS(string s, string t) {",
            "\t\tSuffixTree st(s + (char)('z' + 1) + t + (char)('z' + 2));",
            "\t\tst.lcs(0, sz(s), sz(s) + 1 + sz(t), 0);",
            "\t\treturn st.best;",
            "\t}",
            "};"
        ],
        "description": "O(26N) | Ukkonen's algorithm for online suffix tree construction. Each node contains indices [l, r) into the string, and a list of child nodes. Suffixes are given by traversals of this tree, joining [l, r) substrings. The root is 0 (has l = -1, r = 0), non-existent children are -1. To get a complete tree, append a dummy symbol -- otherwise it may contain an incomplete path (still useful for substring matching, though)."
    },
    "AhoCorasick-Tyler": {
        "scope": "cpp",
        "prefix": [
            "apoc_AhoCorasick-Tyler"
        ],
        "body": [
            "const int ABSIZE = 26;",
            "",
            "struct node {",
            "    int nxt[ABSIZE];",
            "    vi ids = {};",
            "    int prv = -1, link = -1;",
            "    char c;",
            "    int linkMemo[ABSIZE];",
            "",
            "    node(int prv = -1, char c = '$'): prv(prv), c(c) {",
            "        fill(all(nxt), -1);",
            "        fill(all(linkMemo), -1);",
            "    }",
            "};",
            "",
            "vector<node> trie(1);",
            "",
            "void addWord(string &s, int id) {",
            "    int cur = 0;",
            "    for(char c: s) {",
            "        int idx = c - 'a';",
            "        if(trie[cur].nxt[idx] == -1) {",
            "            trie[cur].nxt[idx] = sz(trie);",
            "            trie.emplace_back(cur, c);",
            "        }",
            "        cur = trie[cur].nxt[idx];",
            "    }",
            "    trie[cur].ids.push_back(id);",
            "}",
            "",
            "int getLink(int cur);",
            "",
            "int calc(int cur, char c) {",
            "    int idx = c - 'a';",
            "    auto &ret = trie[cur].linkMemo[idx];",
            "    if(ret != -1) return ret;",
            "    if(trie[cur].nxt[idx] != -1)",
            "        return ret = trie[cur].nxt[idx];",
            "    return ret = cur == 0 ? 0 : calc(getLink(cur), c);",
            "}",
            "",
            "int getLink(int cur) {",
            "    auto &ret = trie[cur].link;",
            "    if(ret != -1) return ret;",
            "    if(cur == 0 || trie[cur].prv == 0) return ret = 0;",
            "    return ret = calc(getLink(trie[cur].prv), trie[cur].c);",
            "}"
        ],
        "description": "construction takes O(26N), where N = sum of length of patterns. find(x) is O(N), where N = length of x. findAll is O(NM). | Aho-Corasick automaton, used for multiple pattern matching. Initialize with AhoCorasick ac(patterns); the automaton start node will be at index 0. find(word) returns for each position the index of the longest word that ends there, or -1 if none. findAll(-, word) finds all words (up to N sqrt N many if no duplicate patterns) that start at each position (shortest first). Duplicate patterns are allowed; empty patterns are not. To find the longest words that start at each position, reverse all input. For large alphabets, split each symbol into chunks, with sentinel bits for symbol boundaries."
    },
    "Hashing-codeforces": {
        "scope": "cpp",
        "prefix": [
            "apoc_Hashing-codeforces"
        ],
        "body": [
            "typedef uint64_t ull;",
            "static int C; // initialized below",
            "",
            "// Arithmetic mod two primes and 2^32 simultaneously.",
            "// \"typedef uint64_t H;\" instead if Thue-Morse does not apply.",
            "template<int M, class B>",
            "struct A {",
            "\tint x; B b; A(int x=0) : x(x), b(x) {}",
            "\tA(int x, B b) : x(x), b(b) {}",
            "\tA operator+(A o){int y = x+o.x; return{y - (y>=M)*M, b+o.b};}",
            "\tA operator-(A o){int y = x-o.x; return{y + (y< 0)*M, b-o.b};}",
            "\tA operator*(A o) { return {(int)(1LL*x*o.x % M), b*o.b}; }",
            "\texplicit operator ull() { return x ^ (ull) b << 21; }",
            "};",
            "typedef A<1000000007, A<1000000009, unsigned>> H;",
            "",
            "struct HashInterval {",
            "\tvector<H> ha, pw;",
            "\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {",
            "\t\tpw[0] = 1;",
            "\t\trep(i,0,sz(str))",
            "\t\t\tha[i+1] = ha[i] * C + str[i],",
            "\t\t\tpw[i+1] = pw[i] * C;",
            "\t}",
            "\tH hashInterval(int a, int b) { // hash [a, b)",
            "\t\treturn ha[b] - ha[a] * pw[b - a];",
            "\t}",
            "};",
            "",
            "vector<H> getHashes(string& str, int length) {",
            "\tif (sz(str) < length) return {};",
            "\tH h = 0, pw = 1;",
            "\trep(i,0,length)",
            "\t\th = h * C + str[i], pw = pw * C;",
            "\tvector<H> ret = {h};",
            "\trep(i,length,sz(str)) {",
            "\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}",
            "",
            "int main() {",
            "\ttimeval tp;",
            "\tgettimeofday(&tp, 0);",
            "\tC = (int)tp.tv_usec; // (less than modulo)",
            "\tassert((ull)(H(1)*2+1-3) == 0);",
            "\t// ...",
            "}"
        ],
        "description": "Various self-explanatory methods for string hashing. Use on Codeforces, which lacks 64-bit support and where solutions can be hacked."
    },
    "Hashing": {
        "scope": "cpp",
        "prefix": [
            "apoc_Hashing"
        ],
        "body": [
            "// Arithmetic mod 2^64-1. 2x slower than mod 2^64 and more",
            "// code, but works on evil test data (e.g. Thue-Morse, where",
            "// ABBA... and BAAB... of length 2^10 hash the same mod 2^64).",
            "// \"typedef ull H;\" instead if you think test data is random,",
            "// or work mod 10^9+7 if the Birthday paradox is not a problem.",
            "typedef uint64_t ull;",
            "struct H {",
            "\tull x; H(ull x=0) : x(x) {}",
            "\tH operator+(H o) { return x + o.x + (x + o.x < x); }",
            "\tH operator-(H o) { return *this + ~o.x; }",
            "\tH operator*(H o) { auto m = (__uint128_t)x * o.x;",
            "\t\treturn H((ull)m) + (ull)(m >> 64); }",
            "\tull get() const { return x + !~x; }",
            "\tbool operator==(H o) const { return get() == o.get(); }",
            "\tbool operator<(H o) const { return get() < o.get(); }",
            "};",
            "static const H C = (ll)1e11+3; // (order ~ 3e9; random also ok)",
            "",
            "struct HashInterval {",
            "\tvector<H> ha, pw;",
            "\tHashInterval(string& str) : ha(sz(str)+1), pw(ha) {",
            "\t\tpw[0] = 1;",
            "\t\trep(i,0,sz(str))",
            "\t\t\tha[i+1] = ha[i] * C + str[i],",
            "\t\t\tpw[i+1] = pw[i] * C;",
            "\t}",
            "\tH hashInterval(int a, int b) { // hash [a, b)",
            "\t\treturn ha[b] - ha[a] * pw[b - a];",
            "\t}",
            "};",
            "",
            "vector<H> getHashes(string& str, int length) {",
            "\tif (sz(str) < length) return {};",
            "\tH h = 0, pw = 1;",
            "\trep(i,0,length)",
            "\t\th = h * C + str[i], pw = pw * C;",
            "\tvector<H> ret = {h};",
            "\trep(i,length,sz(str)) {",
            "\t\tret.push_back(h = h * C + str[i] - pw * str[i-length]);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "H hashString(string& s){H h{}; for(char c:s) h=h*C+c;return h;}"
        ],
        "description": "Self-explanatory methods for string hashing."
    },
    "FenwickTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_FenwickTree"
        ],
        "body": [
            "struct FT {",
            "\tvector<ll> s;",
            "\tFT(int n) : s(n) {}",
            "\tvoid update(int pos, ll dif) { // a[pos] += dif",
            "\t\tfor (; pos < sz(s); pos |= pos + 1) s[pos] += dif;",
            "\t}",
            "\tll query(int pos) { // sum of values in [0, pos)",
            "\t\tll res = 0;",
            "\t\tfor (; pos > 0; pos &= pos - 1) res += s[pos-1];",
            "\t\treturn res;",
            "\t}",
            "\tint lower_bound(ll sum) {// min pos st sum of [0, pos] >= sum",
            "\t\t// Returns n if no sum is >= sum, or -1 if empty sum is.",
            "\t\tif (sum <= 0) return -1;",
            "\t\tint pos = 0;",
            "\t\tfor (int pw = 1 << 25; pw; pw >>= 1) {",
            "\t\t\tif (pos + pw <= sz(s) && s[pos + pw-1] < sum)",
            "\t\t\t\tpos += pw, sum -= s[pos-1];",
            "\t\t}",
            "\t\treturn pos;",
            "\t}",
            "};"
        ],
        "description": "Both operations are O(\\log N). | Computes partial sums a[0] + a[1] + ... + a[pos - 1], and updates single elements a[i], taking the difference between the old and new value."
    },
    "Treap": {
        "scope": "cpp",
        "prefix": [
            "apoc_Treap"
        ],
        "body": [
            "struct node {",
            "    int val, prior, sz = 1;",
            "    node *left = nullptr, *right = nullptr;",
            "    node(int val = 0): val(val), prior(rand()) {}",
            "};",
            "",
            "int getSz(node *cur) { return cur ? cur->sz : 0; }",
            "void recalc(node *cur) { cur->sz = getSz(cur->left) + getSz(cur->right) + 1; }",
            "",
            "pair<node*, node*> split(node *cur, int v) {",
            "    if(!cur) return {nullptr, nullptr};",
            "    node *left, *right;",
            "    if(getSz(cur->left) >= v) {",
            "        right = cur;",
            "        auto [L, R] = split(cur->left, v);",
            "        left = L, right->left = R;",
            "        recalc(right);",
            "    }",
            "    else {",
            "        left = cur;",
            "        auto [L, R] = split(cur->right, v - getSz(cur->left) - 1);",
            "        left->right = L, right = R;",
            "        recalc(left);",
            "    }",
            "    return {left, right};",
            "}",
            "",
            "node* merge(node *t1, node *t2) {",
            "    if(!t1 || !t2) return t1 ? t1 : t2;",
            "    node *res;",
            "    if(t1->prior > t2->prior) {",
            "        res = t1;",
            "        res->right = merge(t1->right, t2);",
            "    }",
            "    else {",
            "        res = t2;",
            "        res->left = merge(t1, t2->left);",
            "    }",
            "    recalc(res);",
            "    return res;",
            "}"
        ],
        "description": "O(\\log N) | A short self-balancing tree. It acts as a sequential container with log-time splits/joins, and is easy to augment with additional data."
    },
    "LazySegmentTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_LazySegmentTree"
        ],
        "body": [
            "/*",
            " * Usage: Node* tr = new Node(v, 0, sz(v));",
            " */",
            "const int inf = 1e9;",
            "struct Node {",
            "\tNode *l = 0, *r = 0;",
            "\tint lo, hi, mset = inf, madd = 0, val = -inf;",
            "\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf",
            "\tNode(vi& v, int lo, int hi) : lo(lo), hi(hi) {",
            "\t\tif (lo + 1 < hi) {",
            "\t\t\tint mid = lo + (hi - lo)/2;",
            "\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);",
            "\t\t\tval = max(l->val, r->val);",
            "\t\t}",
            "\t\telse val = v[lo];",
            "\t}",
            "\tint query(int L, int R) {",
            "\t\tif (R <= lo || hi <= L) return -inf;",
            "\t\tif (L <= lo && hi <= R) return val;",
            "\t\tpush();",
            "\t\treturn max(l->query(L, R), r->query(L, R));",
            "\t}",
            "\tvoid set(int L, int R, int x) {",
            "\t\tif (R <= lo || hi <= L) return;",
            "\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;",
            "\t\telse {",
            "\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);",
            "\t\t\tval = max(l->val, r->val);",
            "\t\t}",
            "\t}",
            "\tvoid add(int L, int R, int x) {",
            "\t\tif (R <= lo || hi <= L) return;",
            "\t\tif (L <= lo && hi <= R) {",
            "\t\t\tif (mset != inf) mset += x;",
            "\t\t\telse madd += x;",
            "\t\t\tval += x;",
            "\t\t}",
            "\t\telse {",
            "\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);",
            "\t\t\tval = max(l->val, r->val);",
            "\t\t}",
            "\t}",
            "\tvoid push() {",
            "\t\tif (!l) {",
            "\t\t\tint mid = lo + (hi - lo)/2;",
            "\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);",
            "\t\t}",
            "\t\tif (mset != inf)",
            "\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;",
            "\t\telse if (madd)",
            "\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;",
            "\t}",
            "};"
        ],
        "description": "O(\\log N). | Segment tree with ability to add or set values of large intervals, and compute max of intervals. Can be changed to other things. Use with a bump allocator for better performance, and SmallPtr or implicit indices to save memory."
    },
    "MoQueries": {
        "scope": "cpp",
        "prefix": [
            "apoc_MoQueries"
        ],
        "body": [
            "void add(int ind, int end) { ... } // add a[ind] (end = 0 or 1)",
            "void del(int ind, int end) { ... } // remove a[ind]",
            "int calc() { ... } // compute current answer",
            "",
            "vi mo(vector<pii> Q) {",
            "\tint L = 0, R = 0, blk = 350; // ~N/sqrt(Q)",
            "\tvi s(sz(Q)), res = s;",
            "#define K(x) pii(x.first/blk, x.second ^ -(x.first/blk & 1))",
            "\tiota(all(s), 0);",
            "\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });",
            "\tfor (int qi : s) {",
            "\t\tpii q = Q[qi];",
            "\t\twhile (L > q.first) add(--L, 0);",
            "\t\twhile (R < q.second) add(R++, 1);",
            "\t\twhile (L < q.first) del(L++, 0);",
            "\t\twhile (R > q.second) del(--R, 1);",
            "\t\tres[qi] = calc();",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "vi moTree(vector<array<int, 2>> Q, vector<vi>& ed, int root=0){",
            "\tint N = sz(ed), pos[2] = {}, blk = 350; // ~N/sqrt(Q)",
            "\tvi s(sz(Q)), res = s, I(N), L(N), R(N), in(N), par(N);",
            "\tadd(0, 0), in[0] = 1;",
            "\tauto dfs = [&](int x, int p, int dep, auto& f) -> void {",
            "\t\tpar[x] = p;",
            "\t\tL[x] = N;",
            "\t\tif (dep) I[x] = N++;",
            "\t\tfor (int y : ed[x]) if (y != p) f(y, x, !dep, f);",
            "\t\tif (!dep) I[x] = N++;",
            "\t\tR[x] = N;",
            "\t};",
            "\tdfs(root, -1, 0, dfs);",
            "#define K(x) pii(I[x[0]] / blk, I[x[1]] ^ -(I[x[0]] / blk & 1))",
            "\tiota(all(s), 0);",
            "\tsort(all(s), [&](int s, int t){ return K(Q[s]) < K(Q[t]); });",
            "\tfor (int qi : s) rep(end,0,2) {",
            "\t\tint &a = pos[end], b = Q[qi][end], i = 0;",
            "#define step(c) { if (in[c]) { del(a, end); in[a] = 0; } \\",
            "                  else { add(c, end); in[c] = 1; } a = c; }",
            "\t\twhile (!(L[b] <= L[a] && R[a] <= R[b]))",
            "\t\t\tI[i++] = b, b = par[b];",
            "\t\twhile (a != b) step(par[a]);",
            "\t\twhile (i--) step(I[i]);",
            "\t\tif (end) res[qi] = calc();",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(N sqrt Q) | Answer interval or tree path queries by finding an approximate TSP through the queries, and moving from one query to the next by adding/removing points at the ends. If values are on tree edges, change texttt{step} to add/remove the edge (a, c) and remove the initial texttt{add} call (but keep texttt{in})."
    },
    "Matrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_Matrix"
        ],
        "body": [
            "/*",
            " * Usage: Matrix<int, 3> A;",
            " *  A.d = {{{{1,2,3}}, {{4,5,6}}, {{7,8,9}}}};",
            " *  vector<int> vec = {1,2,3};",
            " *  vec = (A^N) * vec;",
            " */",
            "template<class T, int N> struct Matrix {",
            "\ttypedef Matrix M;",
            "\tarray<array<T, N>, N> d{};",
            "\tM operator*(const M& m) const {",
            "\t\tM a;",
            "\t\trep(i,0,N) rep(j,0,N)",
            "\t\t\trep(k,0,N) a.d[i][j] += d[i][k]*m.d[k][j];",
            "\t\treturn a;",
            "\t}",
            "\tvector<T> operator*(const vector<T>& vec) const {",
            "\t\tvector<T> ret(N);",
            "\t\trep(i,0,N) rep(j,0,N) ret[i] += d[i][j] * vec[j];",
            "\t\treturn ret;",
            "\t}",
            "\tM operator^(ll p) const {",
            "\t\tassert(p >= 0);",
            "\t\tM a, b(*this);",
            "\t\trep(i,0,N) a.d[i][i] = 1;",
            "\t\twhile (p) {",
            "\t\t\tif (p&1) a = a*b;",
            "\t\t\tb = b*b;",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "};"
        ],
        "description": "Basic operations on square matrices."
    },
    "HashMap": {
        "scope": "cpp",
        "prefix": [
            "apoc_HashMap"
        ],
        "body": [
            "// To use most bits rather than just the lowest ones:",
            "struct chash { // large odd number for C",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71;",
            "\tll operator()(ll x) const { return __builtin_bswap64(x*C); }",
            "};",
            "__gnu_pbds::gp_hash_table<ll,int,chash> h({},{},{},{},{1<<16});",
            "",
            "",
            "const int RANDOM = chrono::high_resolution_clock::now().time_since_epoch().count();",
            "struct chash { // To use most bits rather than just the lowest ones:",
            "\tconst uint64_t C = ll(4e18 * acos(0)) | 71; // large odd number",
            "\tll operator()(ll x) const { return __builtin_bswap64((x^RANDOM)*C); }",
            "};",
            "__gnu_pbds::gp_hash_table<ll, int, chash> h({},{},{},{}, {1 << 16});",
            "*/"
        ],
        "description": "Hash map with mostly the same API as unordered_map, but tilde 3x faster. Uses 1.5x memory. Initial capacity must be a power of 2 (if provided). /"
    },
    "SegmentTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentTree"
        ],
        "body": [
            "struct Tree {",
            "\ttypedef int T;",
            "\tstatic constexpr T unit = INT_MIN;",
            "\tT f(T a, T b) { return max(a, b); } // (any associative fn)",
            "\tvector<T> s; int n;",
            "\tTree(int n = 0, T def = unit) : s(2*n, def), n(n) {}",
            "\tvoid update(int pos, T val) {",
            "\t\tfor (s[pos += n] = val; pos /= 2;)",
            "\t\t\ts[pos] = f(s[pos * 2], s[pos * 2 + 1]);",
            "\t}",
            "\tT query(int b, int e) { // query [b, e)",
            "\t\tT ra = unit, rb = unit;",
            "\t\tfor (b += n, e += n; b < e; b /= 2, e /= 2) {",
            "\t\t\tif (b % 2) ra = f(ra, s[b++]);",
            "\t\t\tif (e % 2) rb = f(s[--e], rb);",
            "\t\t}",
            "\t\treturn f(ra, rb);",
            "\t}",
            "};"
        ],
        "description": "O(\\log N) | Zero-indexed max-tree. Bounds are inclusive to the left and exclusive to the right. Can be changed by modifying T, f and unit."
    },
    "UnionFind": {
        "scope": "cpp",
        "prefix": [
            "apoc_UnionFind"
        ],
        "body": [
            "struct UF {",
            "\tvi e;",
            "\tUF(int n) : e(n, -1) {}",
            "\tbool sameSet(int a, int b) { return find(a) == find(b); }",
            "\tint size(int x) { return -e[find(x)]; }",
            "\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
            "\tbool join(int a, int b) {",
            "\t\ta = find(a), b = find(b);",
            "\t\tif (a == b) return false;",
            "\t\tif (e[a] > e[b]) swap(a, b);",
            "\t\te[a] += e[b]; e[b] = a;",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "O(alpha(N)) / | Disjoint-set data structure."
    },
    "PST": {
        "scope": "cpp",
        "prefix": [
            "apoc_PST"
        ],
        "body": [
            "struct PST {",
            "\tPST *l = 0, *r = 0;",
            "\tint lo, hi;",
            "\tll val = 0, lzadd = 0;",
            "\tPST(vl& v, int lo, int hi) : lo(lo), hi(hi) {",
            "\t\tif (lo + 1 < hi) {",
            "\t\t\tint mid = lo + (hi - lo)/2;",
            "\t\t\tl = new PST(v, lo, mid); r = new PST(v, mid, hi);",
            "\t\t}",
            "\t\telse val = v[lo];",
            "\t}",
            "\tll query(int L, int R) {",
            "\t\tif (R < lo || hi < L) return 0; // idempotent",
            "\t\tif (L <= lo && hi <= R) return val;",
            "\t\tpush();",
            "\t\treturn l->query(L, R) + r->query(L, R);",
            "\t}",
            "\tPST * add(int L, int R, ll v) {",
            "\t\tif (R <= lo || hi <= L) return this;",
            "\t\tPST *n;",
            "\t\tif (L <= lo && hi <= R) {",
            "\t\t\tn = new PST(*this);",
            "\t\t\tn->val += v;",
            "\t\t\tn->lzadd += v;",
            "\t\t} else {",
            "\t\t\tpush();",
            "\t\t\tn = new PST(*this);",
            "\t\t\tn->l = l->add(L, R, v);",
            "\t\t\tn->r = r->add(L, R, v);",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "\tvoid push() {",
            "\t\tif(lzadd == 0) return;",
            "\t\tl = l->add(lo, hi, lzadd);",
            "\t\tr = r->add(lo, hi, lzadd);",
            "\t\tlzadd = 0;",
            "\t}",
            "};"
        ],
        "description": "O(\\log N) per query, O((n + q) \\log n) memory | Persistent segment tree with laziness"
    },
    "RMQ": {
        "scope": "cpp",
        "prefix": [
            "apoc_RMQ"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " *  RMQ rmq(values);",
            " *  rmq.query(inclusive, exclusive);",
            " */",
            "template<class T>",
            "struct RMQ {",
            "\tvector<vector<T>> jmp;",
            "\tRMQ(const vector<T>& V) : jmp(1, V) {",
            "\t\tfor (int pw = 1, k = 1; pw * 2 <= sz(V); pw *= 2, ++k) {",
            "\t\t\tjmp.emplace_back(sz(V) - pw * 2 + 1);",
            "\t\t\trep(j,0,sz(jmp[k]))",
            "\t\t\t\tjmp[k][j] = min(jmp[k - 1][j], jmp[k - 1][j + pw]);",
            "\t\t}",
            "\t}",
            "\tT query(int a, int b) {",
            "\t\tassert(a < b); // or return inf if a == b",
            "\t\tint dep = 31 - __builtin_clz(b - a);",
            "\t\treturn min(jmp[dep][a], jmp[dep][b - (1 << dep)]);",
            "\t}",
            "};"
        ],
        "description": "O(|V| \\log |V| + Q) | Range Minimum Queries on an array. Returns min(V[a], V[a + 1], ... V[b - 1]) in constant time."
    },
    "FenwickTree2d": {
        "scope": "cpp",
        "prefix": [
            "apoc_FenwickTree2d"
        ],
        "body": [
            "struct FT2 {",
            "\tvector<vi> ys; vector<FT> ft;",
            "\tFT2(int limx) : ys(limx) {}",
            "\tvoid fakeUpdate(int x, int y) {",
            "\t\tfor (; x < sz(ys); x |= x + 1) ys[x].push_back(y);",
            "\t}",
            "\tvoid init() {",
            "\t\tfor (vi& v : ys) sort(all(v)), ft.emplace_back(sz(v));",
            "\t}",
            "\tint ind(int x, int y) {",
            "\t\treturn (int)(lower_bound(all(ys[x]), y) - ys[x].begin()); }",
            "\tvoid update(int x, int y, ll dif) {",
            "\t\tfor (; x < sz(ys); x |= x + 1)",
            "\t\t\tft[x].update(ind(x, y), dif);",
            "\t}",
            "\tll query(int x, int y) {",
            "\t\tll sum = 0;",
            "\t\tfor (; x; x &= x - 1)",
            "\t\t\tsum += ft[x-1].query(ind(x-1, y));",
            "\t\treturn sum;",
            "\t}",
            "};"
        ],
        "description": "O(\\log^2 N). (Use persistent segment trees for O(\\log N).) | Computes sums a[i,j] for all i<I, j<J, and increases single elements a[i,j]. Requires that the elements to be updated are known in advance (call fakeUpdate() before init())."
    },
    "OrderStatisticTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_OrderStatisticTree"
        ],
        "body": [
            "using namespace __gnu_pbds;",
            "",
            "template<class T>",
            "using Tree = tree<T, null_type, less<T>, rb_tree_tag,",
            "    tree_order_statistics_node_update>;",
            "",
            "void example() {",
            "\tTree<int> t, t2; t.insert(8);",
            "\tauto it = t.insert(10).first;",
            "\tassert(it == t.lower_bound(9));",
            "\tassert(t.order_of_key(10) == 1);",
            "\tassert(t.order_of_key(11) == 2);",
            "\tassert(*t.find_by_order(0) == 8);",
            "\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t",
            "}"
        ],
        "description": "O(\\log N) / | A set (not multiset!) with support for finding the n'th element, and finding the index of an element. To get a map, change texttt{null_type}."
    },
    "UnionFindRollback": {
        "scope": "cpp",
        "prefix": [
            "apoc_UnionFindRollback"
        ],
        "body": [
            "/*",
            " * Usage: int t = uf.time(); ...; uf.rollback(t);",
            " */",
            "struct RollbackUF {",
            "\tvi e; vector<pii> st;",
            "\tRollbackUF(int n) : e(n, -1) {}",
            "\tint size(int x) { return -e[find(x)]; }",
            "\tint find(int x) { return e[x] < 0 ? x : find(e[x]); }",
            "\tint time() { return sz(st); }",
            "\tvoid rollback(int t) {",
            "\t\tfor (int i = time(); i --> t;)",
            "\t\t\te[st[i].first] = st[i].second;",
            "\t\tst.resize(t);",
            "\t}",
            "\tbool join(int a, int b) {",
            "\t\ta = find(a), b = find(b);",
            "\t\tif (a == b) return false;",
            "\t\tif (e[a] > e[b]) swap(a, b);",
            "\t\tst.push_back({a, e[a]});",
            "\t\tst.push_back({b, e[b]});",
            "\t\te[a] += e[b]; e[b] = a;",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "O(\\log(N)) | Disjoint-set data structure with undo. If undo is not needed, skip st, time() and rollback()."
    },
    "LineContainer": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineContainer"
        ],
        "body": [
            "struct Line {",
            "\tmutable ll k, m, p;",
            "\tbool operator<(const Line& o) const { return k < o.k; }",
            "\tbool operator<(ll x) const { return p < x; }",
            "};",
            "",
            "struct LineContainer : multiset<Line, less<>> {",
            "\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
            "\tstatic const ll inf = LLONG_MAX;",
            "\tll div(ll a, ll b) { // floored division",
            "\t\treturn a / b - ((a ^ b) < 0 && a % b); }",
            "\tbool isect(iterator x, iterator y) {",
            "\t\tif (y == end()) return x->p = inf, 0;",
            "\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
            "\t\telse x->p = div(y->m - x->m, x->k - y->k);",
            "\t\treturn x->p >= y->p;",
            "\t}",
            "\tvoid add(ll k, ll m) {",
            "\t\tauto z = insert({k, m, 0}), y = z++, x = y;",
            "\t\twhile (isect(y, z)) z = erase(z);",
            "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
            "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
            "\t\t\tisect(x, erase(y));",
            "\t}",
            "\tll query(ll x) {",
            "\t\tassert(!empty());",
            "\t\tauto l = *lower_bound(x);",
            "\t\treturn l.k * x + l.m;",
            "\t}",
            "};"
        ],
        "description": "O(\\log N) | Container where you can add lines of the form kx+m, and query maximum values at points x. Useful for dynamic programming (``convex hull trick'')."
    },
    "SubMatrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_SubMatrix"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * SubMatrix<int> m(matrix);",
            " * m.sum(0, 0, 2, 2); // top left 4 elements",
            " */",
            "template<class T>",
            "struct SubMatrix {",
            "\tvector<vector<T>> p;",
            "\tSubMatrix(vector<vector<T>>& v) {",
            "\t\tint R = sz(v), C = sz(v[0]);",
            "\t\tp.assign(R+1, vector<T>(C+1));",
            "\t\trep(r,0,R) rep(c,0,C)",
            "\t\t\tp[r+1][c+1] = v[r][c] + p[r][c+1] + p[r+1][c] - p[r][c];",
            "\t}",
            "\tT sum(int u, int l, int d, int r) {",
            "\t\treturn p[d][r] - p[d][l] - p[u][r] + p[u][l];",
            "\t}",
            "};"
        ],
        "description": "O(N^2 + Q) | Calculate submatrix sums quickly, given upper-left and lower-right corners (half-open)."
    },
    "FastFourierTransformMod": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastFourierTransformMod"
        ],
        "body": [
            "typedef vector<ll> vl;",
            "template<int M> vl convMod(const vl &a, const vl &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvl res(sz(a) + sz(b) - 1);",
            "\tint B=32-__builtin_clz(sz(res)), n=1<<B, cut=int(sqrt(M));",
            "\tvector<C> L(n), R(n), outs(n), outl(n);",
            "\trep(i,0,sz(a)) L[i] = C((int)a[i] / cut, (int)a[i] % cut);",
            "\trep(i,0,sz(b)) R[i] = C((int)b[i] / cut, (int)b[i] % cut);",
            "\tfft(L), fft(R);",
            "\trep(i,0,n) {",
            "\t\tint j = -i & (n - 1);",
            "\t\toutl[j] = (L[i] + conj(L[j])) * R[i] / (2.0 * n);",
            "\t\touts[j] = (L[i] - conj(L[j])) * R[i] / (2.0 * n) / 1i;",
            "\t}",
            "\tfft(outl), fft(outs);",
            "\trep(i,0,sz(res)) {",
            "\t\tll av = ll(real(outl[i])+.5), cv = ll(imag(outs[i])+.5);",
            "\t\tll bv = ll(imag(outl[i])+.5) + ll(real(outs[i])+.5);",
            "\t\tres[i] = ((av % M * cut + bv) % M * cut + cv) % M;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(N \\log N), where N = |A|+|B| (twice as slow as NTT or FFT) | Higher precision FFT, can be used for convolutions modulo arbitrary integers as long as N\\log_2Ncdot text{mod} < 8.6 cdot 10^{14} (in practice 10^{16} or higher). Inputs must be in [0, text{mod})."
    },
    "BerlekampMassey": {
        "scope": "cpp",
        "prefix": [
            "apoc_BerlekampMassey"
        ],
        "body": [
            "/*",
            " * Usage: berlekampMassey({0, 1, 1, 3, 5, 11}) // {1, 2}",
            " */",
            "vector<ll> berlekampMassey(vector<ll> s) {",
            "\tint n = sz(s), L = 0, m = 0;",
            "\tvector<ll> C(n), B(n), T;",
            "\tC[0] = B[0] = 1;",
            "",
            "\tll b = 1;",
            "\trep(i,0,n) { ++m;",
            "\t\tll d = s[i] % mod;",
            "\t\trep(j,1,L+1) d = (d + C[j] * s[i - j]) % mod;",
            "\t\tif (!d) continue;",
            "\t\tT = C; ll coef = d * modpow(b, mod-2) % mod;",
            "\t\trep(j,m,n) C[j] = (C[j] - coef * B[j - m]) % mod;",
            "\t\tif (2 * L > i) continue;",
            "\t\tL = i + 1 - L; B = T; b = d; m = 0;",
            "\t}",
            "",
            "\tC.resize(L + 1); C.erase(C.begin());",
            "\tfor (ll& x : C) x = (mod - x) % mod;",
            "\treturn C;",
            "}"
        ],
        "description": "O(N^2) | Recovers any n-order linear recurrence relation from the first 2n terms of the recurrence. Useful for guessing linear recurrences after brute-forcing the first terms. Should work on any field, but numerical stability for floats is not guaranteed. Output will have size \\le n."
    },
    "GoldenSectionSearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_GoldenSectionSearch"
        ],
        "body": [
            "/*",
            " * Usage: ",
            "\tdouble func(double x) { return 4+x+.3*x*x; }",
            "\tdouble xmin = gss(-1000,1000,func);",
            " */",
            "/// It is important for r to be precise, otherwise we don't necessarily maintain the inequality a < x1 < x2 < b.",
            "double gss(double a, double b, double (*f)(double)) {",
            "\tdouble r = (sqrt(5)-1)/2, eps = 1e-7;",
            "\tdouble x1 = b - r*(b-a), x2 = a + r*(b-a);",
            "\tdouble f1 = f(x1), f2 = f(x2);",
            "\twhile (b-a > eps)",
            "\t\tif (f1 < f2) { //change to > to find maximum",
            "\t\t\tb = x2; x2 = x1; f2 = f1;",
            "\t\t\tx1 = b - r*(b-a); f1 = f(x1);",
            "\t\t} else {",
            "\t\t\ta = x1; x1 = x2; f1 = f2;",
            "\t\t\tx2 = a + r*(b-a); f2 = f(x2);",
            "\t\t}",
            "\treturn a;",
            "}"
        ],
        "description": "O(\\log((b-a) / \\epsilon)) | Finds the argument minimizing the function f in the interval [a,b] assuming f is unimodal on the interval, i.e. has only one local minimum. The maximum error in the result is eps. Works equally well for maximization with a small change in the code. See TernarySearch.h in the Various chapter for a discrete version."
    },
    "SolveLinear2": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinear2"
        ],
        "body": [
            "rep(j,0,n) if (j != i) // instead of rep(j,i+1,n)",
            "// ... then at the end:",
            "x.assign(m, undefined);",
            "rep(i,0,rank) {",
            "\trep(j,rank,m) if (fabs(A[i][j]) > eps) goto fail;",
            "\tx[col[i]] = b[i] / A[i][i];",
            "fail:; }"
        ],
        "description": ""
    },
    "Polynomial": {
        "scope": "cpp",
        "prefix": [
            "apoc_Polynomial"
        ],
        "body": [
            "struct Poly {",
            "\tvector<double> a;",
            "\tdouble operator()(double x) const {",
            "\t\tdouble val = 0;",
            "\t\tfor (int i = sz(a); i--;) (val *= x) += a[i];",
            "\t\treturn val;",
            "\t}",
            "\tvoid diff() {",
            "\t\trep(i,1,sz(a)) a[i-1] = i*a[i];",
            "\t\ta.pop_back();",
            "\t}",
            "\tvoid divroot(double x0) {",
            "\t\tdouble b = a.back(), c; a.back() = 0;",
            "\t\tfor(int i=sz(a)-1; i--;) c = a[i], a[i] = a[i+1]*x0+b, b=c;",
            "\t\ta.pop_back();",
            "\t}",
            "};"
        ],
        "description": " /"
    },
    "Integrate": {
        "scope": "cpp",
        "prefix": [
            "apoc_Integrate"
        ],
        "body": [
            "template<class F>",
            "double quad(double a, double b, F f, const int n = 1000) {",
            "\tdouble h = (b - a) / 2 / n, v = f(a) + f(b);",
            "\trep(i,1,n*2)",
            "\t\tv += f(a + i*h) * (i&1 ? 4 : 2);",
            "\treturn v * h / 3;",
            "}"
        ],
        "description": "Simple integration of a function over an interval using Simpson's rule. The error should be proportional to h^4, although in practice you will want to verify that the result is stable to desired precision when epsilon changes."
    },
    "HillClimbing": {
        "scope": "cpp",
        "prefix": [
            "apoc_HillClimbing"
        ],
        "body": [
            "typedef array<double, 2> P;",
            "",
            "template<class F> pair<double, P> hillClimb(P start, F f) {",
            "\tpair<double, P> cur(f(start), start);",
            "\tfor (double jmp = 1e9; jmp > 1e-20; jmp /= 2) {",
            "\t\trep(j,0,100) rep(dx,-1,2) rep(dy,-1,2) {",
            "\t\t\tP p = cur.second;",
            "\t\t\tp[0] += dx*jmp;",
            "\t\t\tp[1] += dy*jmp;",
            "\t\t\tcur = min(cur, make_pair(f(p), p));",
            "\t\t}",
            "\t}",
            "\treturn cur;",
            "}"
        ],
        "description": "Poor man's optimization for unimodal functions."
    },
    "Simplex": {
        "scope": "cpp",
        "prefix": [
            "apoc_Simplex"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * vvd A = {{1,-1}, {-1,1}, {-1,-2}};",
            " * vd b = {1,1,-4}, c = {-1,-1}, x;",
            " * T val = LPSolver(A, b, c).solve(x);",
            " */",
            "typedef double T; // long double, Rational, double + mod<P>...",
            "typedef vector<T> vd;",
            "typedef vector<vd> vvd;",
            "",
            "const T eps = 1e-8, inf = 1/.0;",
            "#define MP make_pair",
            "#define ltj(X) if(s == -1 || MP(X[j],N[j]) < MP(X[s],N[s])) s=j",
            "",
            "struct LPSolver {",
            "\tint m, n;",
            "\tvi N, B;",
            "\tvvd D;",
            "",
            "\tLPSolver(const vvd& A, const vd& b, const vd& c) :",
            "\t\tm(sz(b)), n(sz(c)), N(n+1), B(m), D(m+2, vd(n+2)) {",
            "\t\t\trep(i,0,m) rep(j,0,n) D[i][j] = A[i][j];",
            "\t\t\trep(i,0,m) { B[i] = n+i; D[i][n] = -1; D[i][n+1] = b[i];}",
            "\t\t\trep(j,0,n) { N[j] = j; D[m][j] = -c[j]; }",
            "\t\t\tN[n] = -1; D[m+1][n] = 1;",
            "\t\t}",
            "",
            "\tvoid pivot(int r, int s) {",
            "\t\tT *a = D[r].data(), inv = 1 / a[s];",
            "\t\trep(i,0,m+2) if (i != r && abs(D[i][s]) > eps) {",
            "\t\t\tT *b = D[i].data(), inv2 = b[s] * inv;",
            "\t\t\trep(j,0,n+2) b[j] -= a[j] * inv2;",
            "\t\t\tb[s] = a[s] * inv2;",
            "\t\t}",
            "\t\trep(j,0,n+2) if (j != s) D[r][j] *= inv;",
            "\t\trep(i,0,m+2) if (i != r) D[i][s] *= -inv;",
            "\t\tD[r][s] = inv;",
            "\t\tswap(B[r], N[s]);",
            "\t}",
            "",
            "\tbool simplex(int phase) {",
            "\t\tint x = m + phase - 1;",
            "\t\tfor (;;) {",
            "\t\t\tint s = -1;",
            "\t\t\trep(j,0,n+1) if (N[j] != -phase) ltj(D[x]);",
            "\t\t\tif (D[x][s] >= -eps) return true;",
            "\t\t\tint r = -1;",
            "\t\t\trep(i,0,m) {",
            "\t\t\t\tif (D[i][s] <= eps) continue;",
            "\t\t\t\tif (r == -1 || MP(D[i][n+1] / D[i][s], B[i])",
            "\t\t\t\t             < MP(D[r][n+1] / D[r][s], B[r])) r = i;",
            "\t\t\t}",
            "\t\t\tif (r == -1) return false;",
            "\t\t\tpivot(r, s);",
            "\t\t}",
            "\t}",
            "",
            "\tT solve(vd &x) {",
            "\t\tint r = 0;",
            "\t\trep(i,1,m) if (D[i][n+1] < D[r][n+1]) r = i;",
            "\t\tif (D[r][n+1] < -eps) {",
            "\t\t\tpivot(r, n);",
            "\t\t\tif (!simplex(2) || D[m+1][n+1] < -eps) return -inf;",
            "\t\t\trep(i,0,m) if (B[i] == -1) {",
            "\t\t\t\tint s = 0;",
            "\t\t\t\trep(j,1,n+1) ltj(D[i]);",
            "\t\t\t\tpivot(i, s);",
            "\t\t\t}",
            "\t\t}",
            "\t\tbool ok = simplex(1); x = vd(n);",
            "\t\trep(i,0,m) if (B[i] < n) x[B[i]] = D[i][n+1];",
            "\t\treturn ok ? D[m][n+1] : inf;",
            "\t}",
            "};"
        ],
        "description": "O(NM * #pivots), where a pivot may be e.g. an edge relaxation. O(2^n) in the general case. | "
    },
    "PolyRoots": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyRoots"
        ],
        "body": [
            "/*",
            " * Usage: polyRoots({{2,-3,1}},-1e9,1e9) // solve x^2-3x+2 = 0",
            " */",
            "vector<double> polyRoots(Poly p, double xmin, double xmax) {",
            "\tif (sz(p.a) == 2) { return {-p.a[0]/p.a[1]}; }",
            "\tvector<double> ret;",
            "\tPoly der = p;",
            "\tder.diff();",
            "\tauto dr = polyRoots(der, xmin, xmax);",
            "\tdr.push_back(xmin-1);",
            "\tdr.push_back(xmax+1);",
            "\tsort(all(dr));",
            "\trep(i,0,sz(dr)-1) {",
            "\t\tdouble l = dr[i], h = dr[i+1];",
            "\t\tbool sign = p(l) > 0;",
            "\t\tif (sign ^ (p(h) > 0)) {",
            "\t\t\trep(it,0,60) { // while (h - l > 1e-8)",
            "\t\t\t\tdouble m = (l + h) / 2, f = p(m);",
            "\t\t\t\tif ((f <= 0) ^ sign) l = m;",
            "\t\t\t\telse h = m;",
            "\t\t\t}",
            "\t\t\tret.push_back((l + h) / 2);",
            "\t\t}",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "O(n^2 \\log(1/\\epsilon)) / | Finds the real roots to a polynomial."
    },
    "FastFourierTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastFourierTransform"
        ],
        "body": [
            "   Accuracy bound from http://www.daemonology.net/papers/fft.pdf",
            "   Useful for convolution:",
            "   \\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.",
            "   For convolution of complex numbers or more than two vectors: FFT, multiply",
            "   pointwise, divide by n, reverse(start+1, end), FFT back.",
            "   Rounding is safe if $(\\sum a_i^2 + \\sum b_i^2)\\log_2{N} < 9\\cdot10^{14}$",
            "   (in practice $10^{16}$; higher for random inputs).",
            "   Otherwise, use NTT/FFTMod.",
            "",
            "typedef complex<double> C;",
            "typedef vector<double> vd;",
            "void fft(vector<C>& a) {",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);",
            "\tstatic vector<complex<long double>> R(2, 1);",
            "\tstatic vector<C> rt(2, 1);  // (^ 10% faster if double)",
            "\tfor (static int k = 2; k < n; k *= 2) {",
            "\t\tR.resize(n); rt.resize(n);",
            "\t\tauto x = polar(1.0L, acos(-1.0L) / k);",
            "\t\trep(i,k,2*k) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];",
            "\t}",
            "\tvi rev(n);",
            "\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {",
            "\t\t\t// C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line",
            "\t\t\tauto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line",
            "\t\t\tC z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line",
            "\t\t\ta[i + j + k] = a[i + j] - z;",
            "\t\t\ta[i + j] += z;",
            "\t\t}",
            "}",
            "vd conv(const vd& a, const vd& b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tvd res(sz(a) + sz(b) - 1);",
            "\tint L = 32 - __builtin_clz(sz(res)), n = 1 << L;",
            "\tvector<C> in(n), out(n);",
            "\tcopy(all(a), begin(in));",
            "\trep(i,0,sz(b)) in[i].imag(b[i]);",
            "\tfft(in);",
            "\tfor (C& x : in) x *= x;",
            "\trep(i,0,n) out[i] = in[-i & (n - 1)] - conj(in[i]);",
            "\tfft(out);",
            "\trep(i,0,sz(res)) res[i] = imag(out[i]) / (4 * n);",
            "\treturn res;",
            "}"
        ],
        "description": "O(N \\log N) with N = |A|+|B| (tilde 1s for N=2^{22}) | fft(a) computes hat f(k) = sum_x a[x] \\exp(2pi i cdot k x / N) for all k. N must be a power of 2."
    },
    "MatrixInverse-mod": {
        "scope": "cpp",
        "prefix": [
            "apoc_MatrixInverse-mod"
        ],
        "body": [
            "int matInv(vector<vector<ll>>& A) {",
            "\tint n = sz(A); vi col(n);",
            "\tvector<vector<ll>> tmp(n, vector<ll>(n));",
            "\trep(i,0,n) tmp[i][i] = 1, col[i] = i;",
            "",
            "\trep(i,0,n) {",
            "\t\tint r = i, c = i;",
            "\t\trep(j,i,n) rep(k,i,n) if (A[j][k]) {",
            "\t\t\tr = j; c = k; goto found;",
            "\t\t}",
            "\t\treturn i;",
            "found:",
            "\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);",
            "\t\trep(j,0,n) swap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);",
            "\t\tswap(col[i], col[c]);",
            "\t\tll v = modpow(A[i][i], mod - 2);",
            "\t\trep(j,i+1,n) {",
            "\t\t\tll f = A[j][i] * v % mod;",
            "\t\t\tA[j][i] = 0;",
            "\t\t\trep(k,i+1,n) A[j][k] = (A[j][k] - f*A[i][k]) % mod;",
            "\t\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - f*tmp[i][k]) % mod;",
            "\t\t}",
            "\t\trep(j,i+1,n) A[i][j] = A[i][j] * v % mod;",
            "\t\trep(j,0,n) tmp[i][j] = tmp[i][j] * v % mod;",
            "\t\tA[i][i] = 1;",
            "\t}",
            "",
            "\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {",
            "\t\tll v = A[j][i];",
            "\t\trep(k,0,n) tmp[j][k] = (tmp[j][k] - v*tmp[i][k]) % mod;",
            "\t}",
            "",
            "\trep(i,0,n) rep(j,0,n)",
            "\t\tA[col[i]][col[j]] = tmp[i][j] % mod + (tmp[i][j] < 0 ? mod : 0);",
            "\treturn n;",
            "}"
        ],
        "description": "O(n^3) | Invert matrix A modulo a prime. Returns rank; result is stored in A unless singular (rank < n). For prime powers, repeatedly set A^{-1} = A^{-1} (2I - AA^{-1})  (text{mod }p^k) where A^{-1} starts as the inverse of A mod p, and k is doubled in each step."
    },
    "IntDeterminant": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntDeterminant"
        ],
        "body": [
            "const ll mod = 12345;",
            "ll det(vector<vector<ll>>& a) {",
            "\tint n = sz(a); ll ans = 1;",
            "\trep(i,0,n) {",
            "\t\trep(j,i+1,n) {",
            "\t\t\twhile (a[j][i] != 0) { // gcd step",
            "\t\t\t\tll t = a[i][i] / a[j][i];",
            "\t\t\t\tif (t) rep(k,i,n)",
            "\t\t\t\t\ta[i][k] = (a[i][k] - a[j][k] * t) % mod;",
            "\t\t\t\tswap(a[i], a[j]);",
            "\t\t\t\tans *= -1;",
            "\t\t\t}",
            "\t\t}",
            "\t\tans = ans * a[i][i] % mod;",
            "\t\tif (!ans) return 0;",
            "\t}",
            "\treturn (ans + mod) % mod;",
            "}"
        ],
        "description": "O(N^3) | Calculates determinant using modular arithmetics. Modulos can also be removed to get a pure-integer version."
    },
    "integrateAdaptiveTyler": {
        "scope": "cpp",
        "prefix": [
            "apoc_integrateAdaptiveTyler"
        ],
        "body": [
            "#define approx(a, b) (b-a) / 6 * (f(a) + 4 * f((a+b) / 2) + f(b))",
            "",
            "template<class F>",
            "ld adapt (F &f, ld a, ld b, ld A, int iters) {",
            "    ld m = (a+b) / 2;",
            "    ld A1 = approx(a, m), A2 = approx(m, b);",
            "    if(!iters && (abs(A1 + A2 - A) < eps || b-a < eps))",
            "        return A;",
            "    ld left = adapt(f, a, m, A1, max(iters-1, 0));",
            "    ld right = adapt(f, m, b, A2, max(iters-1, 0));",
            "    return left + right;",
            "}",
            "",
            "template<class F>",
            "ld integrate(F f, ld a, ld b, int iters = 0) {",
            "    return adapt(f, a, b, approx(a, b), iters);",
            "}"
        ],
        "description": "Gets area under a curve"
    },
    "NewtonsMethod": {
        "scope": "cpp",
        "prefix": [
            "apoc_NewtonsMethod"
        ],
        "body": [
            "template<class F, class T>",
            "void solveNonlinear(F f, vector<T> &x){",
            "    int n = sz(x);",
            "    rep(iter, 0, 100) {",
            "        vector<vector<T>> J = makeJacobian(f, x);",
            "        matInv(J);",
            "        vector<T> dx = J * f(x);",
            "        x = x - dx;",
            "    }",
            "}"
        ],
        "description": "Solves a system on non-linear equations"
    },
    "Determinant": {
        "scope": "cpp",
        "prefix": [
            "apoc_Determinant"
        ],
        "body": [
            "double det(vector<vector<double>>& a) {",
            "\tint n = sz(a); double res = 1;",
            "\trep(i,0,n) {",
            "\t\tint b = i;",
            "\t\trep(j,i+1,n) if (fabs(a[j][i]) > fabs(a[b][i])) b = j;",
            "\t\tif (i != b) swap(a[i], a[b]), res *= -1;",
            "\t\tres *= a[i][i];",
            "\t\tif (res == 0) return 0;",
            "\t\trep(j,i+1,n) {",
            "\t\t\tdouble v = a[j][i] / a[i][i];",
            "\t\t\tif (v != 0) rep(k,i+1,n) a[j][k] -= v * a[i][k];",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(N^3) | Calculates determinant of a matrix. Destroys the matrix."
    },
    "SolveLinearBinary": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinearBinary"
        ],
        "body": [
            "typedef bitset<1000> bs;",
            "",
            "int solveLinear(vector<bs>& A, vi& b, bs& x, int m) {",
            "\tint n = sz(A), rank = 0, br;",
            "\tassert(m <= sz(x));",
            "\tvi col(m); iota(all(col), 0);",
            "\trep(i,0,n) {",
            "\t\tfor (br=i; br<n; ++br) if (A[br].any()) break;",
            "\t\tif (br == n) {",
            "\t\t\trep(j,i,n) if(b[j]) return -1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tint bc = (int)A[br]._Find_next(i-1);",
            "\t\tswap(A[i], A[br]);",
            "\t\tswap(b[i], b[br]);",
            "\t\tswap(col[i], col[bc]);",
            "\t\trep(j,0,n) if (A[j][i] != A[j][bc]) {",
            "\t\t\tA[j].flip(i); A[j].flip(bc);",
            "\t\t}",
            "\t\trep(j,i+1,n) if (A[j][i]) {",
            "\t\t\tb[j] ^= b[i];",
            "\t\t\tA[j] ^= A[i];",
            "\t\t}",
            "\t\trank++;",
            "\t}",
            "",
            "\tx = bs();",
            "\tfor (int i = rank; i--;) {",
            "\t\tif (!b[i]) continue;",
            "\t\tx[col[i]] = 1;",
            "\t\trep(j,0,i) b[j] ^= A[j][i];",
            "\t}",
            "\treturn rank; // (multiple solutions if rank < m)",
            "}"
        ],
        "description": "O(n^2 m) | Solves Ax = b over mathbb F_2. If there are multiple solutions, one is returned arbitrarily. Returns rank, or -1 if no solutions. Destroys A and b."
    },
    "PolyInterpolate": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyInterpolate"
        ],
        "body": [
            "typedef vector<double> vd;",
            "vd interpolate(vd x, vd y, int n) {",
            "\tvd res(n), temp(n);",
            "\trep(k,0,n-1) rep(i,k+1,n)",
            "\t\ty[i] = (y[i] - y[k]) / (x[i] - x[k]);",
            "\tdouble last = 0; temp[0] = 1;",
            "\trep(k,0,n) rep(i,0,n) {",
            "\t\tres[i] += y[k] * temp[i];",
            "\t\tswap(last, temp[i]);",
            "\t\ttemp[i] -= last * x[k];",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(n^2) / | Given n points (x[i], y[i]), computes an n-1-degree polynomial p that"
    },
    "Tridiagonal": {
        "scope": "cpp",
        "prefix": [
            "apoc_Tridiagonal"
        ],
        "body": [
            "\\[",
            "\\left(\\begin{array}{c}b_0\\\\b_1\\\\b_2\\\\b_3\\\\\\vdots\\\\b_{n-1}\\end{array}\\right) =",
            "\\left(\\begin{array}{cccccc}",
            "d_0 & p_0 & 0 & 0 & \\cdots & 0\\\\",
            "q_0 & d_1 & p_1 & 0 & \\cdots & 0\\\\",
            "0 & q_1 & d_2 & p_2 & \\cdots & 0\\\\",
            "\\vdots & \\vdots & \\ddots & \\ddots & \\ddots & \\vdots\\\\",
            "0 & 0 & \\cdots & q_{n-3} & d_{n-2} & p_{n-2}\\\\",
            "0 & 0 & \\cdots & 0 & q_{n-2} & d_{n-1}\\\\",
            "\\end{array}\\right)",
            "\\left(\\begin{array}{c}x_0\\\\x_1\\\\x_2\\\\x_3\\\\\\vdots\\\\x_{n-1}\\end{array}\\right).",
            "\\]",
            "",
            "This is useful for solving problems on the type",
            "\\[ a_i=b_ia_{i-1}+c_ia_{i+1}+d_i,\\,1\\leq i\\leq n, \\]",
            "where $a_0$, $a_{n+1}$, $b_i$, $c_i$ and $d_i$ are known. $a$ can then be obtained from",
            "\\begin{align*}",
            "\\{a_i\\}=\\textrm{tridiagonal}(&\\{1,-1,-1,...,-1,1\\}, \\{0,c_1,c_2,\\dots,c_n\\},\\\\",
            "&\\{b_1,b_2,\\dots,b_n,0\\}, \\{a_0,d_1,d_2,\\dots,d_n,a_{n+1}\\}).",
            "\\end{align*}",
            "Fails if the solution is not unique.",
            "",
            "If $|d_i| > |p_i| + |q_{i-1}|$ for all $i$, or $|d_i| > |p_{i-1}| + |q_i|$, or the matrix is positive definite,",
            "the algorithm is numerically stable and neither \\texttt{tr} nor the check for \\texttt{diag[i] == 0} is needed.",
            "",
            "typedef double T;",
            "vector<T> tridiagonal(vector<T> diag, const vector<T>& super,",
            "\t\tconst vector<T>& sub, vector<T> b) {",
            "\tint n = sz(b); vi tr(n);",
            "\trep(i,0,n-1) {",
            "\t\tif (abs(diag[i]) < 1e-9 * abs(super[i])) { // diag[i] == 0",
            "\t\t\tb[i+1] -= b[i] * diag[i+1] / super[i];",
            "\t\t\tif (i+2 < n) b[i+2] -= b[i] * sub[i+1] / super[i];",
            "\t\t\tdiag[i+1] = sub[i]; tr[++i] = 1;",
            "\t\t} else {",
            "\t\t\tdiag[i+1] -= super[i]*sub[i]/diag[i];",
            "\t\t\tb[i+1] -= b[i]*sub[i]/diag[i];",
            "\t\t}",
            "\t}",
            "\tfor (int i = n; i--;) {",
            "\t\tif (tr[i]) {",
            "\t\t\tswap(b[i], b[i-1]);",
            "\t\t\tdiag[i-1] = diag[i];",
            "\t\t\tb[i] /= super[i-1];",
            "\t\t} else {",
            "\t\t\tb[i] /= diag[i];",
            "\t\t\tif (i) b[i-1] -= b[i]*super[i-1];",
            "\t\t}",
            "\t}",
            "\treturn b;",
            "}"
        ],
        "description": "O(N) | x=textrm{tridiagonal}(d,p,q,b) solves the equation system"
    },
    "JacobianMatrix": {
        "scope": "cpp",
        "prefix": [
            "apoc_JacobianMatrix"
        ],
        "body": [
            "template<class F, class T>",
            "vector<vector<T>> makeJacobian(F &f, vector<T> &x) {",
            "    int n = sz(x);",
            "    vector<vector<T>> J(n, vector<T>(n));",
            "    vector<T> fX0 = f(x);",
            "    rep(i, 0, n) {",
            "        x[i] += eps;",
            "        vector<T> fX1 = f(x);",
            "        rep(j, 0, n){",
            "            J[j][i] = (fX1[j] - fX0[j]) / eps;",
            "        }",
            "\tx[i] -= eps;",
            "    }",
            "    return J;",
            "}"
        ],
        "description": "Makes Jacobian Matrix using finite differences"
    },
    "SolveLinear": {
        "scope": "cpp",
        "prefix": [
            "apoc_SolveLinear"
        ],
        "body": [
            "typedef vector<double> vd;",
            "const double eps = 1e-12;",
            "",
            "int solveLinear(vector<vd>& A, vd& b, vd& x) {",
            "\tint n = sz(A), m = sz(x), rank = 0, br, bc;",
            "\tif (n) assert(sz(A[0]) == m);",
            "\tvi col(m); iota(all(col), 0);",
            "",
            "\trep(i,0,n) {",
            "\t\tdouble v, bv = 0;",
            "\t\trep(r,i,n) rep(c,i,m)",
            "\t\t\tif ((v = fabs(A[r][c])) > bv)",
            "\t\t\t\tbr = r, bc = c, bv = v;",
            "\t\tif (bv <= eps) {",
            "\t\t\trep(j,i,n) if (fabs(b[j]) > eps) return -1;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tswap(A[i], A[br]);",
            "\t\tswap(b[i], b[br]);",
            "\t\tswap(col[i], col[bc]);",
            "\t\trep(j,0,n) swap(A[j][i], A[j][bc]);",
            "\t\tbv = 1/A[i][i];",
            "\t\trep(j,i+1,n) {",
            "\t\t\tdouble fac = A[j][i] * bv;",
            "\t\t\tb[j] -= fac * b[i];",
            "\t\t\trep(k,i+1,m) A[j][k] -= fac*A[i][k];",
            "\t\t}",
            "\t\trank++;",
            "\t}",
            "",
            "\tx.assign(m, 0);",
            "\tfor (int i = rank; i--;) {",
            "\t\tb[i] /= A[i][i];",
            "\t\tx[col[i]] = b[i];",
            "\t\trep(j,0,i) b[j] -= A[j][i] * b[i];",
            "\t}",
            "\treturn rank; // (multiple solutions if rank < m)",
            "}"
        ],
        "description": "O(n^2 m) | Solves A * x = b. If there are multiple solutions, an arbitrary one is returned. Returns rank, or -1 if no solutions. Data in A and b is lost."
    },
    "LinearRecurrence": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinearRecurrence"
        ],
        "body": [
            "/*",
            " * Usage: linearRec({0, 1}, {1, 1}, k) // k'th Fibonacci number",
            " */",
            "const ll mod = 5; /** exclude-line */",
            "",
            "typedef vector<ll> Poly;",
            "ll linearRec(Poly S, Poly tr, ll k) {",
            "\tint n = sz(tr);",
            "",
            "\tauto combine = [&](Poly a, Poly b) {",
            "\t\tPoly res(n * 2 + 1);",
            "\t\trep(i,0,n+1) rep(j,0,n+1)",
            "\t\t\tres[i + j] = (res[i + j] + a[i] * b[j]) % mod;",
            "\t\tfor (int i = 2 * n; i > n; --i) rep(j,0,n)",
            "\t\t\tres[i - 1 - j] = (res[i - 1 - j] + res[i] * tr[j]) % mod;",
            "\t\tres.resize(n + 1);",
            "\t\treturn res;",
            "\t};",
            "",
            "\tPoly pol(n + 1), e(pol);",
            "\tpol[0] = e[1] = 1;",
            "",
            "\tfor (++k; k; k /= 2) {",
            "\t\tif (k % 2) pol = combine(pol, e);",
            "\t\te = combine(e, e);",
            "\t}",
            "",
            "\tll res = 0;",
            "\trep(i,0,n) res = (res + pol[i + 1] * S[i]) % mod;",
            "\treturn res;",
            "}"
        ],
        "description": "O(n^2 \\log k) | Generates the k'th term of an n-order linear recurrence S[i] = sum_j S[i-j-1]tr[j], given S[0 \\ldots \\ge n-1] and tr[0 \\ldots n-1]. Faster than matrix multiplication. Useful together with Berlekamp--Massey."
    },
    "IntegrateAdaptive": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntegrateAdaptive"
        ],
        "body": [
            "/*",
            " * Usage: ",
            "\tdouble sphereVolume = quad(-1, 1, [](double x) {",
            "\treturn quad(-1, 1, [\\&](double y) {",
            "\treturn quad(-1, 1, [\\&](double z) {",
            "\treturn x*x + y*y + z*z < 1; });});});",
            " */",
            "typedef double d;",
            "#define S(a,b) (f(a) + 4*f((a+b) / 2) + f(b)) * (b-a) / 6",
            "",
            "template <class F>",
            "d rec(F& f, d a, d b, d eps, d S) {",
            "\td c = (a + b) / 2;",
            "\td S1 = S(a, c), S2 = S(c, b), T = S1 + S2;",
            "\tif (abs(T - S) <= 15 * eps || b - a < 1e-10)",
            "\t\treturn T + (T - S) / 15;",
            "\treturn rec(f, a, c, eps / 2, S1) + rec(f, c, b, eps / 2, S2);",
            "}",
            "template<class F>",
            "d quad(d a, d b, F f, d eps = 1e-8) {",
            "\treturn rec(f, a, b, eps, S(a, b));",
            "}"
        ],
        "description": "Fast integration using an adaptive Simpson's rule."
    },
    "FastSubsetTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastSubsetTransform"
        ],
        "body": [
            "void FST(vi& a, bool inv) {",
            "\tfor (int n = sz(a), step = 1; step < n; step *= 2) {",
            "\t\tfor (int i = 0; i < n; i += 2 * step) rep(j,i,i+step) {",
            "\t\t\tint &u = a[j], &v = a[j + step]; tie(u, v) =",
            "\t\t\t\tinv ? pii(v - u, u) : pii(v, u + v); // AND",
            "\t\t\t\t// inv ? pii(v, u - v) : pii(u + v, u); // OR /// include-line",
            "\t\t\t\t// pii(u + v, u - v);                   // XOR /// include-line",
            "\t\t}",
            "\t}",
            "\t// if (inv) for (int& x : a) x /= sz(a); // XOR only /// include-line",
            "}",
            "vi conv(vi a, vi b) {",
            "\tFST(a, 0); FST(b, 0);",
            "\trep(i,0,sz(a)) a[i] *= b[i];",
            "\tFST(a, 1); return a;",
            "}"
        ],
        "description": "O(N \\log N) | Transform to a basis with fast convolutions of the form displaystyle c[z] = sumnolimits_{z = x oplus y} a[x] cdot b[y], where oplus is one of AND, OR, XOR. The size of a must be a power of two."
    },
    "RungeKutta4": {
        "scope": "cpp",
        "prefix": [
            "apoc_RungeKutta4"
        ],
        "body": [
            "template<class F, class T>",
            "T solveSystem(F f, T x, ld time, int iters) {",
            "    double h = time / iters;",
            "    for(int iter = 0; iter < iters; iter++) {",
            "        T k1 = f(x);",
            "        A k2 = f(x + 0.5 * h * k1);",
            "        A k3 = f(x + 0.5 * h * k2);",
            "        A k4 = f(x + h * k3);",
            "        x = x + h / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4);",
            "    }",
            "    return x;",
            "}"
        ],
        "description": "Numerically approximates the solution to a system of Differential Equations"
    },
    "NumberTheoreticTransform": {
        "scope": "cpp",
        "prefix": [
            "apoc_NumberTheoreticTransform"
        ],
        "body": [
            "   \\texttt{conv(a, b) = c}, where $c[x] = \\sum a[i]b[x-i]$.",
            "   For manual convolution: NTT the inputs, multiply",
            "   pointwise, divide by n, reverse(start+1, end), NTT back.",
            "",
            "",
            "const ll mod = (119 << 23) + 1, root = 62; // = 998244353",
            "// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21",
            "// and 483 << 21 (same root). The last two are > 10^9.",
            "typedef vector<ll> vl;",
            "void ntt(vl &a) {",
            "\tint n = sz(a), L = 31 - __builtin_clz(n);",
            "\tstatic vl rt(2, 1);",
            "\tfor (static int k = 2, s = 2; k < n; k *= 2, s++) {",
            "\t\trt.resize(n);",
            "\t\tll z[] = {1, modpow(root, mod >> s)};",
            "\t\trep(i,k,2*k) rt[i] = rt[i / 2] * z[i & 1] % mod;",
            "\t}",
            "\tvi rev(n);",
            "\trep(i,0,n) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;",
            "\trep(i,0,n) if (i < rev[i]) swap(a[i], a[rev[i]]);",
            "\tfor (int k = 1; k < n; k *= 2)",
            "\t\tfor (int i = 0; i < n; i += 2 * k) rep(j,0,k) {",
            "\t\t\tll z = rt[j + k] * a[i + j + k] % mod, &ai = a[i + j];",
            "\t\t\ta[i + j + k] = ai - z + (z > ai ? mod : 0);",
            "\t\t\tai += (ai + z >= mod ? z - mod : z);",
            "\t\t}",
            "}",
            "vl conv(const vl &a, const vl &b) {",
            "\tif (a.empty() || b.empty()) return {};",
            "\tint s = sz(a) + sz(b) - 1, B = 32 - __builtin_clz(s), n = 1 << B;",
            "\tint inv = modpow(n, mod - 2);",
            "\tvl L(a), R(b), out(n);",
            "\tL.resize(n), R.resize(n);",
            "\tntt(L), ntt(R);",
            "\trep(i,0,n) out[-i & (n - 1)] = (ll)L[i] * R[i] % mod * inv % mod;",
            "\tntt(out);",
            "\treturn {out.begin(), out.begin() + s};",
            "}"
        ],
        "description": "O(N \\log N) | ntt(a) computes hat f(k) = sum_x a[x] g^{xk} for all k, where g=text{root}^{(mod-1)/N}. N must be a power of 2. Useful for convolution modulo specific nice primes of the form 2^a b+1, where the convolution result has size at most 2^a. For arbitrary modulo, see FFTMod."
    },
    "MatrixInverse": {
        "scope": "cpp",
        "prefix": [
            "apoc_MatrixInverse"
        ],
        "body": [
            "int matInv(vector<vector<double>>& A) {",
            "\tint n = sz(A); vi col(n);",
            "\tvector<vector<double>> tmp(n, vector<double>(n));",
            "\trep(i,0,n) tmp[i][i] = 1, col[i] = i;",
            "",
            "\trep(i,0,n) {",
            "\t\tint r = i, c = i;",
            "\t\trep(j,i,n) rep(k,i,n)",
            "\t\t\tif (fabs(A[j][k]) > fabs(A[r][c]))",
            "\t\t\t\tr = j, c = k;",
            "\t\tif (fabs(A[r][c]) < 1e-12) return i;",
            "\t\tA[i].swap(A[r]); tmp[i].swap(tmp[r]);",
            "\t\trep(j,0,n)",
            "\t\t\tswap(A[j][i], A[j][c]), swap(tmp[j][i], tmp[j][c]);",
            "\t\tswap(col[i], col[c]);",
            "\t\tdouble v = A[i][i];",
            "\t\trep(j,i+1,n) {",
            "\t\t\tdouble f = A[j][i] / v;",
            "\t\t\tA[j][i] = 0;",
            "\t\t\trep(k,i+1,n) A[j][k] -= f*A[i][k];",
            "\t\t\trep(k,0,n) tmp[j][k] -= f*tmp[i][k];",
            "\t\t}",
            "\t\trep(j,i+1,n) A[i][j] /= v;",
            "\t\trep(j,0,n) tmp[i][j] /= v;",
            "\t\tA[i][i] = 1;",
            "\t}",
            "",
            "\t/// forget A at this point, just eliminate tmp backward",
            "\tfor (int i = n-1; i > 0; --i) rep(j,0,i) {",
            "\t\tdouble v = A[j][i];",
            "\t\trep(k,0,n) tmp[j][k] -= v*tmp[i][k];",
            "\t}",
            "",
            "\trep(i,0,n) rep(j,0,n) A[col[i]][col[j]] = tmp[i][j];",
            "\treturn n;",
            "}"
        ],
        "description": "O(n^3) | Invert matrix A. Returns rank; result is stored in A unless singular (rank < n). Can easily be extended to prime moduli; for prime powers, repeatedly set A^{-1} = A^{-1} (2I - AA^{-1})  (text{mod }p^k) where A^{-1} starts as the inverse of A mod p, and k is doubled in each step."
    },
    "Unrolling": {
        "scope": "cpp",
        "prefix": [
            "apoc_Unrolling"
        ],
        "body": [
            "#define F {...; ++i;}",
            "int i = from;",
            "while (i&3 && i < to) F // for alignment, if needed",
            "while (i + 4 <= to) { F F F F }",
            "while (i < to) F"
        ],
        "description": " /"
    },
    "SmallPtr": {
        "scope": "cpp",
        "prefix": [
            "apoc_SmallPtr"
        ],
        "body": [
            "template<class T> struct ptr {",
            "\tunsigned ind;",
            "\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {",
            "\t\tassert(ind < sizeof buf);",
            "\t}",
            "\tT& operator*() const { return *(T*)(buf + ind); }",
            "\tT* operator->() const { return &**this; }",
            "\tT& operator[](int a) const { return (&**this)[a]; }",
            "\texplicit operator bool() const { return ind; }",
            "};"
        ],
        "description": "A 32-bit pointer that points into BumpAllocator memory."
    },
    "FastKnapsack": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastKnapsack"
        ],
        "body": [
            "int knapsack(vi w, int t) {",
            "\tint a = 0, b = 0, x;",
            "\twhile (b < sz(w) && a + w[b] <= t) a += w[b++];",
            "\tif (b == sz(w)) return a;",
            "\tint m = *max_element(all(w));",
            "\tvi u, v(2*m, -1);",
            "\tv[a+m-t] = b;",
            "\trep(i,b,sz(w)) {",
            "\t\tu = v;",
            "\t\trep(x,0,m) v[x+w[i]] = max(v[x+w[i]], u[x]);",
            "\t\tfor (x = 2*m; --x > m;) rep(j, max(0,u[x]), v[x])",
            "\t\t\tv[x-w[j]] = max(v[x-w[j]], j);",
            "\t}",
            "\tfor (a = t; v[a+m-t] < 0; a--) ;",
            "\treturn a;",
            "}"
        ],
        "description": "O(N max(w_i)) | Given N non-negative integer weights w and a non-negative target t, computes the maximum S <= t such that S is the sum of some subset of the weights."
    },
    "KnuthDP": {
        "scope": "cpp",
        "prefix": [
            "apoc_KnuthDP"
        ],
        "body": [],
        "description": "O(N^2) / | "
    },
    "BumpAllocatorSTL": {
        "scope": "cpp",
        "prefix": [
            "apoc_BumpAllocatorSTL"
        ],
        "body": [
            "/*",
            " * Usage: vector<vector<int, small<int>>> ed(N);",
            " */",
            "char buf[450 << 20] alignas(16);",
            "size_t buf_ind = sizeof buf;",
            "",
            "template<class T> struct small {",
            "\ttypedef T value_type;",
            "\tsmall() {}",
            "\ttemplate<class U> small(const U&) {}",
            "\tT* allocate(size_t n) {",
            "\t\tbuf_ind -= n * sizeof(T);",
            "\t\tbuf_ind &= 0 - alignof(T);",
            "\t\treturn (T*)(buf + buf_ind);",
            "\t}",
            "\tvoid deallocate(T*, size_t) {}",
            "};"
        ],
        "description": "BumpAllocator for STL containers."
    },
    "IntervalContainer": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntervalContainer"
        ],
        "body": [
            "set<pii>::iterator addInterval(set<pii>& is, int L, int R) {",
            "\tif (L == R) return is.end();",
            "\tauto it = is.lower_bound({L, R}), before = it;",
            "\twhile (it != is.end() && it->first <= R) {",
            "\t\tR = max(R, it->second);",
            "\t\tbefore = it = is.erase(it);",
            "\t}",
            "\tif (it != is.begin() && (--it)->second >= L) {",
            "\t\tL = min(L, it->first);",
            "\t\tR = max(R, it->second);",
            "\t\tis.erase(it);",
            "\t}",
            "\treturn is.insert(before, {L,R});",
            "}",
            "",
            "void removeInterval(set<pii>& is, int L, int R) {",
            "\tif (L == R) return;",
            "\tauto it = addInterval(is, L, R);",
            "\tauto r2 = it->second;",
            "\tif (it->first == L) is.erase(it);",
            "\telse (int&)it->second = L;",
            "\tif (R != r2) is.emplace(R, r2);",
            "}"
        ],
        "description": "O(\\log N) | Add and remove intervals from a set of disjoint intervals. Will merge the added interval with any overlapping intervals in the set when adding. Intervals are [inclusive, exclusive)."
    },
    "FastInput": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastInput"
        ],
        "body": [
            "/*",
            " * Usage: ./a.out < input.txt",
            " */",
            "inline char gc() { // like getchar()",
            "\tstatic char buf[1 << 16];",
            "\tstatic size_t bc, be;",
            "\tif (bc >= be) {",
            "\t\tbuf[0] = 0, bc = 0;",
            "\t\tbe = fread(buf, 1, sizeof(buf), stdin);",
            "\t}",
            "\treturn buf[bc++]; // returns 0 on EOF",
            "}",
            "",
            "int readInt() {",
            "\tint a, c;",
            "\twhile ((a = gc()) < 40);",
            "\tif (a == '-') return -readInt();",
            "\twhile ((c = gc()) >= 48) a = a * 10 + c - 480;",
            "\treturn a - 48;",
            "}"
        ],
        "description": "About 5x as fast as cin/scanf. | Read an integer from stdin. Usage requires your program to pipe in input from file."
    },
    "BumpAllocator": {
        "scope": "cpp",
        "prefix": [
            "apoc_BumpAllocator"
        ],
        "body": [
            "// Either globally or in a single class:",
            "static char buf[450 << 20];",
            "void* operator new(size_t s) {",
            "\tstatic size_t i = sizeof buf;",
            "\tassert(s < i);",
            "\treturn (void*)&buf[i -= s];",
            "}",
            "void operator delete(void*) {}"
        ],
        "description": "When you need to dynamically allocate many objects and don't care about freeing them. \"new X\" otherwise has an overhead of something like 0.05us + 16 bytes per allocation."
    },
    "ConstantIntervals": {
        "scope": "cpp",
        "prefix": [
            "apoc_ConstantIntervals"
        ],
        "body": [
            "/*",
            " * Usage: constantIntervals(0, sz(v), [\\&](int x){return v[x];}, [\\&](int lo, int hi, T val){...});",
            " */",
            "template<class F, class G, class T>",
            "void rec(int from, int to, F& f, G& g, int& i, T& p, T q) {",
            "\tif (p == q) return;",
            "\tif (from == to) {",
            "\t\tg(i, to, p);",
            "\t\ti = to; p = q;",
            "\t} else {",
            "\t\tint mid = (from + to) >> 1;",
            "\t\trec(from, mid, f, g, i, p, f(mid));",
            "\t\trec(mid+1, to, f, g, i, p, q);",
            "\t}",
            "}",
            "template<class F, class G>",
            "void constantIntervals(int from, int to, F f, G g) {",
            "\tif (to <= from) return;",
            "\tint i = from; auto p = f(i), q = f(to-1);",
            "\trec(from, to-1, f, g, i, p, q);",
            "\tg(i, to, q);",
            "}"
        ],
        "description": "O(k\\logfrac{n}{k}) | Split a monotone function on [from, to) into a minimal set of half-open intervals on which it has the same value. Runs a callback g for each such interval."
    },
    "SIMD": {
        "scope": "cpp",
        "prefix": [
            "apoc_SIMD"
        ],
        "body": [
            "typedef __m256i mi;",
            "#define L(x) _mm256_loadu_si256((mi*)&(x))",
            "",
            "// High-level/specific methods:",
            "// load(u)?_si256, store(u)?_si256, setzero_si256, _mm_malloc",
            "// blendv_(epi8|ps|pd) (z?y:x), movemask_epi8 (hibits of bytes)",
            "// i32gather_epi32(addr, x, 4): map addr[] over 32-b parts of x",
            "// sad_epu8: sum of absolute differences of u8, outputs 4xi64",
            "// maddubs_epi16: dot product of unsigned i7's, outputs 16xi15",
            "// madd_epi16: dot product of signed i16's, outputs 8xi32",
            "// extractf128_si256(, i) (256->128), cvtsi128_si32 (128->lo32)",
            "// permute2f128_si256(x,x,1) swaps 128-bit lanes",
            "// shuffle_epi32(x, 3*64+2*16+1*4+0) == x for each lane",
            "// shuffle_epi8(x, y) takes a vector instead of an imm",
            "",
            "// Methods that work with most data types (append e.g. _epi32):",
            "// set1, blend (i8?x:y), add, adds (sat.), mullo, sub, and/or,",
            "// andnot, abs, min, max, sign(1,x), cmp(gt|eq), unpack(lo|hi)",
            "",
            "int sumi32(mi m) { union {int v[8]; mi m;} u; u.m = m;",
            "\tint ret = 0; rep(i,0,8) ret += u.v[i]; return ret; }",
            "mi zero() { return _mm256_setzero_si256(); }",
            "mi one() { return _mm256_set1_epi32(-1); }",
            "bool all_zero(mi m) { return _mm256_testz_si256(m, m); }",
            "bool all_one(mi m) { return _mm256_testc_si256(m, one()); }",
            "",
            "ll example_filteredDotProduct(int n, short* a, short* b) {",
            "\tint i = 0; ll r = 0;",
            "\tmi zero = _mm256_setzero_si256(), acc = zero;",
            "\twhile (i + 16 <= n) {",
            "\t\tmi va = L(a[i]), vb = L(b[i]); i += 16;",
            "\t\tva = _mm256_and_si256(_mm256_cmpgt_epi16(vb, va), va);",
            "\t\tmi vp = _mm256_madd_epi16(va, vb);",
            "\t\tacc = _mm256_add_epi64(_mm256_unpacklo_epi32(vp, zero),",
            "\t\t\t_mm256_add_epi64(acc, _mm256_unpackhi_epi32(vp, zero)));",
            "\t}",
            "\tunion {ll v[4]; mi m;} u; u.m = acc; rep(i,0,4) r += u.v[i];",
            "\tfor (;i<n;++i) if (a[i] < b[i]) r += a[i]*b[i]; // <- equiv",
            "\treturn r;",
            "}"
        ],
        "description": "Cheat sheet of SSE/AVX intrinsics, for doing arithmetic on several numbers at once. Can provide a constant factor improvement of about 4, orthogonal to loop unrolling. Operations follow the pattern texttt{\"_mm(256)?_name_(si(128|256)|epi(8|16|32|64)|pd|ps)\"}. Not all are described here; grep for texttt{_mm_} in texttt{/usr/lib/gcc/{ If AVX is unsupported, try 128-bit operations, \"emmintrin.h\" and #define texttt{__SSE__} and texttt{__MMX__} before including it. For aligned memory use texttt{_mm_malloc(size, 32)} or texttt{int buf[N] alignas(32)}, but prefer loadu/storeu. /"
    },
    "FastMod": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastMod"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "struct FastMod {",
            "\tull b, m;",
            "\tFastMod(ull b) : b(b), m(-1ULL / b) {}",
            "\tull reduce(ull a) { // a % b + (0 or b)",
            "\t\treturn a - (ull)((__uint128_t(m) * a) >> 64) * b;",
            "\t}",
            "};"
        ],
        "description": "Compute a % b about 5 times faster than usual, where b is constant but not known at compile time. Returns a value congruent to a pmod b in the range [0, 2b)."
    },
    "IntervalCover": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntervalCover"
        ],
        "body": [
            "template<class T>",
            "vi cover(pair<T, T> G, vector<pair<T, T>> I) {",
            "\tvi S(sz(I)), R;",
            "\tiota(all(S), 0);",
            "\tsort(all(S), [&](int a, int b) { return I[a] < I[b]; });",
            "\tT cur = G.first;",
            "\tint at = 0;",
            "\twhile (cur < G.second) { // (A)",
            "\t\tpair<T, int> mx = make_pair(cur, -1);",
            "\t\twhile (at < sz(I) && I[S[at]].first <= cur) {",
            "\t\t\tmx = max(mx, make_pair(I[S[at]].second, S[at]));",
            "\t\t\tat++;",
            "\t\t}",
            "\t\tif (mx.second == -1) return {};",
            "\t\tcur = mx.first;",
            "\t\tR.push_back(mx.second);",
            "\t}",
            "\treturn R;",
            "}"
        ],
        "description": "O(N \\log N) | Compute indices of smallest set of intervals covering another interval. Intervals should be [inclusive, exclusive). To support [inclusive, inclusive], change (A) to add texttt{|| R.empty()}. Returns empty set on failure (or if G is empty)."
    },
    "LIS": {
        "scope": "cpp",
        "prefix": [
            "apoc_LIS"
        ],
        "body": [
            "template<class I> vi lis(const vector<I>& S) {",
            "\tif (S.empty()) return {};",
            "\tvi prev(sz(S));",
            "\ttypedef pair<I, int> p;",
            "\tvector<p> res;",
            "\trep(i,0,sz(S)) {",
            "\t\t// change 0 -> i for longest non-decreasing subsequence",
            "\t\tauto it = lower_bound(all(res), p{S[i], 0});",
            "\t\tif (it == res.end()) res.emplace_back(), it = res.end()-1;",
            "\t\t*it = {S[i], i};",
            "\t\tprev[i] = it == res.begin() ? 0 : (it-1)->second;",
            "\t}",
            "\tint L = sz(res), cur = res.back().second;",
            "\tvi ans(L);",
            "\twhile (L--) ans[L] = cur, cur = prev[cur];",
            "\treturn ans;",
            "}"
        ],
        "description": "O(N \\log N) | Compute indices for the longest increasing subsequence."
    },
    "DivideAndConquerDP": {
        "scope": "cpp",
        "prefix": [
            "apoc_DivideAndConquerDP"
        ],
        "body": [
            "struct DP { // Modify at will:",
            "\tint lo(int ind) { return 0; }",
            "\tint hi(int ind) { return ind; }",
            "\tll f(int ind, int k) { return dp[ind][k]; }",
            "\tvoid store(int ind, int k, ll v) { res[ind] = pii(k, v); }",
            "",
            "\tvoid rec(int L, int R, int LO, int HI) {",
            "\t\tif (L >= R) return;",
            "\t\tint mid = (L + R) >> 1;",
            "\t\tpair<ll, int> best(LLONG_MAX, LO);",
            "\t\trep(k, max(LO,lo(mid)), min(HI,hi(mid)))",
            "\t\t\tbest = min(best, make_pair(f(mid, k), k));",
            "\t\tstore(mid, best.second, best.first);",
            "\t\trec(L, mid, LO, best.second+1);",
            "\t\trec(mid+1, R, best.second, HI);",
            "\t}",
            "\tvoid solve(int L, int R) { rec(L, R, INT_MIN, INT_MAX); }",
            "};"
        ],
        "description": "O((N + (hi-lo)) \\log N) | Given a[i] = min_{lo(i) \\le k < hi(i)}(f(i, k)) where the (minimal) optimal k increases with i, computes a[i] for i = L..R-1."
    },
    "TernarySearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_TernarySearch"
        ],
        "body": [
            "/*",
            " * Usage: ",
            "\tint ind = ternSearch(0,n-1,[\\&](int i){return a[i];});",
            " */",
            "template<class F>",
            "int ternSearch(int a, int b, F f) {",
            "\tassert(a <= b);",
            "\twhile (b - a >= 5) {",
            "\t\tint mid = (a + b) / 2;",
            "\t\tif (f(mid) < f(mid+1)) a = mid; // (A)",
            "\t\telse b = mid+1;",
            "\t}",
            "\trep(i,a+1,b+1) if (f(a) < f(i)) a = i; // (B)",
            "\treturn a;",
            "}"
        ],
        "description": "O(\\log(b-a)) |  Find the smallest i in [a,b] that maximizes f(i), assuming that f(a) < dots < f(i) \\ge dots \\ge f(b). To reverse which of the sides allows non-strict inequalities, change the < marked with (A) to <=, and reverse the loop at (B). To minimize f, change it to >, also at (B)."
    },
    "FastEratosthenes": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastEratosthenes"
        ],
        "body": [
            "const int LIM = 1e6;",
            "bitset<LIM> isPrime;",
            "vi eratosthenes() {",
            "\tconst int S = (int)round(sqrt(LIM)), R = LIM / 2;",
            "\tvi pr = {2}, sieve(S+1); pr.reserve(int(LIM/log(LIM)*1.1));",
            "\tvector<pii> cp;",
            "\tfor (int i = 3; i <= S; i += 2) if (!sieve[i]) {",
            "\t\tcp.push_back({i, i * i / 2});",
            "\t\tfor (int j = i * i; j <= S; j += 2 * i) sieve[j] = 1;",
            "\t}",
            "\tfor (int L = 1; L <= R; L += S) {",
            "\t\tarray<bool, S> block{};",
            "\t\tfor (auto &[p, idx] : cp)",
            "\t\t\tfor (int i=idx; i < S+L; idx = (i+=p)) block[i-L] = 1;",
            "\t\trep(i,0,min(S, R - L))",
            "\t\t\tif (!block[i]) pr.push_back((L + i) * 2 + 1);",
            "\t}",
            "\tfor (int i : pr) isPrime[i] = 1;",
            "\treturn pr;",
            "}"
        ],
        "description": "LIM=1e9 approx 1.5s | Prime sieve for generating all primes smaller than LIM."
    },
    "ModPow": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModPow"
        ],
        "body": [
            "const ll mod = 1000000007; // faster if const",
            "",
            "ll modpow(ll b, ll e) {",
            "\tll ans = 1;",
            "\tfor (; e; b = b * b % mod, e /= 2)",
            "\t\tif (e & 1) ans = ans * b % mod;",
            "\treturn ans;",
            "}"
        ],
        "description": ""
    },
    "ModSqrt": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModSqrt"
        ],
        "body": [
            "ll sqrt(ll a, ll p) {",
            "\ta %= p; if (a < 0) a += p;",
            "\tif (a == 0) return 0;",
            "\tassert(modpow(a, (p-1)/2, p) == 1); // else no solution",
            "\tif (p % 4 == 3) return modpow(a, (p+1)/4, p);",
            "\t// a^(n+3)/8 or 2^(n+3)/8 * 2^(n-1)/4 works if p % 8 == 5",
            "\tll s = p - 1, n = 2;",
            "\tint r = 0, m;",
            "\twhile (s % 2 == 0)",
            "\t\t++r, s /= 2;",
            "\t/// find a non-square mod p",
            "\twhile (modpow(n, (p - 1) / 2, p) != p - 1) ++n;",
            "\tll x = modpow(a, (s + 1) / 2, p);",
            "\tll b = modpow(a, s, p), g = modpow(n, s, p);",
            "\tfor (;; r = m) {",
            "\t\tll t = b;",
            "\t\tfor (m = 0; m < r && t != 1; ++m)",
            "\t\t\tt = t * t % p;",
            "\t\tif (m == 0) return x;",
            "\t\tll gs = modpow(g, 1LL << (r - m - 1), p);",
            "\t\tg = gs * gs % p;",
            "\t\tx = x * gs % p;",
            "\t\tb = b * g % p;",
            "\t}",
            "}"
        ],
        "description": "O(\\log^2 p) worst case, O(\\log p) for most p | Tonelli-Shanks algorithm for modular square roots. Finds x s.t. x^2 = a pmod p (-x gives the other solution)."
    },
    "ModSum": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModSum"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull sumsq(ull to) { return to / 2 * ((to-1) | 1); }",
            "/// ^ written in a weird way to deal with overflows correctly",
            "",
            "ull divsum(ull to, ull c, ull k, ull m) {",
            "\tull res = k / m * sumsq(to) + c / m * to;",
            "\tk %= m; c %= m;",
            "\tif (!k) return res;",
            "\tull to2 = (to * k + c) / m;",
            "\treturn res + (to - 1) * to2 - divsum(to2, m-1 - c, m, k);",
            "}",
            "",
            "ll modsum(ull to, ll c, ll k, ll m) {",
            "\tc = ((c % m) + m) % m;",
            "\tk = ((k % m) + m) % m;",
            "\treturn to * c + k * sumsq(to) - m * divsum(to, c, k, m);",
            "}"
        ],
        "description": "\\log(m), with a large constant. | Sums of mod'ed arithmetic progressions.  texttt{modsum(to, c, k, m)} = sum_{i=0}^{mathrm{to}-1}{(ki+c) % m}. texttt{divsum} is similar but for floored division."
    },
    "ModLog": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModLog"
        ],
        "body": [
            "ll modLog(ll a, ll b, ll m) {",
            "\tll n = (ll) sqrt(m) + 1, e = 1, f = 1, j = 1;",
            "\tunordered_map<ll, ll> A;",
            "\twhile (j <= n && (e = f = e * a % m) != b % m)",
            "\t\tA[e * b % m] = j++;",
            "\tif (e == b % m) return j;",
            "\tif (__gcd(m, e) == __gcd(m, b))",
            "\t\trep(i,2,n+2) if (A.count(e = e * f % m))",
            "\t\t\treturn n * i - A[e];",
            "\treturn -1;",
            "}"
        ],
        "description": "O(sqrt m) | Returns the smallest x > 0 s.t. a^x = b pmod m, or -1 if no such x exists. modLog(a,1,m) can be used to calculate the order of a."
    },
    "MillerRabin": {
        "scope": "cpp",
        "prefix": [
            "apoc_MillerRabin"
        ],
        "body": [
            "bool isPrime(ull n) {",
            "\tif (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "\tull A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},",
            "\t    s = __builtin_ctzll(n-1), d = n >> s;",
            "\tfor (ull a : A) {   // ^ count trailing zeroes",
            "\t\tull p = modpow(a%n, d, n), i = s;",
            "\t\twhile (p != 1 && p != n - 1 && a % n && i--)",
            "\t\t\tp = modmul(p, p, n);",
            "\t\tif (p != n-1 && i != s) return 0;",
            "\t}",
            "\treturn 1;",
            "}"
        ],
        "description": "7 times the complexity of a^b mod c. | Deterministic Miller-Rabin primality test. Guaranteed to work for numbers up to 7 cdot 10^{18}; for larger numbers, use Python and extend A randomly."
    },
    "Factor": {
        "scope": "cpp",
        "prefix": [
            "apoc_Factor"
        ],
        "body": [
            "ull pollard(ull n) {",
            "\tauto f = [n](ull x) { return modmul(x, x, n) + 1; };",
            "\tull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
            "\twhile (t++ % 40 || __gcd(prd, n) == 1) {",
            "\t\tif (x == y) x = ++i, y = f(x);",
            "\t\tif ((q = modmul(prd, max(x,y) - min(x,y), n))) prd = q;",
            "\t\tx = f(x), y = f(f(y));",
            "\t}",
            "\treturn __gcd(prd, n);",
            "}",
            "vector<ull> factor(ull n) {",
            "\tif (n == 1) return {};",
            "\tif (isPrime(n)) return {n};",
            "\tull x = pollard(n);",
            "\tauto l = factor(x), r = factor(n / x);",
            "\tl.insert(l.end(), all(r));",
            "\treturn l;",
            "}"
        ],
        "description": "O(n^{1/4}), less for numbers with small factors. | Pollard-rho randomized factorization algorithm. Returns prime factors of a number, in arbitrary order (e.g. 2299 -> {11, 19, 11})."
    },
    "euclid": {
        "scope": "cpp",
        "prefix": [
            "apoc_euclid"
        ],
        "body": [
            "ll euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (!b) return x = 1, y = 0, a;",
            "\tll d = euclid(b, a % b, y, x);",
            "\treturn y -= a/b * x, d;",
            "}"
        ],
        "description": "Finds two integers x and y, such that ax+by=\\gcd(a,b). If you just need gcd, use the built in texttt{__gcd} instead. If a and b are coprime, then x is the inverse of a pmod{b}. /"
    },
    "ModMulLL": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModMulLL"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "\tll ret = a * b - M * ull(1.L / M * a * b);",
            "\treturn ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "\tull ans = 1;",
            "\tfor (; e; b = modmul(b, b, mod), e /= 2)",
            "\t\tif (e & 1) ans = modmul(ans, b, mod);",
            "\treturn ans;",
            "}"
        ],
        "description": "O(1) for texttt{modmul}, O(\\log b) for texttt{modpow} | Calculate acdot bbmod c (or a^b bmod c) for 0 \\le a, b \\le c \\le 7.2cdot 10^{18}."
    },
    "Eratosthenes": {
        "scope": "cpp",
        "prefix": [
            "apoc_Eratosthenes"
        ],
        "body": [
            "const int MAX_PR = 5'000'000;",
            "bitset<MAX_PR> isprime;",
            "vi eratosthenesSieve(int lim) {",
            "\tisprime.set(); isprime[0] = isprime[1] = 0;",
            "\tfor (int i = 4; i < lim; i += 2) isprime[i] = 0;",
            "\tfor (int i = 3; i*i < lim; i += 2) if (isprime[i])",
            "\t\tfor (int j = i*i; j < lim; j += i*2) isprime[j] = 0;",
            "\tvi pr;",
            "\trep(i,2,lim) if (isprime[i]) pr.push_back(i);",
            "\treturn pr;",
            "}"
        ],
        "description": "lim=100'000'000 approx 0.8 s. Runs 30% faster if only odd indices are stored. | Prime sieve for generating all primes up to a certain limit. isprime[i] is true iff i is a prime."
    },
    "phiFunction": {
        "scope": "cpp",
        "prefix": [
            "apoc_phiFunction"
        ],
        "body": [
            "const int LIM = 5000000;",
            "int phi[LIM];",
            "",
            "void calculatePhi() {",
            "\trep(i,0,LIM) phi[i] = i&1 ? i : i/2;",
            "\tfor (int i = 3; i < LIM; i += 2) if(phi[i] == i)",
            "\t\tfor (int j = i; j < LIM; j += i) phi[j] -= phi[j] / i;",
            "}"
        ],
        "description": ""
    },
    "ContinuedFractions": {
        "scope": "cpp",
        "prefix": [
            "apoc_ContinuedFractions"
        ],
        "body": [
            "typedef double d; // for N ~ 1e7; long double for N ~ 1e9",
            "pair<ll, ll> approximate(d x, ll N) {",
            "\tll LP = 0, LQ = 1, P = 1, Q = 0, inf = LLONG_MAX; d y = x;",
            "\tfor (;;) {",
            "\t\tll lim = min(P ? (N-LP) / P : inf, Q ? (N-LQ) / Q : inf),",
            "\t\t   a = (ll)floor(y), b = min(a, lim),",
            "\t\t   NP = b*P + LP, NQ = b*Q + LQ;",
            "\t\tif (a > b) {",
            "\t\t\t// If b > a/2, we have a semi-convergent that gives us a",
            "\t\t\t// better approximation; if b = a/2, we *may* have one.",
            "\t\t\t// Return {P, Q} here for a more canonical approximation.",
            "\t\t\treturn (abs(x - (d)NP / (d)NQ) < abs(x - (d)P / (d)Q)) ?",
            "\t\t\t\tmake_pair(NP, NQ) : make_pair(P, Q);",
            "\t\t}",
            "\t\tif (abs(y = 1/(y - (d)a)) > 3*N) {",
            "\t\t\treturn {NP, NQ};",
            "\t\t}",
            "\t\tLP = P; P = NP;",
            "\t\tLQ = Q; Q = NQ;",
            "\t}",
            "}"
        ],
        "description": "O(\\log N) | Given N and a real number x \\ge 0, finds the closest rational approximation p/q with p, q \\le N. It will obey |p/q - x| \\le 1/qN.  For consecutive convergents, p_{k+1}q_k - q_{k+1}p_k = (-1)^k. (p_k/q_k alternates between >x and <x.) If x is rational, y eventually becomes infty; if x is the root of a degree 2 polynomial the a's eventually become cyclic."
    },
    "GetFactors": {
        "scope": "cpp",
        "prefix": [
            "apoc_GetFactors"
        ],
        "body": [
            "void getFactors(auto &pF, auto &primes, auto &factors, int i = 0, int n = 1) {",
            "    if(i == sz(pF)) {",
            "        factors.push_back(n);",
            "        return;",
            "    }",
            "",
            "    for(int j = 0, pow = 1; i <= pF[j]; j++, pow *= primes[j])",
            "        getFactors(pF, primes, factors, i+1, n * pow);",
            "}"
        ],
        "description": "O(sqrt[3]{N}) | Gets all factors of a number N given the prime factorization of the number."
    },
    "CRT": {
        "scope": "cpp",
        "prefix": [
            "apoc_CRT"
        ],
        "body": [
            "ll crt(ll a, ll m, ll b, ll n) {",
            "\tif (n > m) swap(a, b), swap(m, n);",
            "\tll x, y, g = euclid(m, n, x, y);",
            "\tassert((a - b) % g == 0); // else no solution",
            "\tx = (b - a) % n * x % n / g * m + a;",
            "\treturn x < 0 ? x + m*n/g : x;",
            "}"
        ],
        "description": "\\log(n) | Chinese Remainder Theorem.  texttt{crt(a, m, b, n)} computes x such that x\\equiv a pmod m, x\\equiv b pmod n. If |a| < m and |b| < n, x will obey 0 \\le x < text{lcm}(m, n). Assumes mn < 2^{62}."
    },
    "FracBinarySearch": {
        "scope": "cpp",
        "prefix": [
            "apoc_FracBinarySearch"
        ],
        "body": [
            "/*",
            " * Usage: fracBS([](Frac f) { return f.p>=3*f.q; }, 10); // {1,3}",
            " */",
            "struct Frac { ll p, q; };",
            "",
            "template<class F>",
            "Frac fracBS(F f, ll N) {",
            "\tbool dir = 1, A = 1, B = 1;",
            "\tFrac lo{0, 1}, hi{1, 1}; // Set hi to 1/0 to search (0, N]",
            "\tif (f(lo)) return lo;",
            "\tassert(f(hi));",
            "\twhile (A || B) {",
            "\t\tll adv = 0, step = 1; // move hi if dir, else lo",
            "\t\tfor (int si = 0; step; (step *= 2) >>= si) {",
            "\t\t\tadv += step;",
            "\t\t\tFrac mid{lo.p * adv + hi.p, lo.q * adv + hi.q};",
            "\t\t\tif (abs(mid.p) > N || mid.q > N || dir == !f(mid)) {",
            "\t\t\t\tadv -= step; si = 2;",
            "\t\t\t}",
            "\t\t}",
            "\t\thi.p += lo.p * adv;",
            "\t\thi.q += lo.q * adv;",
            "\t\tdir = !dir;",
            "\t\tswap(lo, hi);",
            "\t\tA = B; B = !!adv;",
            "\t}",
            "\treturn dir ? hi : lo;",
            "}"
        ],
        "description": "O(\\log(N)) | Given f and N, finds the smallest fraction p/q in [0, 1] such that f(p/q) is true, and p, q \\le N. You may want to throw an exception from f if it finds an exact solution, in which case N can be removed."
    },
    "ModularArithmetic": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModularArithmetic"
        ],
        "body": [
            "const ll mod = 17; // change to something else",
            "struct Mod {",
            "\tll x;",
            "\tMod(ll xx) : x(xx) {}",
            "\tMod operator+(Mod b) { return Mod((x + b.x) % mod); }",
            "\tMod operator-(Mod b) { return Mod((x - b.x + mod) % mod); }",
            "\tMod operator*(Mod b) { return Mod((x * b.x) % mod); }",
            "\tMod operator/(Mod b) { return *this * invert(b); }",
            "\tMod invert(Mod a) {",
            "\t\tll x, y, g = euclid(a.x, mod, x, y);",
            "\t\tassert(g == 1); return Mod((x + mod) % mod);",
            "\t}",
            "\tMod operator^(ll e) {",
            "\t\tif (!e) return Mod(1);",
            "\t\tMod r = *this ^ (e / 2); r = r * r;",
            "\t\treturn e&1 ? *this * r : r;",
            "\t}",
            "};"
        ],
        "description": "Operators for modular arithmetic. You need to set {tt mod} to some number first and then you can use the structure. /"
    },
    "ModInverse": {
        "scope": "cpp",
        "prefix": [
            "apoc_ModInverse"
        ],
        "body": [
            "// const ll mod = 1000000007, LIM = 200000; ///include-line",
            "ll* inv = new ll[LIM] - 1; inv[1] = 1;",
            "rep(i,2,LIM) inv[i] = mod - (mod / i) * inv[mod % i] % mod;"
        ],
        "description": "Pre-computation of modular inverses. Assumes LIM \\le mod and that mod is a prime."
    },
    "LinearSieve": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinearSieve"
        ],
        "body": [
            "const int LIM = 1000000;",
            "vi lp(LIM+1), primes;",
            "",
            "rep(i, 2, LIM + 1) {",
            "\tif (lp[i] == 0) primes.push_back(lp[i] = i);",
            "\tfor (int j = 0; j < sz(primes) && i * primes[j] <= LIM && primes[j] <= lp[i]; ++j)",
            "\t\tlp[i * primes[j]] = primes[j];",
            "}"
        ],
        "description": "O(N) | Finds smallest prime factor of each integer"
    },
    "MinCostMaxFlowDijkstra": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCostMaxFlowDijkstra"
        ],
        "body": [
            "bool findPath(int s, int t) {",
            "\tfill(all(dist), inf);",
            "\tfill(all(seen), 0);",
            "\tdist[s] = 0;",
            "\t__gnu_pbds::priority_queue<pair<ll, int>> pq;",
            "\tvector<decltype(pq)::point_iterator> its(n);",
            "\tpq.push({0, s});",
            "\twhile(!pq.empty()) {",
            "\t\tauto [d, cur] = pq.top(); pq.pop(); d *= -1;",
            "\t\tseen[cur] = 1;",
            "\t\tif(dist[cur] < d) continue;",
            "\t\tfor(int idx: adj[cur]) {",
            "\t\t\tauto [nxt, cap, f, wt] = edges[idx];",
            "\t\t\tll nxtD = d + wt + pi[cur] - pi[nxt];",
            "\t\t\tif(f >= cap || nxtD >= dist[nxt] || seen[nxt]) continue;",
            "\t\t\tdist[nxt] = nxtD;",
            "\t\t\tpar[nxt] = {cur, idx};",
            "\t\t\tif(its[nxt] == pq.end()) its[nxt] = pq.push({-nxtD, nxt});",
            "\t\t\telse pq.modify(its[nxt], {-nxtD, nxt});",
            "\t\t}",
            "\t}",
            "\trep(i, 0, n) pi[i] = min(pi[i] + dist[i], inf);",
            "\treturn seen[t];",
            "}"
        ],
        "description": "If SPFA TLEs, swap the find_path function in MCMF with the one below and in_q with seen. If negative edge weights can occur, initialize pi with the shortest path from the source to each node using Bellman-Ford. Negative weight cycles not supported. /"
    },
    "FloydWarshall": {
        "scope": "cpp",
        "prefix": [
            "apoc_FloydWarshall"
        ],
        "body": [
            "const ll inf = 1LL << 62;",
            "void floydWarshall(vector<vector<ll>>& m) {",
            "\tint n = sz(m);",
            "\trep(i,0,n) m[i][i] = min(m[i][i], 0LL);",
            "\trep(k,0,n) rep(i,0,n) rep(j,0,n)",
            "\t\tif (m[i][k] != inf && m[k][j] != inf) {",
            "\t\t\tauto newDist = max(m[i][k] + m[k][j], -inf);",
            "\t\t\tm[i][j] = min(m[i][j], newDist);",
            "\t\t}",
            "\trep(k,0,n) if (m[k][k] < 0) rep(i,0,n) rep(j,0,n)",
            "\t\tif (m[i][k] != inf && m[k][j] != inf) m[i][j] = -inf;",
            "}"
        ],
        "description": "O(N^3) | Calculates all-pairs shortest path in a directed graph that might have negative edge weights. Input is an distance matrix m, where m[i][j] = texttt{inf} if i and j are not adjacent. As output, m[i][j] is set to the shortest distance between i and j, texttt{inf} if no path, or texttt{-inf} if the path goes through a negative-weight cycle."
    },
    "EulerWalk": {
        "scope": "cpp",
        "prefix": [
            "apoc_EulerWalk"
        ],
        "body": [
            "vi eulerWalk(vector<vector<pii>>& gr, int nedges, int src=0) {",
            "\tint n = sz(gr);",
            "\tvi D(n), its(n), eu(nedges), ret, s = {src};",
            "\tD[src]++; // to allow Euler paths, not just cycles",
            "\twhile (!s.empty()) {",
            "\t\tint x = s.back(), y, e, &it = its[x], end = sz(gr[x]);",
            "\t\tif (it == end){ ret.push_back(x); s.pop_back(); continue; }",
            "\t\ttie(y, e) = gr[x][it++];",
            "\t\tif (!eu[e]) {",
            "\t\t\tD[x]--, D[y]++;",
            "\t\t\teu[e] = 1; s.push_back(y);",
            "\t\t}}",
            "\tfor (int x : D) if (x < 0 || sz(ret) != nedges+1) return {};",
            "\treturn {ret.rbegin(), ret.rend()};",
            "}"
        ],
        "description": "O(V + E) | Eulerian undirected/directed path/cycle algorithm. Input should be a vector of (dest, global edge index), where for undirected graphs, forward/backward edges have the same index. Returns a list of nodes in the Eulerian path/cycle with src at both start and end, or empty list if no cycle/path exists. To get edge indices back, add .second to s and ret."
    },
    "CompressTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_CompressTree"
        ],
        "body": [
            "typedef vector<pair<int, int>> vpi;",
            "vpi compressTree(LCA& lca, const vi& subset) {",
            "\tstatic vi rev; rev.resize(sz(lca.time));",
            "\tvi li = subset, &T = lca.time;",
            "\tauto cmp = [&](int a, int b) { return T[a] < T[b]; };",
            "\tsort(all(li), cmp);",
            "\tint m = sz(li)-1;",
            "\trep(i,0,m) {",
            "\t\tint a = li[i], b = li[i+1];",
            "\t\tli.push_back(lca.lca(a, b));",
            "\t}",
            "\tsort(all(li), cmp);",
            "\tli.erase(unique(all(li)), li.end());",
            "\trep(i,0,sz(li)) rev[li[i]] = i;",
            "\tvpi ret = {pii(0, li[0])};",
            "\trep(i,0,sz(li)-1) {",
            "\t\tint a = li[i], b = li[i+1];",
            "\t\tret.emplace_back(rev[lca.lca(a, b)], b);",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "O(|S| \\log |S|) | Given a rooted tree and a subset S of nodes, compute the minimal subtree that contains all the nodes by adding all (at most |S|-1) pairwise LCA's and compressing edges. Returns a list of (par, orig_index) representing a tree rooted at 0. The root points to itself."
    },
    "HLD": {
        "scope": "cpp",
        "prefix": [
            "apoc_HLD"
        ],
        "body": [
            "template <bool VALS_EDGES> struct HLD {",
            "\tint N, tim = 0;",
            "\tvector<vi> adj;",
            "\tvi par, siz, depth, rt, pos;",
            "\tNode *tree;",
            "\tHLD(vector<vi> adj_)",
            "\t\t: N(sz(adj_)), adj(adj_), par(N, -1), siz(N, 1), depth(N),",
            "\t\t  rt(N),pos(N),tree(new Node(0, N)){ dfsSz(0); dfsHld(0); }",
            "\tvoid dfsSz(int v) {",
            "\t\tif (par[v] != -1) adj[v].erase(find(all(adj[v]), par[v]));",
            "\t\tfor (int& u : adj[v]) {",
            "\t\t\tpar[u] = v, depth[u] = depth[v] + 1;",
            "\t\t\tdfsSz(u);",
            "\t\t\tsiz[v] += siz[u];",
            "\t\t\tif (siz[u] > siz[adj[v][0]]) swap(u, adj[v][0]);",
            "\t\t}",
            "\t}",
            "\tvoid dfsHld(int v) {",
            "\t\tpos[v] = tim++;",
            "\t\tfor (int u : adj[v]) {",
            "\t\t\trt[u] = (u == adj[v][0] ? rt[v] : u);",
            "\t\t\tdfsHld(u);",
            "\t\t}",
            "\t}",
            "\ttemplate <class B> void process(int u, int v, B op) {",
            "\t\tfor (; rt[u] != rt[v]; v = par[rt[v]]) {",
            "\t\t\tif (depth[rt[u]] > depth[rt[v]]) swap(u, v);",
            "\t\t\top(pos[rt[v]], pos[v] + 1);",
            "\t\t}",
            "\t\tif (depth[u] > depth[v]) swap(u, v);",
            "\t\top(pos[u] + VALS_EDGES, pos[v] + 1);",
            "\t}",
            "\tvoid modifyPath(int u, int v, int val) {",
            "\t\tprocess(u, v, [&](int l, int r) { tree->add(l, r, val); });",
            "\t}",
            "\tint queryPath(int u, int v) { // Modify depending on problem",
            "\t\tint res = -1e9;",
            "\t\tprocess(u, v, [&](int l, int r) {",
            "\t\t\t\tres = max(res, tree->query(l, r));",
            "\t\t});",
            "\t\treturn res;",
            "\t}",
            "\tint querySubtree(int v) { // modifySubtree is similar",
            "\t\treturn tree->query(pos[v] + VALS_EDGES, pos[v] + siz[v]);",
            "\t}",
            "};"
        ],
        "description": "O((\\log N)^2) | Decomposes a tree into vertex disjoint heavy paths and light edges such that the path from any leaf to the root contains at most log(n) light edges. Code does additive modifications and max queries, but can support commutative segtree modifications/queries on paths and subtrees. Takes as input the full adjacency list. VALS_EDGES being true means that values are stored in the edges, as opposed to the nodes. All values initialized to the segtree default. Root must be 0."
    },
    "DominatorTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_DominatorTree"
        ],
        "body": [
            "struct DominatorTree {",
            "\tvector<vi> adj, ans; // input edges, edges of dominator tree (directed tree downwards from root)",
            "\tvector<vi> radj, child, sdomChild;",
            "\tvi label, rlabel, sdom, dom;",
            "\tvi par, bes;",
            "\tint co = 0;",
            "\tDominatorTree(int n) {",
            "\t\tn += n;",
            "\t\tadj = ans = radj = child = sdomChild =",
            "\t\t\tvector<vector<int>>(n);",
            "\t\tlabel = rlabel = sdom = dom = par = bes = vector<int>(n);",
            "\t}",
            "\tvoid add_edge(int a, int b) { adj[a].pb(b); }",
            "\tint get(int x) {",
            "\t\tif (par[x] != x) {",
            "\t\t\tint t = get(par[x]);",
            "\t\t\tpar[x] = par[par[x]];",
            "\t\t\tif (sdom[t] < sdom[bes[x]]) bes[x] = t;",
            "\t\t}",
            "\t\treturn bes[x];",
            "\t}",
            "\tvoid dfs(int x) { // create DFS tree",
            "\t\tlabel[x] = ++co;",
            "\t\trlabel[co] = x;",
            "\t\tsdom[co] = par[co] = bes[co] = co;",
            "\t\tfor (auto y : adj[x]) {",
            "\t\t\tif (!label[y]) {",
            "\t\t\t\tdfs(y);",
            "\t\t\t\tchild[label[x]].pb(label[y]);",
            "\t\t\t}",
            "\t\t\tradj[label[y]].pb(label[x]);",
            "\t\t}",
            "\t}",
            "\tvoid init(int root) {",
            "\t\tdfs(root);",
            "\t\tfor (int i = co; i >= 1; --i) {",
            "\t\t\tfor (auto j : radj[i])",
            "\t\t\t\tsdom[i] = min(sdom[i], sdom[get(j)]);",
            "\t\t\tif (i > 1) sdomChild[sdom[i]].pb(i);",
            "\t\t\tfor (auto j : sdomChild[i]) {",
            "\t\t\t\tint k = get(j);",
            "\t\t\t\tif (sdom[j] == sdom[k]) dom[j] = sdom[j];",
            "\t\t\t\telse dom[j] = k;",
            "\t\t\t}",
            "\t\t\tfor (auto j : child[i]) par[j] = i;",
            "\t\t}",
            "\t\tfor (int i = 2; i < co + 1; ++i) {",
            "\t\t\tif (dom[i] != sdom[i]) dom[i] = dom[dom[i]];",
            "\t\t\tans[rlabel[dom[i]]].pb(rlabel[i]);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "O(V+E) | Builds a dominator tree on a DAG. Output tree is in adj, directed down from the root."
    },
    "LinkCutTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_LinkCutTree"
        ],
        "body": [
            "struct Node { // Splay tree. Root's pp contains tree's parent.",
            "\tNode *p = 0, *pp = 0, *c[2];",
            "\tbool flip = 0;",
            "\tNode() { c[0] = c[1] = 0; fix(); }",
            "\tvoid fix() {",
            "\t\tif (c[0]) c[0]->p = this;",
            "\t\tif (c[1]) c[1]->p = this;",
            "\t\t// (+ update sum of subtree elements etc. if wanted)",
            "\t}",
            "\tvoid pushFlip() {",
            "\t\tif (!flip) return;",
            "\t\tflip = 0; swap(c[0], c[1]);",
            "\t\tif (c[0]) c[0]->flip ^= 1;",
            "\t\tif (c[1]) c[1]->flip ^= 1;",
            "\t}",
            "\tint up() { return p ? p->c[1] == this : -1; }",
            "\tvoid rot(int i, int b) {",
            "\t\tint h = i ^ b;",
            "\t\tNode *x = c[i], *y = b == 2 ? x : x->c[h], *z = b ? y : x;",
            "\t\tif ((y->p = p)) p->c[up()] = y;",
            "\t\tc[i] = z->c[i ^ 1];",
            "\t\tif (b < 2) {",
            "\t\t\tx->c[h] = y->c[h ^ 1];",
            "\t\t\tz->c[h ^ 1] = b ? x : this;",
            "\t\t}",
            "\t\ty->c[i ^ 1] = b ? this : x;",
            "\t\tfix(); x->fix(); y->fix();",
            "\t\tif (p) p->fix();",
            "\t\tswap(pp, y->pp);",
            "\t}",
            "\tvoid splay() { /// Splay this up to the root. Always finishes without flip set.",
            "\t\tfor (pushFlip(); p; ) {",
            "\t\t\tif (p->p) p->p->pushFlip();",
            "\t\t\tp->pushFlip(); pushFlip();",
            "\t\t\tint c1 = up(), c2 = p->up();",
            "\t\t\tif (c2 == -1) p->rot(c1, 2);",
            "\t\t\telse p->p->rot(c2, c1 != c2);",
            "\t\t}",
            "\t}",
            "\tNode* first() { /// Return the min element of the subtree rooted at this, splayed to the top.",
            "\t\tpushFlip();",
            "\t\treturn c[0] ? c[0]->first() : (splay(), this);",
            "\t}",
            "};",
            "",
            "struct LinkCut {",
            "\tvector<Node> node;",
            "\tLinkCut(int N) : node(N) {}",
            "",
            "\tvoid link(int u, int v) { // add an edge (u, v)",
            "\t\tassert(!connected(u, v));",
            "\t\tmakeRoot(&node[u]);",
            "\t\tnode[u].pp = &node[v];",
            "\t}",
            "\tvoid cut(int u, int v) { // remove an edge (u, v)",
            "\t\tNode *x = &node[u], *top = &node[v];",
            "\t\tmakeRoot(top); x->splay();",
            "\t\tassert(top == (x->pp ?: x->c[0]));",
            "\t\tif (x->pp) x->pp = 0;",
            "\t\telse {",
            "\t\t\tx->c[0] = top->p = 0;",
            "\t\t\tx->fix();",
            "\t\t}",
            "\t}",
            "\tbool connected(int u, int v) { // are u, v in the same tree?",
            "\t\tNode* nu = access(&node[u])->first();",
            "\t\treturn nu == access(&node[v])->first();",
            "\t}",
            "\tvoid makeRoot(Node* u) { /// Move u to root of represented tree.",
            "\t\taccess(u);",
            "\t\tu->splay();",
            "\t\tif(u->c[0]) {",
            "\t\t\tu->c[0]->p = 0;",
            "\t\t\tu->c[0]->flip ^= 1;",
            "\t\t\tu->c[0]->pp = u;",
            "\t\t\tu->c[0] = 0;",
            "\t\t\tu->fix();",
            "\t\t}",
            "\t}",
            "\tNode* access(Node* u) { /// Move u to root aux tree. Return the root of the root aux tree.",
            "\t\tu->splay();",
            "\t\twhile (Node* pp = u->pp) {",
            "\t\t\tpp->splay(); u->pp = 0;",
            "\t\t\tif (pp->c[1]) {",
            "\t\t\t\tpp->c[1]->p = 0; pp->c[1]->pp = pp; }",
            "\t\t\tpp->c[1] = u; pp->fix(); u = pp;",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "};"
        ],
        "description": "All operations take amortized O(\\log N). | Represents a forest of unrooted trees. You can add and remove edges (as long as the result is still a forest), and check whether two nodes are in the same tree."
    },
    "EdmondsKarp": {
        "scope": "cpp",
        "prefix": [
            "apoc_EdmondsKarp"
        ],
        "body": [
            "template<class T> T edmondsKarp(vector<unordered_map<int, T>>& graph, int source, int sink) {",
            "\tassert(source != sink);",
            "\tT flow = 0;",
            "\tvi par(sz(graph)), q = par;",
            "",
            "\tfor (;;) {",
            "\t\tfill(all(par), -1);",
            "\t\tpar[source] = 0;",
            "\t\tint ptr = 1;",
            "\t\tq[0] = source;",
            "",
            "\t\trep(i,0,ptr) {",
            "\t\t\tint x = q[i];",
            "\t\t\tfor (auto e : graph[x]) {",
            "\t\t\t\tif (par[e.first] == -1 && e.second > 0) {",
            "\t\t\t\t\tpar[e.first] = x;",
            "\t\t\t\t\tq[ptr++] = e.first;",
            "\t\t\t\t\tif (e.first == sink) goto out;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn flow;",
            "out:",
            "\t\tT inc = numeric_limits<T>::max();",
            "\t\tfor (int y = sink; y != source; y = par[y])",
            "\t\t\tinc = min(inc, graph[par[y]][y]);",
            "",
            "\t\tflow += inc;",
            "\t\tfor (int y = sink; y != source; y = par[y]) {",
            "\t\t\tint p = par[y];",
            "\t\t\tif ((graph[p][y] -= inc) <= 0) graph[p].erase(y);",
            "\t\t\tgraph[y][p] += inc;",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "Flow algorithm with guaranteed complexity O(VE^2). To get edge flow values, compare capacities before and after, and take the positive values only."
    },
    "hopcroftKarp": {
        "scope": "cpp",
        "prefix": [
            "apoc_hopcroftKarp"
        ],
        "body": [
            "/*",
            " * Usage: vi btoa(m, -1); hopcroftKarp(g, btoa);",
            " */",
            "bool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {",
            "\tif (A[a] != L) return 0;",
            "\tA[a] = -1;",
            "\tfor (int b : g[a]) if (B[b] == L + 1) {",
            "\t\tB[b] = 0;",
            "\t\tif (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))",
            "\t\t\treturn btoa[b] = a, 1;",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "int hopcroftKarp(vector<vi>& g, vi& btoa) {",
            "\tint res = 0;",
            "\tvi A(g.size()), B(btoa.size()), cur, next;",
            "\tfor (;;) {",
            "\t\tfill(all(A), 0);",
            "\t\tfill(all(B), 0);",
            "\t\t/// Find the starting nodes for BFS (i.e. layer 0).",
            "\t\tcur.clear();",
            "\t\tfor (int a : btoa) if(a != -1) A[a] = -1;",
            "\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);",
            "\t\t/// Find all layers using bfs.",
            "\t\tfor (int lay = 1;; lay++) {",
            "\t\t\tbool islast = 0;",
            "\t\t\tnext.clear();",
            "\t\t\tfor (int a : cur) for (int b : g[a]) {",
            "\t\t\t\tif (btoa[b] == -1) {",
            "\t\t\t\t\tB[b] = lay;",
            "\t\t\t\t\tislast = 1;",
            "\t\t\t\t}",
            "\t\t\t\telse if (btoa[b] != a && !B[b]) {",
            "\t\t\t\t\tB[b] = lay;",
            "\t\t\t\t\tnext.push_back(btoa[b]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (islast) break;",
            "\t\t\tif (next.empty()) return res;",
            "\t\t\tfor (int a : next) A[a] = lay;",
            "\t\t\tcur.swap(next);",
            "\t\t}",
            "\t\t/// Use DFS to scan for augmenting paths.",
            "\t\trep(a,0,sz(g))",
            "\t\t\tres += dfs(a, 0, g, btoa, A, B);",
            "\t}",
            "}"
        ],
        "description": "O(sqrt{V}E) | Fast bipartite matching algorithm. Graph g should be a list of neighbors of the left partition, and btoa should be a vector full of -1's of the same size as the right partition. Returns the size of the matching. btoa[i] will be the match for vertex i on the right side, or -1 if it's not matched."
    },
    "BellmanFord": {
        "scope": "cpp",
        "prefix": [
            "apoc_BellmanFord"
        ],
        "body": [
            "const ll inf = LLONG_MAX;",
            "struct Ed { int a, b, w, s() { return a < b ? a : -a; }};",
            "struct Node { ll dist = inf; int prev = -1; };",
            "",
            "void bellmanFord(vector<Node>& nodes, vector<Ed>& eds, int s) {",
            "\tnodes[s].dist = 0;",
            "\tsort(all(eds), [](Ed a, Ed b) { return a.s() < b.s(); });",
            "",
            "\tint lim = sz(nodes) / 2 + 2; // /3+100 with shuffled vertices",
            "\trep(i,0,lim) for (Ed ed : eds) {",
            "\t\tNode cur = nodes[ed.a], &dest = nodes[ed.b];",
            "\t\tif (abs(cur.dist) == inf) continue;",
            "\t\tll d = cur.dist + ed.w;",
            "\t\tif (d < dest.dist) {",
            "\t\t\tdest.prev = ed.a;",
            "\t\t\tdest.dist = (i < lim-1 ? d : -inf);",
            "\t\t}",
            "\t}",
            "\trep(i,0,lim) for (Ed e : eds) {",
            "\t\tif (nodes[e.a].dist == -inf)",
            "\t\t\tnodes[e.b].dist = -inf;",
            "\t}",
            "}"
        ],
        "description": "O(VE) | Calculates shortest paths from s in a graph that might have negative edge weights. Unreachable nodes get dist = inf; nodes reachable through negative-weight cycles get dist = -inf. Assumes V^2 max |w_i| < tilde{} 2^{63}."
    },
    "GeneralMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_GeneralMatching"
        ],
        "body": [
            "vector<pii> generalMatching(int N, vector<pii>& ed) {",
            "\tvector<vector<ll>> mat(N, vector<ll>(N)), A;",
            "\tfor (pii pa : ed) {",
            "\t\tint a = pa.first, b = pa.second, r = rand() % mod;",
            "\t\tmat[a][b] = r, mat[b][a] = (mod - r) % mod;",
            "\t}",
            "",
            "\tint r = matInv(A = mat), M = 2*N - r, fi, fj;",
            "\tassert(r % 2 == 0);",
            "",
            "\tif (M != N) do {",
            "\t\tmat.resize(M, vector<ll>(M));",
            "\t\trep(i,0,N) {",
            "\t\t\tmat[i].resize(M);",
            "\t\t\trep(j,N,M) {",
            "\t\t\t\tint r = rand() % mod;",
            "\t\t\t\tmat[i][j] = r, mat[j][i] = (mod - r) % mod;",
            "\t\t\t}",
            "\t\t}",
            "\t} while (matInv(A = mat) != M);",
            "",
            "\tvi has(M, 1); vector<pii> ret;",
            "\trep(it,0,M/2) {",
            "\t\trep(i,0,M) if (has[i])",
            "\t\t\trep(j,i+1,M) if (A[i][j] && mat[i][j]) {",
            "\t\t\t\tfi = i; fj = j; goto done;",
            "\t\t} assert(0); done:",
            "\t\tif (fj < N) ret.emplace_back(fi, fj);",
            "\t\thas[fi] = has[fj] = 0;",
            "\t\trep(sw,0,2) {",
            "\t\t\tll a = modpow(A[fi][fj], mod-2);",
            "\t\t\trep(i,0,M) if (has[i] && A[i][fj]) {",
            "\t\t\t\tll b = A[i][fj] * a % mod;",
            "\t\t\t\trep(j,0,M) A[i][j] = (A[i][j] - A[fi][j] * b) % mod;",
            "\t\t\t}",
            "\t\t\tswap(fi,fj);",
            "\t\t}",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "O(N^3) | Matching for general graphs. Fails with probability N / mod."
    },
    "MinCostMaxFlow": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCostMaxFlow"
        ],
        "body": [
            "struct mcmf {",
            "    const ll inf = LLONG_MAX >> 2;",
            "    struct edge {",
            "        int v;",
            "        ll cap, flow, cost;",
            "    };",
            "    int n;",
            "    vector<edge> edges;",
            "    vvi adj; vii par; vi in_q;",
            "    vector<ll> dist, pi;",
            "    mcmf(int n): n(n), adj(n), dist(n), pi(n), par(n), in_q(n) {}",
            "    void add_edge(int u, int v, ll cap, ll cost) {",
            "        int idx = sz(edges);",
            "        edges.push_back({v, cap, 0, cost});",
            "        edges.push_back({u, cap, cap, -cost});",
            "        adj[u].push_back(idx);",
            "        adj[v].push_back(idx ^ 1);",
            "    }",
            "    bool find_path(int s, int t) {",
            "        fill(all(dist), inf);",
            "        fill(all(in_q), 0);",
            "        queue<int> q; q.push(s);",
            "        dist[s] = 0, in_q[s] = 1;",
            "        while(!q.empty()) {",
            "            int cur = q.front(); q.pop();",
            "            in_q[cur] = 0;",
            "            for(int idx: adj[cur]) {",
            "                auto [nxt, cap, fl, wt] = edges[idx];",
            "                ll nxtD = dist[cur] + wt;",
            "                if(fl >= cap || nxtD >= dist[nxt]) continue;",
            "                dist[nxt] = nxtD;",
            "                par[nxt] = {cur, idx};",
            "                if(in_q[nxt]) continue;",
            "                q.push(nxt); in_q[nxt] = 1;",
            "            }",
            "        }",
            "",
            "        return dist[t] < inf;",
            "    }",
            "    pair<ll, ll> calc(int s, int t) {",
            "        ll flow = 0, cost = 0;",
            "        while(find_path(s, t)) {",
            "            rep(i, 0, n) pi[i] = min(pi[i] + dist[i], inf);",
            "            ll f = inf;",
            "            for(int i, u, v = t; tie(u, i) = par[v], v != s; v = u)",
            "                f = min(f, edges[i].cap - edges[i].flow);",
            "            flow += f;",
            "            for(int i, u, v = t; tie(u, i) = par[v], v != s; v = u)",
            "                edges[i].flow += f, edges[i^1].flow -= f;",
            "        }",
            "        rep(i, 0, sz(edges)>>1)",
            "            cost += edges[i<<1].cost * edges[i<<1].flow;",
            "",
            "        return {flow, cost};",
            "    }",
            "};"
        ],
        "description": "Approximately O(E^2), actually O(FS) where S is the time complexity of the SSSP alg used in find path (in this case SPFA) / | Min-cost max-flow. Negative cost cycles not supported. To obtain the actual flow, look at positive values only."
    },
    "BinaryLifting": {
        "scope": "cpp",
        "prefix": [
            "apoc_BinaryLifting"
        ],
        "body": [
            "vector<vi> treeJump(vi& P){",
            "\tint on = 1, d = 1;",
            "\twhile(on < sz(P)) on *= 2, d++;",
            "\tvector<vi> jmp(d, P);",
            "\trep(i,1,d) rep(j,0,sz(P))",
            "\t\tjmp[i][j] = jmp[i-1][jmp[i-1][j]];",
            "\treturn jmp;",
            "}",
            "",
            "int jmp(vector<vi>& tbl, int nod, int steps){",
            "\trep(i,0,sz(tbl))",
            "\t\tif(steps&(1<<i)) nod = tbl[i][nod];",
            "\treturn nod;",
            "}",
            "",
            "int lca(vector<vi>& tbl, vi& depth, int a, int b) {",
            "\tif (depth[a] < depth[b]) swap(a, b);",
            "\ta = jmp(tbl, a, depth[a] - depth[b]);",
            "\tif (a == b) return a;",
            "\tfor (int i = sz(tbl); i--;) {",
            "\t\tint c = tbl[i][a], d = tbl[i][b];",
            "\t\tif (c != d) a = c, b = d;",
            "\t}",
            "\treturn tbl[0][a];",
            "}"
        ],
        "description": "construction O(N \\log N), queries O(\\log N) | Calculate power of two jumps in a tree, to support fast upward jumps and LCAs. Assumes the root node points to itself."
    },
    "CentroidDecomp": {
        "scope": "cpp",
        "prefix": [
            "apoc_CentroidDecomp"
        ],
        "body": [
            "/*",
            " * Usage: centroidDecomp(adj, [\\&] (int root, vector<int>\\& isIn) { ... });",
            "\tall nodes with isIn[i] = 1 connected to root are part of root's centroid",
            " */",
            "template<class G, class F>",
            "void centroidDecomp(G g, F f) {",
            "\tvi s(sz(g), 1), par(sz(g)), is(s);",
            "\tauto go = [&] (int u, int p, auto& go) -> void {",
            "\t\tif ((par[u] = p) != -1) g[u].erase(find(all(g[u]), p));",
            "\t\tfor (int v : g[u]) go(v, u, go), s[u] += s[v];",
            "\t};",
            "\tgo(0, -1, go); queue<int> q({0});",
            "\twhile (sz(q)) {",
            "\t\tint x = q.front(), b = x, ss, c; q.pop();",
            "\t\tdo for(int v : g[c = b]) if(s[v] > s[x]/2) b = v;",
            "\t\t\twhile(c != b);",
            "\t\tf(c, is);",
            "\t\tis[c] = 0, ss = s[c];",
            "\t\tfor (int v : g[c]) if (s[v] > 0) q.push(v);",
            "\t\tif (c != x) q.push(x);",
            "\t\tdo s[c] -= ss; while ((c = par[c]) != par[x]);",
            "\t}",
            "}"
        ],
        "description": "O(n \\log n) | Computes centroid decomposition on connected tree, and runs callback function"
    },
    "BiconnectedComponents": {
        "scope": "cpp",
        "prefix": [
            "apoc_BiconnectedComponents"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " *  int eid = 0; ed.resize(N);",
            " *  for each edge (a,b) {",
            " *    ed[a].emplace_back(b, eid);",
            " *    ed[b].emplace_back(a, eid++); }",
            " *  bicomps([\\&](const vi\\& edgelist) {...});",
            " */",
            "vi num, st;",
            "vector<vector<pii>> ed;",
            "int Time;",
            "template<class F>",
            "int dfs(int at, int par, F& f) {",
            "\tint me = num[at] = ++Time, e, y, top = me;",
            "\tfor (auto pa : ed[at]) if (pa.second != par) {",
            "\t\ttie(y, e) = pa;",
            "\t\tif (num[y]) {",
            "\t\t\ttop = min(top, num[y]);",
            "\t\t\tif (num[y] < me)",
            "\t\t\t\tst.push_back(e);",
            "\t\t} else {",
            "\t\t\tint si = sz(st);",
            "\t\t\tint up = dfs(y, e, f);",
            "\t\t\ttop = min(top, up);",
            "\t\t\tif (up == me) {",
            "\t\t\t\tst.push_back(e);",
            "\t\t\t\tf(vi(st.begin() + si, st.end()));",
            "\t\t\t\tst.resize(si);",
            "\t\t\t}",
            "\t\t\telse if (up < me) st.push_back(e);",
            "\t\t\telse { /* e is a bridge */ }",
            "\t\t}",
            "\t}",
            "\treturn top;",
            "}",
            "",
            "template<class F>",
            "void bicomps(F f) {",
            "\tnum.assign(sz(ed), 0);",
            "\trep(i,0,sz(ed)) if (!num[i]) dfs(i, -1, f);",
            "}"
        ],
        "description": "O(E + V) | Finds all biconnected components in an undirected graph, and runs a callback for the edges in each. In a biconnected component there are at least two distinct paths between any two nodes. Note that a node can be in several components. An edge which is not in a component is a bridge, i.e., not part of any cycle."
    },
    "LCA": {
        "scope": "cpp",
        "prefix": [
            "apoc_LCA"
        ],
        "body": [
            "struct LCA {",
            "\tint T = 0;",
            "\tvi time, path, ret;",
            "\tRMQ<int> rmq;",
            "",
            "\tLCA(vector<vi>& C) : time(sz(C)), rmq((dfs(C,0,-1), ret)) {}",
            "\tvoid dfs(vector<vi>& C, int v, int par) {",
            "\t\ttime[v] = T++;",
            "\t\tfor (int y : C[v]) if (y != par) {",
            "\t\t\tpath.push_back(v), ret.push_back(time[v]);",
            "\t\t\tdfs(C, y, v);",
            "\t\t}",
            "\t}",
            "",
            "\tint lca(int a, int b) {",
            "\t\tif (a == b) return a;",
            "\t\ttie(a, b) = minmax(time[a], time[b]);",
            "\t\treturn path[rmq.query(a, b)];",
            "\t}",
            "\t//dist(a,b){return depth[a] + depth[b] - 2*depth[lca(a,b)];}",
            "};"
        ],
        "description": "O(N \\log N + Q) | Data structure for computing lowest common ancestors in a tree (with 0 as root). C should be an adjacency list of the tree, either directed or undirected."
    },
    "2sat": {
        "scope": "cpp",
        "prefix": [
            "apoc_2sat"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " *  TwoSat ts(number of boolean variables);",
            " *  ts.either(0, \\tilde3); // Var 0 is true or var 3 is false",
            " *  ts.setValue(2); // Var 2 is true",
            " *  ts.atMostOne({0,\\tilde1,2}); // <= 1 of vars 0, \\tilde1 and 2 are true",
            " *  ts.solve(); // Returns true iff it is solvable",
            " *  ts.values[0..N-1] holds the assigned values to the vars",
            " */",
            "struct TwoSat {",
            "\tint N;",
            "\tvector<vi> gr;",
            "\tvi values; // 0 = false, 1 = true",
            "",
            "\tTwoSat(int n = 0) : N(n), gr(2*n) {}",
            "",
            "\tint addVar() { // (optional)",
            "\t\tgr.emplace_back();",
            "\t\tgr.emplace_back();",
            "\t\treturn N++;",
            "\t}",
            "",
            "\tvoid either(int f, int j) {",
            "\t\tf = max(2*f, -1-2*f);",
            "\t\tj = max(2*j, -1-2*j);",
            "\t\tgr[f].push_back(j^1);",
            "\t\tgr[j].push_back(f^1);",
            "\t}",
            "\tvoid setValue(int x) { either(x, x); }",
            "",
            "\tvoid atMostOne(const vi& li) { // (optional)",
            "\t\tif (sz(li) <= 1) return;",
            "\t\tint cur = ~li[0];",
            "\t\trep(i,2,sz(li)) {",
            "\t\t\tint next = addVar();",
            "\t\t\teither(cur, ~li[i]);",
            "\t\t\teither(cur, next);",
            "\t\t\teither(~li[i], next);",
            "\t\t\tcur = ~next;",
            "\t\t}",
            "\t\teither(cur, ~li[1]);",
            "\t}",
            "",
            "\tvi val, comp, z; int time = 0;",
            "\tint dfs(int i) {",
            "\t\tint low = val[i] = ++time, x; z.push_back(i);",
            "\t\tfor(int e : gr[i]) if (!comp[e])",
            "\t\t\tlow = min(low, val[e] ?: dfs(e));",
            "\t\tif (low == val[i]) do {",
            "\t\t\tx = z.back(); z.pop_back();",
            "\t\t\tcomp[x] = low;",
            "\t\t\tif (values[x>>1] == -1)",
            "\t\t\t\tvalues[x>>1] = x&1;",
            "\t\t} while (x != i);",
            "\t\treturn val[i] = low;",
            "\t}",
            "",
            "\tbool solve() {",
            "\t\tvalues.assign(N, -1);",
            "\t\tval.assign(2*N, 0); comp = val;",
            "\t\trep(i,0,2*N) if (!comp[i]) dfs(i);",
            "\t\trep(i,0,N) if (comp[2*i] == comp[2*i+1]) return 0;",
            "\t\treturn 1;",
            "\t}",
            "};"
        ],
        "description": "O(N+E), where N is the number of boolean variables, and E is the number of clauses. | Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem, so that an expression of the type (a\\|\\|b)&&(!a\\|\\|c)&&(d\\|\\|!b)&&... becomes true, or reports that it is unsatisfiable. Negated variables are represented by bit-inversions (texttt{tilde{}x})."
    },
    "TopSort": {
        "scope": "cpp",
        "prefix": [
            "apoc_TopSort"
        ],
        "body": [
            "vi topoSort(const vector<vi>& gr) {",
            "\tvi indeg(sz(gr)), ret;",
            "\tfor (auto& li : gr) for (int x : li) indeg[x]++;",
            "\tqueue<int> q; // use priority_queue for lexic. largest ans.",
            "\trep(i,0,sz(gr)) if (indeg[i] == 0) q.push(i);",
            "\twhile (!q.empty()) {",
            "\t\tint i = q.front(); // top() for priority queue",
            "\t\tret.push_back(i);",
            "\t\tq.pop();",
            "\t\tfor (int x : gr[i])",
            "\t\t\tif (--indeg[x] == 0) q.push(x);",
            "\t}",
            "\treturn ret;",
            "}"
        ],
        "description": "O(|V|+|E|) | Topological sorting. Given is an oriented graph. Output is an ordering of vertices, such that there are edges only from left to right. If there are cycles, the returned list will have size smaller than n -- nodes reachable from cycles will not be returned."
    },
    "WeightedMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_WeightedMatching"
        ],
        "body": [
            "pair<int, vi> hungarian(const vector<vi> &a) {",
            "\tif (a.empty()) return {0, {}};",
            "\tint n = sz(a) + 1, m = sz(a[0]) + 1;",
            "\tvi u(n), v(m), p(m), ans(n - 1);",
            "\trep(i,1,n) {",
            "\t\tp[0] = i;",
            "\t\tint j0 = 0; // add \"dummy\" worker 0",
            "\t\tvi dist(m, INT_MAX), pre(m, -1);",
            "\t\tvector<bool> done(m + 1);",
            "\t\tdo { // dijkstra",
            "\t\t\tdone[j0] = true;",
            "\t\t\tint i0 = p[j0], j1, delta = INT_MAX;",
            "\t\t\trep(j,1,m) if (!done[j]) {",
            "\t\t\t\tauto cur = a[i0 - 1][j - 1] - u[i0] - v[j];",
            "\t\t\t\tif (cur < dist[j]) dist[j] = cur, pre[j] = j0;",
            "\t\t\t\tif (dist[j] < delta) delta = dist[j], j1 = j;",
            "\t\t\t}",
            "\t\t\trep(j,0,m) {",
            "\t\t\t\tif (done[j]) u[p[j]] += delta, v[j] -= delta;",
            "\t\t\t\telse dist[j] -= delta;",
            "\t\t\t}",
            "\t\t\tj0 = j1;",
            "\t\t} while (p[j0]);",
            "\t\twhile (j0) { // update alternating path",
            "\t\t\tint j1 = pre[j0];",
            "\t\t\tp[j0] = p[j1], j0 = j1;",
            "\t\t}",
            "\t}",
            "\trep(j,1,m) if (p[j]) ans[p[j] - 1] = j - 1;",
            "\treturn {-v[0], ans}; // min cost",
            "}"
        ],
        "description": "O(N^2M) | Given a weighted bipartite graph, matches every node on the left with a node on the right such that no nodes are in two matchings and the sum of the edge weights is minimal. Takes cost[N][M], where cost[i][j] = cost for L[i] to be matched with R[j] and returns (min cost, match), where L[i] is matched with R[match[i]]. Negate costs for max cost. Requires N \\le M."
    },
    "SCC": {
        "scope": "cpp",
        "prefix": [
            "apoc_SCC"
        ],
        "body": [
            "/*",
            " * Usage: scc(graph, [\\&](vi\\& v) { ... }) visits all components",
            " * in reverse topological order. comp[i] holds the component",
            " * index of a node (a component only has edges to components with",
            " * lower index). ncomps will contain the number of components.",
            " */",
            "vi val, comp, z, cont;",
            "int Time, ncomps;",
            "template<class G, class F> int dfs(int j, G& g, F& f) {",
            "\tint low = val[j] = ++Time, x; z.push_back(j);",
            "\tfor (auto e : g[j]) if (comp[e] < 0)",
            "\t\tlow = min(low, val[e] ?: dfs(e,g,f));",
            "",
            "\tif (low == val[j]) {",
            "\t\tdo {",
            "\t\t\tx = z.back(); z.pop_back();",
            "\t\t\tcomp[x] = ncomps;",
            "\t\t\tcont.push_back(x);",
            "\t\t} while (x != j);",
            "\t\tf(cont); cont.clear();",
            "\t\tncomps++;",
            "\t}",
            "\treturn val[j] = low;",
            "}",
            "template<class G, class F> void scc(G& g, F f) {",
            "\tint n = sz(g);",
            "\tval.assign(n, 0); comp.assign(n, -1);",
            "\tTime = ncomps = 0;",
            "\trep(i,0,n) if (comp[i] < 0) dfs(i, g, f);",
            "}"
        ],
        "description": "O(E + V) | Finds strongly connected components in a directed graph. If vertices u, v belong to the same component, we can reach u from v and vice versa."
    },
    "EdgeColoring": {
        "scope": "cpp",
        "prefix": [
            "apoc_EdgeColoring"
        ],
        "body": [
            "vi edgeColoring(int N, vector<pii> eds) {",
            "\tvi cc(N + 1), ret(sz(eds)), fan(N), free(N), loc;",
            "\tfor (pii e : eds) ++cc[e.first], ++cc[e.second];",
            "\tint u, v, ncols = *max_element(all(cc)) + 1;",
            "\tvector<vi> adj(N, vi(ncols, -1));",
            "\tfor (pii e : eds) {",
            "\t\ttie(u, v) = e;",
            "\t\tfan[0] = v;",
            "\t\tloc.assign(ncols, 0);",
            "\t\tint at = u, end = u, d, c = free[u], ind = 0, i = 0;",
            "\t\twhile (d = free[v], !loc[d] && (v = adj[u][d]) != -1)",
            "\t\t\tloc[d] = ++ind, cc[ind] = d, fan[ind] = v;",
            "\t\tcc[loc[d]] = c;",
            "\t\tfor (int cd = d; at != -1; cd ^= c ^ d, at = adj[at][cd])",
            "\t\t\tswap(adj[at][cd], adj[end = at][cd ^ c ^ d]);",
            "\t\twhile (adj[fan[i]][d] != -1) {",
            "\t\t\tint left = fan[i], right = fan[++i], e = cc[i];",
            "\t\t\tadj[u][e] = left;",
            "\t\t\tadj[left][e] = u;",
            "\t\t\tadj[right][e] = -1;",
            "\t\t\tfree[right] = e;",
            "\t\t}",
            "\t\tadj[u][d] = fan[i];",
            "\t\tadj[fan[i]][d] = u;",
            "\t\tfor (int y : {fan[0], u, end})",
            "\t\t\tfor (int& z = free[y] = 0; adj[y][z] != -1; z++);",
            "\t}",
            "\trep(i,0,sz(eds))",
            "\t\tfor (tie(u, v) = eds[i]; adj[u][ret[i]] != v;) ++ret[i];",
            "\treturn ret;",
            "}"
        ],
        "description": "O(NM) | Given a simple, undirected graph with max degree D, computes a (D + 1)-coloring of the edges such that no neighboring edges share a color. (D-coloring is NP-hard, but can be done for bipartite graphs by repeated matchings of max-degree nodes.)"
    },
    "DFSMatching": {
        "scope": "cpp",
        "prefix": [
            "apoc_DFSMatching"
        ],
        "body": [
            "/*",
            " * Usage: vi btoa(m, -1); dfsMatching(g, btoa);",
            " */",
            "bool find(int j, vector<vi>& g, vi& btoa, vi& vis) {",
            "\tif (btoa[j] == -1) return 1;",
            "\tvis[j] = 1; int di = btoa[j];",
            "\tfor (int e : g[di])",
            "\t\tif (!vis[e] && find(e, g, btoa, vis)) {",
            "\t\t\tbtoa[e] = di;",
            "\t\t\treturn 1;",
            "\t\t}",
            "\treturn 0;",
            "}",
            "int dfsMatching(vector<vi>& g, vi& btoa) {",
            "\tvi vis;",
            "\trep(i,0,sz(g)) {",
            "\t\tvis.assign(sz(btoa), 0);",
            "\t\tfor (int j : g[i])",
            "\t\t\tif (find(j, g, btoa, vis)) {",
            "\t\t\t\tbtoa[j] = i;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t}",
            "\treturn sz(btoa) - (int)count(all(btoa), -1);",
            "}"
        ],
        "description": "O(VE) | Simple bipartite matching algorithm. Graph g should be a list of neighbors of the left partition, and btoa should be a vector full of -1's of the same size as the right partition. Returns the size of the matching. btoa[i] will be the match for vertex i on the right side, or -1 if it's not matched."
    },
    "MaximalCliques": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximalCliques"
        ],
        "body": [
            "/// Possible optimization: on the top-most",
            "/// recursion level, ignore 'cands', and go through nodes in order of increasing",
            "/// degree, where degrees go down as nodes are removed.",
            "/// (mostly irrelevant given MaximumClique)",
            "",
            "typedef bitset<128> B;",
            "template<class F>",
            "void cliques(vector<B>& eds, F f, B P = ~B(), B X={}, B R={}) {",
            "\tif (!P.any()) { if (!X.any()) f(R); return; }",
            "\tauto q = (P | X)._Find_first();",
            "\tauto cands = P & ~eds[q];",
            "\trep(i,0,sz(eds)) if (cands[i]) {",
            "\t\tR[i] = 1;",
            "\t\tcliques(eds, f, P & eds[i], X & eds[i], R);",
            "\t\tR[i] = P[i] = 0; X[i] = 1;",
            "\t}",
            "}"
        ],
        "description": "O(3^{n/3}), much faster for sparse graphs | Runs a callback for all maximal cliques in a graph (given as a symmetric bitset matrix; self-edges not allowed). Callback is given a bitset representing the maximal clique."
    },
    "MinimumVertexCover": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinimumVertexCover"
        ],
        "body": [
            "vi cover(vector<vi>& g, int n, int m) {",
            "\tvi match(m, -1);",
            "\tint res = dfsMatching(g, match);",
            "\tvector<bool> lfound(n, true), seen(m);",
            "\tfor (int it : match) if (it != -1) lfound[it] = false;",
            "\tvi q, cover;",
            "\trep(i,0,n) if (lfound[i]) q.push_back(i);",
            "\twhile (!q.empty()) {",
            "\t\tint i = q.back(); q.pop_back();",
            "\t\tlfound[i] = 1;",
            "\t\tfor (int e : g[i]) if (!seen[e] && match[e] != -1) {",
            "\t\t\tseen[e] = true;",
            "\t\t\tq.push_back(match[e]);",
            "\t\t}",
            "\t}",
            "\trep(i,0,n) if (!lfound[i]) cover.push_back(i);",
            "\trep(i,0,m) if (seen[i]) cover.push_back(n+i);",
            "\tassert(sz(cover) == res);",
            "\treturn cover;",
            "}"
        ],
        "description": "Finds a minimum vertex cover in a bipartite graph. The size is the same as the size of a maximum matching, and the complement is a maximum independent set."
    },
    "DirectedMST": {
        "scope": "cpp",
        "prefix": [
            "apoc_DirectedMST"
        ],
        "body": [
            "struct Edge { int a, b; ll w; };",
            "struct Node { /// lazy skew heap node",
            "\tEdge key;",
            "\tNode *l, *r;",
            "\tll delta;",
            "\tvoid prop() {",
            "\t\tkey.w += delta;",
            "\t\tif (l) l->delta += delta;",
            "\t\tif (r) r->delta += delta;",
            "\t\tdelta = 0;",
            "\t}",
            "\tEdge top() { prop(); return key; }",
            "};",
            "Node *merge(Node *a, Node *b) {",
            "\tif (!a || !b) return a ?: b;",
            "\ta->prop(), b->prop();",
            "\tif (a->key.w > b->key.w) swap(a, b);",
            "\tswap(a->l, (a->r = merge(b, a->r)));",
            "\treturn a;",
            "}",
            "void pop(Node*& a) { a->prop(); a = merge(a->l, a->r); }",
            "",
            "pair<ll, vi> dmst(int n, int r, vector<Edge>& g) {",
            "\tRollbackUF uf(n);",
            "\tvector<Node*> heap(n);",
            "\tfor (Edge e : g) heap[e.b] = merge(heap[e.b], new Node{e});",
            "\tll res = 0;",
            "\tvi seen(n, -1), path(n), par(n);",
            "\tseen[r] = r;",
            "\tvector<Edge> Q(n), in(n, {-1,-1}), comp;",
            "\tdeque<tuple<int, int, vector<Edge>>> cycs;",
            "\trep(s,0,n) {",
            "\t\tint u = s, qi = 0, w;",
            "\t\twhile (seen[u] < 0) {",
            "\t\t\tif (!heap[u]) return {-1,{}};",
            "\t\t\tEdge e = heap[u]->top();",
            "\t\t\theap[u]->delta -= e.w, pop(heap[u]);",
            "\t\t\tQ[qi] = e, path[qi++] = u, seen[u] = s;",
            "\t\t\tres += e.w, u = uf.find(e.a);",
            "\t\t\tif (seen[u] == s) { /// found cycle, contract",
            "\t\t\t\tNode* cyc = 0;",
            "\t\t\t\tint end = qi, time = uf.time();",
            "\t\t\t\tdo cyc = merge(cyc, heap[w = path[--qi]]);",
            "\t\t\t\twhile (uf.join(u, w));",
            "\t\t\t\tu = uf.find(u), heap[u] = cyc, seen[u] = -1;",
            "\t\t\t\tcycs.push_front({u, time, {&Q[qi], &Q[end]}});",
            "\t\t\t}",
            "\t\t}",
            "\t\trep(i,0,qi) in[uf.find(Q[i].b)] = Q[i];",
            "\t}",
            "",
            "\tfor (auto& [u,t,comp] : cycs) { // restore sol (optional)",
            "\t\tuf.rollback(t);",
            "\t\tEdge inEdge = in[u];",
            "\t\tfor (auto& e : comp) in[uf.find(e.b)] = e;",
            "\t\tin[uf.find(inEdge.b)] = inEdge;",
            "\t}",
            "\trep(i,0,n) par[i] = in[i].a;",
            "\treturn {res, par};",
            "}"
        ],
        "description": "O(E \\log V) | Finds a minimum spanning tree/arborescence of a directed graph, given a root node. If no MST exists, returns -1."
    },
    "PushRelabel": {
        "scope": "cpp",
        "prefix": [
            "apoc_PushRelabel"
        ],
        "body": [
            "struct PushRelabel {",
            "\tstruct Edge {",
            "\t\tint dest, back;",
            "\t\tll f, c;",
            "\t};",
            "\tvector<vector<Edge>> g;",
            "\tvector<ll> ec;",
            "\tvector<Edge*> cur;",
            "\tvector<vi> hs; vi H;",
            "\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}",
            "",
            "\tvoid addEdge(int s, int t, ll cap, ll rcap=0) {",
            "\t\tif (s == t) return;",
            "\t\tg[s].push_back({t, sz(g[t]), 0, cap});",
            "\t\tg[t].push_back({s, sz(g[s])-1, 0, rcap});",
            "\t}",
            "",
            "\tvoid addFlow(Edge& e, ll f) {",
            "\t\tEdge &back = g[e.dest][e.back];",
            "\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);",
            "\t\te.f += f; e.c -= f; ec[e.dest] += f;",
            "\t\tback.f -= f; back.c += f; ec[back.dest] -= f;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tint v = sz(g); H[s] = v; ec[t] = 1;",
            "\t\tvi co(2*v); co[0] = v-1;",
            "\t\trep(i,0,v) cur[i] = g[i].data();",
            "\t\tfor (Edge& e : g[s]) addFlow(e, e.c);",
            "",
            "\t\tfor (int hi = 0;;) {",
            "\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];",
            "\t\t\tint u = hs[hi].back(); hs[hi].pop_back();",
            "\t\t\twhile (ec[u] > 0)  // discharge u",
            "\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {",
            "\t\t\t\t\tH[u] = 1e9;",
            "\t\t\t\t\tfor (Edge& e : g[u]) if (e.c && H[u] > H[e.dest]+1)",
            "\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;",
            "\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)",
            "\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)",
            "\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;",
            "\t\t\t\t\thi = H[u];",
            "\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)",
            "\t\t\t\t\taddFlow(*cur[u], min(ec[u], cur[u]->c));",
            "\t\t\t\telse ++cur[u];",
            "\t\t}",
            "\t}",
            "\tbool leftOfMinCut(int a) { return H[a] >= sz(g); }",
            "};"
        ],
        "description": "O(V^2sqrt E) | Push-relabel using the highest label selection rule and the gap heuristic. Quite fast in practice. To obtain the actual flow, look at positive values only."
    },
    "MinCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinCut"
        ],
        "body": [],
        "description": "After running max-flow, the left side of a min-cut from s to t is given by all vertices reachable from s, only traversing edges with positive residual capacity."
    },
    "GomoryHu": {
        "scope": "cpp",
        "prefix": [
            "apoc_GomoryHu"
        ],
        "body": [
            "typedef array<ll, 3> Edge;",
            "vector<Edge> gomoryHu(int N, vector<Edge> ed) {",
            "\tvector<Edge> tree;",
            "\tvi par(N);",
            "\trep(i,1,N) {",
            "\t\tPushRelabel D(N); // Dinic also works",
            "\t\tfor (Edge t : ed) D.addEdge(t[0], t[1], t[2], t[2]);",
            "\t\ttree.push_back({i, par[i], D.calc(i, par[i])});",
            "\t\trep(j,i+1,N)",
            "\t\t\tif (par[j] == par[i] && D.leftOfMinCut(j)) par[j] = i;",
            "\t}",
            "\treturn tree;",
            "}"
        ],
        "description": "O(V) Flow Computations | Given a list of edges representing an undirected flow graph, returns edges of the Gomory-Hu tree. The max flow between any pair of vertices is given by minimum edge weight along the Gomory-Hu tree path."
    },
    "MaximumIndependentSet": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximumIndependentSet"
        ],
        "body": [],
        "description": "To obtain a maximum independent set of a graph, find a max clique of the complement. If the graph is bipartite, see MinimumVertexCover. /"
    },
    "MaximumClique": {
        "scope": "cpp",
        "prefix": [
            "apoc_MaximumClique"
        ],
        "body": [
            "typedef vector<bitset<200>> vb;",
            "struct Maxclique {",
            "\tdouble limit=0.025, pk=0;",
            "\tstruct Vertex { int i, d=0; };",
            "\ttypedef vector<Vertex> vv;",
            "\tvb e;",
            "\tvv V;",
            "\tvector<vi> C;",
            "\tvi qmax, q, S, old;",
            "\tvoid init(vv& r) {",
            "\t\tfor (auto& v : r) v.d = 0;",
            "\t\tfor (auto& v : r) for (auto j : r) v.d += e[v.i][j.i];",
            "\t\tsort(all(r), [](auto a, auto b) { return a.d > b.d; });",
            "\t\tint mxD = r[0].d;",
            "\t\trep(i,0,sz(r)) r[i].d = min(i, mxD) + 1;",
            "\t}",
            "\tvoid expand(vv& R, int lev = 1) {",
            "\t\tS[lev] += S[lev - 1] - old[lev];",
            "\t\told[lev] = S[lev - 1];",
            "\t\twhile (sz(R)) {",
            "\t\t\tif (sz(q) + R.back().d <= sz(qmax)) return;",
            "\t\t\tq.push_back(R.back().i);",
            "\t\t\tvv T;",
            "\t\t\tfor(auto v:R) if (e[R.back().i][v.i]) T.push_back({v.i});",
            "\t\t\tif (sz(T)) {",
            "\t\t\t\tif (S[lev]++ / ++pk < limit) init(T);",
            "\t\t\t\tint j = 0, mxk = 1, mnk = max(sz(qmax) - sz(q) + 1, 1);",
            "\t\t\t\tC[1].clear(), C[2].clear();",
            "\t\t\t\tfor (auto v : T) {",
            "\t\t\t\t\tint k = 1;",
            "\t\t\t\t\tauto f = [&](int i) { return e[v.i][i]; };",
            "\t\t\t\t\twhile (any_of(all(C[k]), f)) k++;",
            "\t\t\t\t\tif (k > mxk) mxk = k, C[mxk + 1].clear();",
            "\t\t\t\t\tif (k < mnk) T[j++].i = v.i;",
            "\t\t\t\t\tC[k].push_back(v.i);",
            "\t\t\t\t}",
            "\t\t\t\tif (j > 0) T[j - 1].d = 0;",
            "\t\t\t\trep(k,mnk,mxk + 1) for (int i : C[k])",
            "\t\t\t\t\tT[j].i = i, T[j++].d = k;",
            "\t\t\t\texpand(T, lev + 1);",
            "\t\t\t} else if (sz(q) > sz(qmax)) qmax = q;",
            "\t\t\tq.pop_back(), R.pop_back();",
            "\t\t}",
            "\t}",
            "\tvi maxClique() { init(V), expand(V); return qmax; }",
            "\tMaxclique(vb conn) : e(conn), C(sz(e)+1), S(sz(C)), old(S) {",
            "\t\trep(i,0,sz(e)) V.push_back({i});",
            "\t}",
            "};"
        ],
        "description": "Runs in about 1s for n=155 and worst case random graphs (p=.90). Runs faster for sparse graphs. | Quickly finds a maximum clique of a graph (given as symmetric bitset matrix; self-edges not allowed). Can be used to find a maximum independent set by finding a clique of the complement graph."
    },
    "GlobalMinCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_GlobalMinCut"
        ],
        "body": [
            "pair<int, vi> globalMinCut(vector<vi> mat) {",
            "\tpair<int, vi> best = {INT_MAX, {}};",
            "\tint n = sz(mat);",
            "\tvector<vi> co(n);",
            "\trep(i,0,n) co[i] = {i};",
            "\trep(ph,1,n) {",
            "\t\tvi w = mat[0];",
            "\t\tsize_t s = 0, t = 0;",
            "\t\trep(it,0,n-ph) { // O(V^2) -> O(E log V) with prio. queue",
            "\t\t\tw[t] = INT_MIN;",
            "\t\t\ts = t, t = max_element(all(w)) - w.begin();",
            "\t\t\trep(i,0,n) w[i] += mat[t][i];",
            "\t\t}",
            "\t\tbest = min(best, {w[t] - mat[t][t], co[t]});",
            "\t\tco[s].insert(co[s].end(), all(co[t]));",
            "\t\trep(i,0,n) mat[s][i] += mat[t][i];",
            "\t\trep(i,0,n) mat[i][s] = mat[s][i];",
            "\t\tmat[0][t] = INT_MIN;",
            "\t}",
            "\treturn best;",
            "}"
        ],
        "description": "O(V^3) | Find a global minimum cut in an undirected graph, as represented by an adjacency matrix."
    },
    "Dinic": {
        "scope": "cpp",
        "prefix": [
            "apoc_Dinic"
        ],
        "body": [
            "struct Dinic {",
            "\tstruct Edge {",
            "\t\tint to, rev;",
            "\t\tll c, oc;",
            "\t\tll flow() { return max(oc - c, 0LL); } // if you need flows",
            "\t};",
            "\tvi lvl, ptr, q;",
            "\tvector<vector<Edge>> adj;",
            "\tDinic(int n) : lvl(n), ptr(n), q(n), adj(n) {}",
            "\tvoid addEdge(int a, int b, ll c, ll rcap = 0) {",
            "\t\tadj[a].push_back({b, sz(adj[b]), c, c});",
            "\t\tadj[b].push_back({a, sz(adj[a]) - 1, rcap, rcap});",
            "\t}",
            "\tll dfs(int v, int t, ll f) {",
            "\t\tif (v == t || !f) return f;",
            "\t\tfor (int& i = ptr[v]; i < sz(adj[v]); i++) {",
            "\t\t\tEdge& e = adj[v][i];",
            "\t\t\tif (lvl[e.to] == lvl[v] + 1)",
            "\t\t\t\tif (ll p = dfs(e.to, t, min(f, e.c))) {",
            "\t\t\t\t\te.c -= p, adj[e.to][e.rev].c += p;",
            "\t\t\t\t\treturn p;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tll calc(int s, int t) {",
            "\t\tll flow = 0; q[0] = s;",
            "\t\trep(L,0,31) do { // 'int L=30' maybe faster for random data",
            "\t\t\tlvl = ptr = vi(sz(q));",
            "\t\t\tint qi = 0, qe = lvl[s] = 1;",
            "\t\t\twhile (qi < qe && !lvl[t]) {",
            "\t\t\t\tint v = q[qi++];",
            "\t\t\t\tfor (Edge e : adj[v])",
            "\t\t\t\t\tif (!lvl[e.to] && e.c >> (30 - L))",
            "\t\t\t\t\t\tq[qe++] = e.to, lvl[e.to] = lvl[v] + 1;",
            "\t\t\t}",
            "\t\t\twhile (ll p = dfs(s, t, LLONG_MAX)) flow += p;",
            "\t\t} while (lvl[t]);",
            "\t\treturn flow;",
            "\t}",
            "\tbool leftOfMinCut(int a) { return lvl[a] != 0; }",
            "};"
        ],
        "description": "Flow algorithm with complexity O(VE\\log U) where U = max |text{cap}|. O(min(E^{1/2}, V^{2/3})E) if U = 1; O(sqrt{V}E) for bipartite matching."
    },
    "CircleIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleIntersection"
        ],
        "body": [
            "typedef Point<double> P;",
            "bool circleInter(P a,P b,double r1,double r2,pair<P, P>* out) {",
            "\tif (a == b) { assert(r1 != r2); return false; }",
            "\tP vec = b - a;",
            "\tdouble d2 = vec.dist2(), sum = r1+r2, dif = r1-r2,",
            "\t       p = (d2 + r1*r1 - r2*r2)/(d2*2), h2 = r1*r1 - p*p*d2;",
            "\tif (sum*sum < d2 || dif*dif > d2) return false;",
            "\tP mid = a + vec*p, per = vec.perp() * sqrt(fmax(0, h2) / d2);",
            "\treturn true;",
            "}"
        ],
        "description": "Computes the pair of points at which two circles intersect. Returns false in case of no intersection."
    },
    "lineIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_lineIntersection"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * \tauto res = lineInter(s1,e1,s2,e2);",
            " * \tif (res.first == 1)",
            " * \t\tcout << \"intersection point at \" << res.second << endl;",
            " */",
            "\\begin{minipage}{75mm}",
            "If a unique intersection point of the lines going through s1,e1 and s2,e2 exists \\{1, point\\} is returned.",
            "If no intersection point exists \\{0, (0,0)\\} is returned and if infinitely many exists \\{-1, (0,0)\\} is returned.",
            "The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.",
            "Products of three coordinates are used in intermediate steps so watch out for overflow if using int or ll.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/lineIntersection}",
            "\\end{minipage}",
            "",
            "",
            "template<class P>",
            "pair<int, P> lineInter(P s1, P e1, P s2, P e2) {",
            "\tauto d = (e1 - s1).cross(e2 - s2);",
            "\tif (d == 0) // if parallel",
            "\t\treturn {-(s1.cross(e1, s2) == 0), P(0, 0)};",
            "\tauto p = s2.cross(e1, e2), q = s2.cross(e2, s1);",
            "\treturn {1, (s1 * p + e1 * q) / d};",
            "}"
        ],
        "description": "\\"
    },
    "LineHullIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineHullIntersection"
        ],
        "body": [
            "#define cmp(i,j) sgn(dir.perp().cross(poly[(i)%n]-poly[(j)%n]))",
            "#define extr(i) cmp(i + 1, i) >= 0 && cmp(i, i - 1 + n) < 0",
            "template <class P> int extrVertex(vector<P>& poly, P dir) {",
            "\tint n = sz(poly), lo = 0, hi = n;",
            "\tif (extr(0)) return 0;",
            "\twhile (lo + 1 < hi) {",
            "\t\tint m = (lo + hi) / 2;",
            "\t\tif (extr(m)) return m;",
            "\t\tint ls = cmp(lo + 1, lo), ms = cmp(m + 1, m);",
            "\t\t(ls < ms || (ls == ms && ls == cmp(lo, m)) ? hi : lo) = m;",
            "\t}",
            "\treturn lo;",
            "}",
            "",
            "#define cmpL(i) sgn(a.cross(poly[i], b))",
            "template <class P>",
            "array<int, 2> lineHull(P a, P b, vector<P>& poly) {",
            "\tint endA = extrVertex(poly, (a - b).perp());",
            "\tint endB = extrVertex(poly, (b - a).perp());",
            "\tif (cmpL(endA) < 0 || cmpL(endB) > 0)",
            "\t\treturn {-1, -1};",
            "\tarray<int, 2> res;",
            "\trep(i,0,2) {",
            "\t\tint lo = endB, hi = endA, n = sz(poly);",
            "\t\twhile ((lo + 1) % n != hi) {",
            "\t\t\tint m = ((lo + hi + (lo < hi ? 0 : n)) / 2) % n;",
            "\t\t\t(cmpL(m) == cmpL(endB) ? lo : hi) = m;",
            "\t\t}",
            "\t\tres[i] = (lo + !cmpL(hi)) % n;",
            "\t\tswap(endA, endB);",
            "\t}",
            "\tif (res[0] == res[1]) return {res[0], -1};",
            "\tif (!cmpL(res[0]) && !cmpL(res[1]))",
            "\t\tswitch ((res[0] - res[1] + sz(poly) + 1) % sz(poly)) {",
            "\t\t\tcase 0: return {res[0], res[0]};",
            "\t\t\tcase 2: return {res[1], res[1]};",
            "\t\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(\\log n) | Line-convex polygon intersection. The polygon must be ccw and have no collinear points."
    },
    "segDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_segDistance"
        ],
        "body": [
            "template<class P> ld segDist(P s, P e, P p) {",
            "    if(s == e) return (p - s).mag();",
            "    auto d = (e-s).mag2(), t = min(d, max(0.0, (p-s).dot(e-s)));",
            "    return ((p - s)*d - (e - s)*t).mag() / d;",
            "}"
        ],
        "description": "Gets the distance between a point and a segment. /"
    },
    "minkowskiSum": {
        "scope": "cpp",
        "prefix": [
            "apoc_minkowskiSum"
        ],
        "body": [
            "template<class P> vector<P> minkSum(vector<vector<P>> &polys){",
            "    P init(0, 0);",
            "    vector<P> dir;",
            "    for(auto poly: polys) {",
            "        int n = sz(poly);",
            "        if(n == 0)",
            "            continue;",
            "        init = init + poly[0];",
            "        if(n == 1)",
            "            continue;",
            "        rep(i, 0, n)",
            "            dir.push_back(poly[(i+1)%n] - poly[i]);",
            "    }",
            "    if(size(dir) == 0)",
            "        return {init};",
            "    sort(all(dir), [&](P a, P b)->bool {",
            "        bool sideA = a.x > 0 || (a.x == 0 && a.y > 0);",
            "        bool sideB = b.x > 0 || (b.x == 0 && b.y > 0);",
            "        if(sideA != sideB)",
            "            return sideA;",
            "        return a.cross(b) > 0;",
            "    });",
            "    vector<P> sum;",
            "    P cur = init;",
            "    rep(i, 0, sz(dir)) {",
            "        sum.push_back(cur);",
            "        cur = cur + dir[i];",
            "    }",
            "    return sum;",
            "}"
        ],
        "description": "returns the minkowski sum of several polygons"
    },
    "lineDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_lineDistance"
        ],
        "body": [
            "\\begin{minipage}{75mm}",
            "Returns the signed distance between point p and the line containing points a and b. Positive value on left side and negative on right as seen from a towards b. a==b gives nan. P is supposed to be Point<T> or Point3D<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long. Using Point3D will always give a non-negative distance. For Point3D, call .dist on the result of the cross product.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/lineDistance}",
            "\\end{minipage}",
            "",
            "",
            "template<class P>",
            "double lineDist(const P& a, const P& b, const P& p) {",
            "\treturn (double)(b-a).cross(p-a)/(b-a).dist();",
            "}"
        ],
        "description": "\\"
    },
    "segIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_segIntersection"
        ],
        "body": [
            "/*",
            " * Usage: Returns a vector of points. If no points, there is no intersection. If 1 point, the segments intersect at a distinct point. If 2 points, the segments intersect at a segment of points, where the 2 points are the end points.",
            " */",
            "template<class P> vector<P> segInter(P s1, P e1, P s2, P e2) {",
            "    if(doSegInter(s1, e1, s2, e2)) return {lineInter(s1, e1, s2, e2)};",
            "\tset<P> seg;",
            "    if(onSeg(s1, e1, s2)) seg.insert(s2);",
            "    if(onSeg(s1, e1, e2)) seg.insert(e2);",
            "    if(onSeg(s2, e2, s1)) seg.insert(s1);",
            "    if(onSeg(s2, e2, e1)) seg.insert(e1);",
            "    return {all(seg)};",
            "}"
        ],
        "description": "Returns the intersection point of two segments."
    },
    "3dHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_3dHull"
        ],
        "body": [
            "typedef Point3D<double> P3;",
            "",
            "struct PR {",
            "\tvoid ins(int x) { (a == -1 ? a : b) = x; }",
            "\tvoid rem(int x) { (a == x ? a : b) = -1; }",
            "\tint cnt() { return (a != -1) + (b != -1); }",
            "\tint a, b;",
            "};",
            "",
            "struct F { P3 q; int a, b, c; };",
            "",
            "vector<F> hull3d(const vector<P3>& A) {",
            "\tassert(sz(A) >= 4);",
            "\tvector<vector<PR>> E(sz(A), vector<PR>(sz(A), {-1, -1}));",
            "#define E(x,y) E[f.x][f.y]",
            "\tvector<F> FS;",
            "\tauto mf = [&](int i, int j, int k, int l) {",
            "\t\tP3 q = (A[j] - A[i]).cross((A[k] - A[i]));",
            "\t\tif (q.dot(A[l]) > q.dot(A[i]))",
            "\t\t\tq = q * -1;",
            "\t\tF f{q, i, j, k};",
            "\t\tE(a,b).ins(k); E(a,c).ins(j); E(b,c).ins(i);",
            "\t\tFS.push_back(f);",
            "\t};",
            "\trep(i,0,4) rep(j,i+1,4) rep(k,j+1,4)",
            "\t\tmf(i, j, k, 6 - i - j - k);",
            "",
            "\trep(i,4,sz(A)) {",
            "\t\trep(j,0,sz(FS)) {",
            "\t\t\tF f = FS[j];",
            "\t\t\tif(f.q.dot(A[i]) > f.q.dot(A[f.a])) {",
            "\t\t\t\tE(a,b).rem(f.c);",
            "\t\t\t\tE(a,c).rem(f.b);",
            "\t\t\t\tE(b,c).rem(f.a);",
            "\t\t\t\tswap(FS[j--], FS.back());",
            "\t\t\t\tFS.pop_back();",
            "\t\t\t}",
            "\t\t}",
            "\t\tint nw = sz(FS);",
            "\t\trep(j,0,nw) {",
            "\t\t\tF f = FS[j];",
            "#define C(a, b, c) if (E(a,b).cnt() != 2) mf(f.a, f.b, i, f.c);",
            "\t\t\tC(a, b, c); C(a, c, b); C(b, c, a);",
            "\t\t}",
            "\t}",
            "\tfor (F& it : FS) if ((A[it.b] - A[it.a]).cross(",
            "\t\tA[it.c] - A[it.a]).dot(it.q) <= 0) swap(it.c, it.b);",
            "\treturn FS;",
            "};"
        ],
        "description": "O(n^2) | Computes all faces of the 3-dimension hull of a point set.  All faces will point outwards."
    },
    "PolyhedronVolume": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolyhedronVolume"
        ],
        "body": [
            "template<class V, class L>",
            "double signedPolyVolume(const V& p, const L& trilist) {",
            "\tdouble v = 0;",
            "\tfor (auto i : trilist) v += p[i.a].cross(p[i.b]).dot(p[i.c]);",
            "\treturn v / 6;",
            "}"
        ],
        "description": "Magic formula for the volume of a polyhedron. Faces should point outwards."
    },
    "sideOf": {
        "scope": "cpp",
        "prefix": [
            "apoc_sideOf"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * \tbool left = sideOf(p1,p2,q)==1;",
            " */",
            "template<class P>",
            "int sideOf(P s, P e, P p) { return sgn(s.cross(e, p)); }",
            "",
            "template<class P>",
            "int sideOf(const P& s, const P& e, const P& p, double eps) {",
            "\tauto a = (e-s).cross(p-s);",
            "\tdouble l = (e-s).dist()*eps;",
            "\treturn (a > l) - (a < -l);",
            "}"
        ],
        "description": "Returns where p is as seen from s towards e. 1/0/-1 Leftrightarrow left/on line/right. If the optional argument eps is given 0 is returned if p is within distance eps from the line. P is supposed to be Point<T> where T is e.g. double or long long. It uses products in intermediate steps so watch out for overflow if using int or long long."
    },
    "kdTree": {
        "scope": "cpp",
        "prefix": [
            "apoc_kdTree"
        ],
        "body": [
            "typedef long long T;",
            "typedef Point<T> P;",
            "const T INF = numeric_limits<T>::max();",
            "",
            "bool on_x(const P& a, const P& b) { return a.x < b.x; }",
            "bool on_y(const P& a, const P& b) { return a.y < b.y; }",
            "",
            "struct Node {",
            "\tP pt; // if this is a leaf, the single point in it",
            "\tT x0 = INF, x1 = -INF, y0 = INF, y1 = -INF; // bounds",
            "\tNode *first = 0, *second = 0;",
            "",
            "\tT distance(const P& p) { // min squared distance to a point",
            "\t\tT x = (p.x < x0 ? x0 : p.x > x1 ? x1 : p.x);",
            "\t\tT y = (p.y < y0 ? y0 : p.y > y1 ? y1 : p.y);",
            "\t\treturn (P(x,y) - p).dist2();",
            "\t}",
            "",
            "\tNode(vector<P>&& vp) : pt(vp[0]) {",
            "\t\tfor (P p : vp) {",
            "\t\t\tx0 = min(x0, p.x); x1 = max(x1, p.x);",
            "\t\t\ty0 = min(y0, p.y); y1 = max(y1, p.y);",
            "\t\t}",
            "\t\tif (vp.size() > 1) {",
            "\t\t\t// split on x if width >= height (not ideal...)",
            "\t\t\tsort(all(vp), x1 - x0 >= y1 - y0 ? on_x : on_y);",
            "\t\t\t// divide by taking half the array for each child (not",
            "\t\t\t// best performance with many duplicates in the middle)",
            "\t\t\tint half = sz(vp)/2;",
            "\t\t\tfirst = new Node({vp.begin(), vp.begin() + half});",
            "\t\t\tsecond = new Node({vp.begin() + half, vp.end()});",
            "\t\t}",
            "\t}",
            "};",
            "",
            "struct KDTree {",
            "\tNode* root;",
            "\tKDTree(const vector<P>& vp) : root(new Node({all(vp)})) {}",
            "",
            "\tpair<T, P> search(Node *node, const P& p) {",
            "\t\tif (!node->first) {",
            "\t\t\t// uncomment if we should not find the point itself:",
            "\t\t\t// if (p == node->pt) return {INF, P()};",
            "\t\t\treturn make_pair((p - node->pt).dist2(), node->pt);",
            "\t\t}",
            "",
            "\t\tNode *f = node->first, *s = node->second;",
            "\t\tT bfirst = f->distance(p), bsec = s->distance(p);",
            "\t\tif (bfirst > bsec) swap(bsec, bfirst), swap(f, s);",
            "",
            "\t\t// search closest side first, other side if needed",
            "\t\tauto best = search(f, p);",
            "\t\tif (bsec < best.first)",
            "\t\t\tbest = min(best, search(s, p));",
            "\t\treturn best;",
            "\t}",
            "",
            "\t// find nearest point to a point, and its squared distance",
            "\t// (requires an arbitrary operator< for Point)",
            "\tpair<T, P> nearest(const P& p) {",
            "\t\treturn search(root, p);",
            "\t}",
            "};"
        ],
        "description": "KD-tree (2d, can be extended to 3d)"
    },
    "polygonClipping": {
        "scope": "cpp",
        "prefix": [
            "apoc_polygonClipping"
        ],
        "body": [
            "template <class P> vector<P> polyClip(const vector<P>& poly, P s, P e) {",
            "\tvector<P> res;",
            "\trep(i,0,sz(poly)) {",
            "\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();",
            "\t\tbool side = s.cross(e, cur) < 0;",
            "\t\tif (side != (s.cross(e, prev) < 0))",
            "\t\t\tres.push_back(lineInter(s, e, cur, prev).second);",
            "\t\tif (side)",
            "\t\t\tres.push_back(cur);",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "O(n) | Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away."
    },
    "hullDiameter": {
        "scope": "cpp",
        "prefix": [
            "apoc_hullDiameter"
        ],
        "body": [
            "template<class P> pair<P, P> hullDiameter(vector<P> poly){",
            "    int n = sz(poly); if(n < 3) return 0;",
            "    int j = 1;",
            "",
            "    pair<ld, pair<P, P>> ans(0, pair<P, P>(poly[0], poly[0]));",
            "    rep(i, 0, j){",
            "        for(;; j = (j+1)%n){",
            "            ans = max(ans, {(poly[i]-poly[j]).mag2(), {poly[i], poly[j]}});",
            "            if((poly[(j+1)%n] - poly[j]).cross(poly[i+1] - poly[i]) >= 0)",
            "                break;",
            "        }",
            "    }",
            "    return ans.second;",
            "}"
        ],
        "description": "O(n) | Gets the furthest set of points on a convex polygon using rotating calipers"
    },
    "SegmentDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentDistance"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * \tPoint<double> a, b(2,2), p(1,1);",
            " * \tbool onSegment = segDist(a,b,p) < 1e-10;",
            " */",
            "\\begin{minipage}{75mm}",
            "Returns the shortest distance between point p and the line segment from point s to e.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\vspace{-10mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/SegmentDistance}",
            "\\end{minipage}",
            "",
            "",
            "typedef Point<double> P;",
            "double segDist(P& s, P& e, P& p) {",
            "\tif (s==e) return (p-s).dist();",
            "\tauto d = (e-s).dist2(), t = min(d,max(.0,(p-s).dot(e-s)));",
            "\treturn ((p-s)*d-(e-s)*t).dist()/d;",
            "}"
        ],
        "description": "\\"
    },
    "Point": {
        "scope": "cpp",
        "prefix": [
            "apoc_Point"
        ],
        "body": [
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "\ttypedef Point P;",
            "\tT x, y;",
            "\texplicit Point(T x=0, T y=0) : x(x), y(y) {}",
            "\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
            "\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }",
            "\tP operator+(P p) const { return P(x+p.x, y+p.y); }",
            "\tP operator-(P p) const { return P(x-p.x, y-p.y); }",
            "\tP operator*(T d) const { return P(x*d, y*d); }",
            "\tP operator/(T d) const { return P(x/d, y/d); }",
            "\tT dot(P p) const { return x*p.x + y*p.y; }",
            "\tT cross(P p) const { return x*p.y - y*p.x; }",
            "\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }",
            "\tT dist2() const { return x*x + y*y; }",
            "\tdouble dist() const { return sqrt((double)dist2()); }",
            "\t// angle to x-axis in interval [-pi, pi]",
            "\tdouble angle() const { return atan2(y, x); }",
            "\tP unit() const { return *this/dist(); } // makes dist()=1",
            "\tP perp() const { return P(-y, x); } // rotates +90 degrees",
            "\tP normal() const { return perp().unit(); }",
            "\t// returns point rotated 'a' radians ccw around the origin",
            "\tP rotate(double a) const {",
            "\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }",
            "\tfriend ostream& operator<<(ostream& os, P p) {",
            "\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; }",
            "};"
        ],
        "description": "Class to handle points in the plane. T can be e.g. double or long long. (Avoid int.)"
    },
    "MinimumEnclosingCircle": {
        "scope": "cpp",
        "prefix": [
            "apoc_MinimumEnclosingCircle"
        ],
        "body": [
            "pair<P, double> mec(vector<P> ps) {",
            "\tshuffle(all(ps), mt19937(time(0)));",
            "\tP o = ps[0];",
            "\tdouble r = 0, EPS = 1 + 1e-8;",
            "\trep(i,0,sz(ps)) if ((o - ps[i]).dist() > r * EPS) {",
            "\t\to = ps[i], r = 0;",
            "\t\trep(j,0,i) if ((o - ps[j]).dist() > r * EPS) {",
            "\t\t\to = (ps[i] + ps[j]) / 2;",
            "\t\t\tr = (o - ps[i]).dist();",
            "\t\t\trep(k,0,j) if ((o - ps[k]).dist() > r * EPS) {",
            "\t\t\t\to = ccCenter(ps[i], ps[j], ps[k]);",
            "\t\t\t\tr = (o - ps[i]).dist();",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn {o, r};",
            "}"
        ],
        "description": "expected O(n) | Computes the minimum circle that encloses a set of points."
    },
    "centerOfMass": {
        "scope": "cpp",
        "prefix": [
            "apoc_centerOfMass"
        ],
        "body": [
            "template<class P> P polygonCenter(const vector<P>& v) {",
            "\tP res(0, 0); double A = 0;",
            "\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {",
            "\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);",
            "\t\tA += v[j].cross(v[i]);",
            "\t}",
            "\treturn res / A / 3;",
            "}"
        ],
        "description": "O(n) | Returns the center of mass for a polygon."
    },
    "ClosestPair": {
        "scope": "cpp",
        "prefix": [
            "apoc_ClosestPair"
        ],
        "body": [
            "typedef Point<ll> P;",
            "pair<P, P> closest(vector<P> v) {",
            "\tassert(sz(v) > 1);",
            "\tset<P> S;",
            "\tsort(all(v), [](P a, P b) { return a.y < b.y; });",
            "\tpair<ll, pair<P, P>> ret{LLONG_MAX, {P(), P()}};",
            "\tint j = 0;",
            "\tfor (P p : v) {",
            "\t\tP d{1 + (ll)sqrt(ret.first), 0};",
            "\t\twhile (v[j].y <= p.y - d.x) S.erase(v[j++]);",
            "\t\tauto lo = S.lower_bound(p - d), hi = S.upper_bound(p + d);",
            "\t\tfor (; lo != hi; ++lo)",
            "\t\t\tret = min(ret, {(*lo - p).dist2(), {*lo, p}});",
            "\t\tS.insert(p);",
            "\t}",
            "\treturn ret.second;",
            "}"
        ],
        "description": "O(n \\log n) | Finds the closest pair of points."
    },
    "OnSegment": {
        "scope": "cpp",
        "prefix": [
            "apoc_OnSegment"
        ],
        "body": [
            "template<class P> bool onSegment(P s, P e, P p) {",
            "\treturn p.cross(s, e) == 0 && (s - p).dot(e - p) <= 0;",
            "}"
        ],
        "description": "Returns true iff p lies on the line segment from s to e. Use texttt{(segDist(s,e,p)<=epsilon)} instead when using Point<double>."
    },
    "PolygonCut": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonCut"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * \tvector<P> p = ...;",
            " * \tp = polygonCut(p, P(0,0), P(1,0));",
            " */",
            "\\begin{minipage}{75mm}",
            " Returns a vector with the vertices of a polygon with everything to the left of the line going from s to e cut away.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\vspace{-6mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/PolygonCut}",
            "\\vspace{-6mm}",
            "\\end{minipage}",
            "",
            "",
            "typedef Point<double> P;",
            "vector<P> polygonCut(const vector<P>& poly, P s, P e) {",
            "\tvector<P> res;",
            "\trep(i,0,sz(poly)) {",
            "\t\tP cur = poly[i], prev = i ? poly[i-1] : poly.back();",
            "\t\tbool side = s.cross(e, cur) < 0;",
            "\t\tif (side != (s.cross(e, prev) < 0))",
            "\t\t\tres.push_back(lineInter(s, e, cur, prev).second);",
            "\t\tif (side)",
            "\t\t\tres.push_back(cur);",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "\\"
    },
    "CirclePolygonIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_CirclePolygonIntersection"
        ],
        "body": [
            "typedef Point<double> P;",
            "#define arg(p, q) atan2(p.cross(q), p.dot(q))",
            "double circlePoly(P c, double r, vector<P> ps) {",
            "\tauto tri = [&](P p, P q) {",
            "\t\tauto r2 = r * r / 2;",
            "\t\tP d = q - p;",
            "\t\tauto a = d.dot(p)/d.dist2(), b = (p.dist2()-r*r)/d.dist2();",
            "\t\tauto det = a * a - b;",
            "\t\tif (det <= 0) return arg(p, q) * r2;",
            "\t\tauto s = max(0., -a-sqrt(det)), t = min(1., -a+sqrt(det));",
            "\t\tif (t < 0 || 1 <= s) return arg(p, q) * r2;",
            "\t\tP u = p + d * s, v = p + d * t;",
            "\t\treturn arg(p,u) * r2 + u.cross(v)/2 + arg(v,q) * r2;",
            "\t};",
            "\tauto sum = 0.0;",
            "\trep(i,0,sz(ps))",
            "\t\tsum += tri(ps[i] - c, ps[(i + 1) % sz(ps)] - c);",
            "\treturn sum;",
            "}"
        ],
        "description": "O(n) | Returns the area of the intersection of a circle with a ccw polygon."
    },
    "sphericalDistance": {
        "scope": "cpp",
        "prefix": [
            "apoc_sphericalDistance"
        ],
        "body": [
            "double sphericalDistance(double f1, double t1,",
            "\t\tdouble f2, double t2, double radius) {",
            "\tdouble dx = sin(t2)*cos(f2) - sin(t1)*cos(f1);",
            "\tdouble dy = sin(t2)*sin(f2) - sin(t1)*sin(f1);",
            "\tdouble dz = cos(t2) - cos(t1);",
            "\tdouble d = sqrt(dx*dx + dy*dy + dz*dz);",
            "\treturn radius*2*asin(d/2);",
            "}"
        ],
        "description": "Returns the shortest distance on the sphere with radius radius between the points with azimuthal angles (longitude) f1 (phi_1) and f2 (phi_2) from x axis and zenith angles (latitude) t1 (theta_1) and t2 (theta_2) from z axis (0 = north pole). All angles measured in radians. The algorithm starts by converting the spherical coordinates to cartesian coordinates so if that is what you have you can use only the two last rows. dx*radius is then the difference between the two points in the x direction and d*radius is the total distance between the points."
    },
    "Point3D": {
        "scope": "cpp",
        "prefix": [
            "apoc_Point3D"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " */",
            "template<class T> struct Point3D {",
            "\ttypedef Point3D P;",
            "\ttypedef const P& R;",
            "\tT x, y, z;",
            "\texplicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}",
            "\tbool operator<(R p) const {",
            "\t\treturn tie(x, y, z) < tie(p.x, p.y, p.z); }",
            "\tbool operator==(R p) const {",
            "\t\treturn tie(x, y, z) == tie(p.x, p.y, p.z); }",
            "\tP operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }",
            "\tP operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }",
            "\tP operator*(T d) const { return P(x*d, y*d, z*d); }",
            "\tP operator/(T d) const { return P(x/d, y/d, z/d); }",
            "\tT dot(R p) const { return x*p.x + y*p.y + z*p.z; }",
            "\tP cross(R p) const {",
            "\t\treturn P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);",
            "\t}",
            "\tT dist2() const { return x*x + y*y + z*z; }",
            "\tdouble dist() const { return sqrt((double)dist2()); }",
            "\t//Azimuthal angle (longitude) to x-axis in interval [-pi, pi]",
            "\tdouble phi() const { return atan2(y, x); }",
            "\t//Zenith angle (latitude) to the z-axis in interval [0, pi]",
            "\tdouble theta() const { return atan2(sqrt(x*x+y*y),z); }",
            "\tP unit() const { return *this/(T)dist(); } //makes dist()=1",
            "\t//returns unit vector normal to *this and p",
            "\tP normal(P p) const { return cross(p).unit(); }",
            "\t//returns point rotated 'angle' radians ccw around axis",
            "\tP rotate(double angle, P axis) const {",
            "\t\tdouble s = sin(angle), c = cos(angle); P u = axis.unit();",
            "\t\treturn u*dot(u)*(1-c) + (*this)*c - cross(u)*s;",
            "\t}",
            "};"
        ],
        "description": "Class to handle points in 3D space. T can be e.g. double or long long."
    },
    "halfplaneIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_halfplaneIntersection"
        ],
        "body": [
            "const double eps = 1e-8;",
            "typedef Point<double> P;",
            "struct HalfPlane {",
            "    P s, e, d;",
            "    HalfPlane(P s = P(), P e = P()): s(s), e(e), d(e - s) {}",
            "    bool contains(P p) { return d.cross(p - s) > -eps; }",
            "    bool operator<(HalfPlane hp) {",
            "        if(abs(d.x) < eps && abs(hp.d.x) < eps)",
            "            return d.y > 0 && hp.d.y < 0;",
            "        bool side = d.x < eps || (abs(d.x) <= eps && d.y > 0);",
            "        bool sideHp = hp.d.x < eps || (abs(hp.d.x) <= eps && hp.d.y > 0);",
            "        if(side != sideHp) return side;",
            "        return d.cross(hp.d) > 0;",
            "    }",
            "    P inter(HalfPlane hp) {",
            "        auto p = hp.s.cross(e, hp.e), q = hp.s.cross(hp.e, s);",
            "\t    return (s * p + e * q) / d.cross(hp.d);",
            "    }",
            "};",
            "",
            "vector<P> hpIntersection(vector<HalfPlane> hps) {",
            "    sort(all(hps));",
            "    int n = sz(hps), l = 1, r = 0;",
            "    vector<HalfPlane> dq(n+1);",
            "    rep(i, 0, n) {",
            "        while(l < r && !hps[i].contains(dq[r].inter(dq[r-1]))) r--;",
            "        while(l < r && !hps[i].contains(dq[l].inter(dq[l+1]))) l++;",
            "        dq[++r] = hps[i];",
            "        if(l < r && abs(dq[r].d.cross(dq[r-1].d)) < eps) {",
            "            if(dq[r].d.dot(dq[r-1].d) < 0) return {};",
            "            r--;",
            "            if(dq[r].contains(hps[i].s)) dq[r] = hps[i];",
            "        }",
            "    }",
            "    while(l < r - 1 && !dq[l].contains(dq[r].inter(dq[r-1]))) r--;",
            "    while(l < r - 1 && !dq[r].contains(dq[l].inter(dq[l+1]))) l++;",
            "    if(l > r - 2) return {};",
            "    vector<P> poly;",
            "    rep(i, l, r)",
            "        poly.push_back(dq[i].inter(dq[i+1]));",
            "    poly.push_back(dq[r].inter(dq[l]));",
            "    return poly;",
            "}"
        ],
        "description": "O(n \\log n) | Returns the intersection of halfplanes as a polygon"
    },
    "SegmentIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_SegmentIntersection"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * vector<P> inter = segInter(s1,e1,s2,e2);",
            " * if (sz(inter)==1)",
            " *   cout << \"segments intersect at \" << inter[0] << endl;",
            " */",
            "\\begin{minipage}{75mm}",
            "If a unique intersection point between the line segments going from s1 to e1 and from s2 to e2 exists then it is returned.",
            "If no intersection point exists an empty vector is returned. If infinitely many exist a vector with 2 elements is returned, containing the endpoints of the common line segment.",
            "The wrong position will be returned if P is Point<ll> and the intersection point does not have integer coordinates.",
            "Products of three coordinates are used in intermediate steps so watch out for overflow if using int or long long.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/SegmentIntersection}",
            "\\end{minipage}",
            "",
            "",
            "template<class P> vector<P> segInter(P a, P b, P c, P d) {",
            "\tauto oa = c.cross(d, a), ob = c.cross(d, b),",
            "\t     oc = a.cross(b, c), od = a.cross(b, d);",
            "\t// Checks if intersection is single non-endpoint point.",
            "\tif (sgn(oa) * sgn(ob) < 0 && sgn(oc) * sgn(od) < 0)",
            "\t\treturn {(a * ob - b * oa) / (ob - oa)};",
            "\tset<P> s;",
            "\tif (onSegment(c, d, a)) s.insert(a);",
            "\tif (onSegment(c, d, b)) s.insert(b);",
            "\tif (onSegment(a, b, c)) s.insert(c);",
            "\tif (onSegment(a, b, d)) s.insert(d);",
            "\treturn {all(s)};",
            "}"
        ],
        "description": "\\"
    },
    "DelaunayTriangulation": {
        "scope": "cpp",
        "prefix": [
            "apoc_DelaunayTriangulation"
        ],
        "body": [
            "template<class P, class F>",
            "void delaunay(vector<P>& ps, F trifun) {",
            "\tif (sz(ps) == 3) { int d = (ps[0].cross(ps[1], ps[2]) < 0);",
            "\t\ttrifun(0,1+d,2-d); }",
            "\tvector<P3> p3;",
            "\tfor (P p : ps) p3.emplace_back(p.x, p.y, p.dist2());",
            "\tif (sz(ps) > 3) for(auto t:hull3d(p3)) if ((p3[t.b]-p3[t.a]).",
            "\t\t\tcross(p3[t.c]-p3[t.a]).dot(P3(0,0,1)) < 0)",
            "\t\ttrifun(t.a, t.c, t.b);",
            "}"
        ],
        "description": "O(n^2) | Computes the Delaunay triangulation of a set of points. Each circumcircle contains none of the input points. If any three points are collinear or any four are on the same circle, behavior is undefined."
    },
    "ManhattanMST": {
        "scope": "cpp",
        "prefix": [
            "apoc_ManhattanMST"
        ],
        "body": [
            "typedef Point<int> P;",
            "vector<array<int, 3>> manhattanMST(vector<P> ps) {",
            "\tvi id(sz(ps));",
            "\tiota(all(id), 0);",
            "\tvector<array<int, 3>> edges;",
            "\trep(k,0,4) {",
            "\t\tsort(all(id), [&](int i, int j) {",
            "\t\t     return (ps[i]-ps[j]).x < (ps[j]-ps[i]).y;});",
            "\t\tmap<int, int> sweep;",
            "\t\tfor (int i : id) {",
            "\t\t\tfor (auto it = sweep.lower_bound(-ps[i].y);",
            "\t\t\t\t        it != sweep.end(); sweep.erase(it++)) {",
            "\t\t\t\tint j = it->second;",
            "\t\t\t\tP d = ps[i] - ps[j];",
            "\t\t\t\tif (d.y > d.x) break;",
            "\t\t\t\tedges.push_back({d.y + d.x, i, j});",
            "\t\t\t}",
            "\t\t\tsweep[-ps[i].y] = i;",
            "\t\t}",
            "\t\tfor (P& p : ps) if (k & 1) p.x = -p.x; else swap(p.x, p.y);",
            "\t}",
            "\treturn edges;",
            "}"
        ],
        "description": "O(N \\log N) | Given N points, returns up to 4*N edges, which are guaranteed to contain a minimum spanning tree for the graph with edge weights w(p, q) = |p.x - q.x| + |p.y - q.y|. Edges are in the form (distance, src, dst). Use a standard MST algorithm on the result to find the final MST."
    },
    "hullTangents": {
        "scope": "cpp",
        "prefix": [
            "apoc_hullTangents"
        ],
        "body": [
            "#define cmp(i, j) p.cross(h[i], h[j == n ? 0 : j]) * (R ?: -1)",
            "template<bool R, class P> int getTangent(vector<P>& h, P p) {",
            "\tint n = sz(h), lo = 0, hi = n - 1, md;",
            "\tif (cmp(0, 1) >= R && cmp(0, n - 1) >= !R) return 0;",
            "\twhile (md = (lo + hi + 1) / 2, lo < hi) {",
            "\t\tauto a = cmp(md, md + 1), b = cmp(md, lo);",
            "\t\tif (a >= R && cmp(md, md - 1) >= !R) return md;",
            "\t\tif (cmp(lo, lo + 1) < R)",
            "\t\t\ta < R&& b >= 0 ? lo = md : hi = md - 1;",
            "\t\telse a < R || b <= 0 ? lo = md : hi = md - 1;",
            "\t}",
            "\treturn -1; // point strictly inside hull",
            "}",
            "template<class P> pii hullTangents(vector<P>& h, P p) {",
            "\treturn {getTangent<0>(h, p), getTangent<1>(h, p)};",
            "}"
        ],
        "description": "O(\\log n) | Finds the left and right, respectively, tangent points on convex hull from a point. If the point is colinear to side(s) of the polygon, the point further away is returned. Requires ccw, n \\geq 3, and the point be on or outside the polygon."
    },
    "circumcircle": {
        "scope": "cpp",
        "prefix": [
            "apoc_circumcircle"
        ],
        "body": [
            "\\begin{minipage}{75mm}",
            "The circumcirle of a triangle is the circle intersecting all three vertices. ccRadius returns the radius of the circle going through points A, B and C and ccCenter returns the center of the same circle.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\vspace{-2mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/circumcircle}",
            "\\end{minipage}",
            "",
            "",
            "typedef Point<double> P;",
            "double ccRadius(const P& A, const P& B, const P& C) {",
            "\treturn (B-A).dist()*(C-B).dist()*(A-C).dist()/",
            "\t\t\tabs((B-A).cross(C-A))/2;",
            "}",
            "P ccCenter(const P& A, const P& B, const P& C) {",
            "\tP b = C-A, c = B-A;",
            "\treturn A + (b*c.dist2()-c*b.dist2()).perp()/b.cross(c)/2;",
            "}"
        ],
        "description": "\\"
    },
    "InsidePolygon": {
        "scope": "cpp",
        "prefix": [
            "apoc_InsidePolygon"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " * vector<P> v = {P{4,4}, P{1,2}, P{2,1}};",
            " * bool in = inPolygon(v, P{3, 3}, false);",
            " */",
            "template<class P>",
            "bool inPolygon(vector<P> &p, P a, bool strict = true) {",
            "\tint cnt = 0, n = sz(p);",
            "\trep(i,0,n) {",
            "\t\tP q = p[(i + 1) % n];",
            "\t\tif (onSegment(p[i], q, a)) return !strict;",
            "\t\t//or: if (segDist(p[i], q, a) <= eps) return !strict;",
            "\t\tcnt ^= ((a.y<p[i].y) - (a.y<q.y)) * a.cross(p[i], q) > 0;",
            "\t}",
            "\treturn cnt;",
            "}"
        ],
        "description": "O(n) | Returns true if p lies within the polygon. If strict is true, it returns false for points on the boundary. The algorithm uses products in intermediate steps so watch out for overflow."
    },
    "PolygonUnion": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonUnion"
        ],
        "body": [
            "typedef Point<double> P;",
            "double rat(P a, P b) { return sgn(b.x) ? a.x/b.x : a.y/b.y; }",
            "double polyUnion(vector<vector<P>>& poly) {",
            "\tdouble ret = 0;",
            "\trep(i,0,sz(poly)) rep(v,0,sz(poly[i])) {",
            "\t\tP A = poly[i][v], B = poly[i][(v + 1) % sz(poly[i])];",
            "\t\tvector<pair<double, int>> segs = {{0, 0}, {1, 0}};",
            "\t\trep(j,0,sz(poly)) if (i != j) {",
            "\t\t\trep(u,0,sz(poly[j])) {",
            "\t\t\t\tP C = poly[j][u], D = poly[j][(u + 1) % sz(poly[j])];",
            "\t\t\t\tint sc = sideOf(A, B, C), sd = sideOf(A, B, D);",
            "\t\t\t\tif (sc != sd) {",
            "\t\t\t\t\tdouble sa = C.cross(D, A), sb = C.cross(D, B);",
            "\t\t\t\t\tif (min(sc, sd) < 0)",
            "\t\t\t\t\t\tsegs.emplace_back(sa / (sa - sb), sgn(sc - sd));",
            "\t\t\t\t} else if (!sc && !sd && j<i && sgn((B-A).dot(D-C))>0){",
            "\t\t\t\t\tsegs.emplace_back(rat(C - A, B - A), 1);",
            "\t\t\t\t\tsegs.emplace_back(rat(D - A, B - A), -1);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(all(segs));",
            "\t\tfor (auto& s : segs) s.first = min(max(s.first, 0.0), 1.0);",
            "\t\tdouble sum = 0;",
            "\t\tint cnt = segs[0].second;",
            "\t\trep(j,1,sz(segs)) {",
            "\t\t\tif (!cnt) sum += segs[j].first - segs[j - 1].first;",
            "\t\t\tcnt += segs[j].second;",
            "\t\t}",
            "\t\tret += A.cross(B) * sum;",
            "\t}",
            "\treturn ret / 2;",
            "}"
        ],
        "description": "O(N^2), where N is the total number of points | Calculates the area of the union of n polygons (not necessarily convex). The points within each polygon must be given in CCW order. (Epsilon checks may optionally be added to sideOf/sgn, but shouldn't be needed.)"
    },
    "convexHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_convexHull"
        ],
        "body": [
            "template<class P> vector<P> convexHull(vector<P> poly){",
            "    int n = sz(poly);",
            "    vector<P> hull(n+1);",
            "    sort(all(poly));",
            "    int k = 0;",
            "    for(int i = 0; i < n; i++){",
            "        while(k >= 2 && hull[k-2].cross(hull[k-1], poly[i]) <= 0) k--;",
            "        hull[k++] = poly[i];",
            "    }",
            "    for(int i = n-1, t = k+1; i > 0; i--){",
            "        while(k >= t && hull[k-2].cross(hull[k-1], poly[i-1]) <= 0) k--;",
            "        hull[k++] = poly[i-1];",
            "    }",
            "    hull.resize(k-1);",
            "    return hull;",
            "}"
        ],
        "description": "O(n\\log{n}) | gets the smallest convex polygon containing all points using monotone chaining."
    },
    "HullDiameter": {
        "scope": "cpp",
        "prefix": [
            "apoc_HullDiameter"
        ],
        "body": [
            "typedef Point<ll> P;",
            "array<P, 2> hullDiameter(vector<P> S) {",
            "\tint n = sz(S), j = n < 2 ? 0 : 1;",
            "\tpair<ll, array<P, 2>> res({0, {S[0], S[0]}});",
            "\trep(i,0,j)",
            "\t\tfor (;; j = (j + 1) % n) {",
            "\t\t\tres = max(res, {(S[i] - S[j]).dist2(), {S[i], S[j]}});",
            "\t\t\tif ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
            "\t\t\t\tbreak;",
            "\t\t}",
            "\treturn res.second;",
            "}"
        ],
        "description": "O(n) / | Returns the two points with max distance on a convex hull (ccw, no duplicate/collinear points)."
    },
    "CircleLine": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleLine"
        ],
        "body": [
            "template<class P>",
            "vector<P> circleLine(P c, double r, P a, P b) {",
            "\tP ab = b - a, p = a + ab * (c-a).dot(ab) / ab.dist2();",
            "\tdouble s = a.cross(b, c), h2 = r*r - s*s / ab.dist2();",
            "\tif (h2 < 0) return {};",
            "\tif (h2 == 0) return {p};",
            "\tP h = ab.unit() * sqrt(h2);",
            "\treturn {p - h, p + h};",
            "}"
        ],
        "description": "Finds the intersection between a circle and a line. Returns a vector of either 0, 1, or 2 intersection points. P is intended to be Point<double>."
    },
    "linearTransformation": {
        "scope": "cpp",
        "prefix": [
            "apoc_linearTransformation"
        ],
        "body": [
            "\\begin{minipage}{75mm}",
            " Apply the linear transformation (translation, rotation and scaling) which takes line p0-p1 to line q0-q1 to point r.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\vspace{-8mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/linearTransformation}",
            "\\vspace{-2mm}",
            "\\end{minipage}",
            "",
            "",
            "typedef Point<double> P;",
            "P linearTransformation(const P& p0, const P& p1,",
            "\t\tconst P& q0, const P& q1, const P& r) {",
            "\tP dp = p1-p0, dq = q1-q0, num(dp.cross(dq), dp.dot(dq));",
            "\treturn q0 + P((r-p0).cross(num), (r-p0).dot(num))/dp.dist2();",
            "}"
        ],
        "description": "\\"
    },
    "polygonArea": {
        "scope": "cpp",
        "prefix": [
            "apoc_polygonArea"
        ],
        "body": [
            "/*",
            " * Usage: If area is negative, points are given cw, otherwise points are given ccw.",
            " */",
            "template<class T> ld polyArea(vector<pnt<T>> poly) {",
            "    int n = sz(poly); T area = 0;",
            "    for(int i = 0; i < n; i++)",
            "        area += poly[i].cross(poly[(i+1)%n]);",
            "    return area / 2.0L;",
            "}"
        ],
        "description": "O(n) | Uses shoelace theorem to find the area of a polygon."
    },
    "Angle": {
        "scope": "cpp",
        "prefix": [
            "apoc_Angle"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " *  vector<Angle> v = {w[0], w[0].t360() ...}; // sorted",
            " *  int j = 0; rep(i,0,n) { while (v[j] < v[i].t180()) ++j; }",
            " *  // sweeps j such that (j-i) represents the number of positively oriented triangles with vertices at 0 and i",
            " */",
            "struct Angle {",
            "\tint x, y;",
            "\tint t;",
            "\tAngle(int x, int y, int t=0) : x(x), y(y), t(t) {}",
            "\tAngle operator-(Angle b) const { return {x-b.x, y-b.y, t}; }",
            "\tint half() const {",
            "\t\tassert(x || y);",
            "\t\treturn y < 0 || (y == 0 && x < 0);",
            "\t}",
            "\tAngle t90() const { return {-y, x, t + (half() && x >= 0)}; }",
            "\tAngle t180() const { return {-x, -y, t + half()}; }",
            "\tAngle t360() const { return {x, y, t + 1}; }",
            "};",
            "bool operator<(Angle a, Angle b) {",
            "\t// add a.dist2() and b.dist2() to also compare distances",
            "\treturn make_tuple(a.t, a.half(), a.y * (ll)b.x) <",
            "\t       make_tuple(b.t, b.half(), a.x * (ll)b.y);",
            "}",
            "",
            "// Given two points, this calculates the smallest angle between",
            "// them, i.e., the angle that covers the defined line segment.",
            "pair<Angle, Angle> segmentAngles(Angle a, Angle b) {",
            "\tif (b < a) swap(a, b);",
            "\treturn (b < a.t180() ?",
            "\t        make_pair(a, b) : make_pair(b, a.t360()));",
            "}",
            "Angle operator+(Angle a, Angle b) { // point a + vector b",
            "\tAngle r(a.x + b.x, a.y + b.y, a.t);",
            "\tif (a.t180() < r) r.t--;",
            "\treturn r.t180() < a ? r.t360() : r;",
            "}",
            "Angle angleDiff(Angle a, Angle b) { // angle b - angle a",
            "\tint tu = b.t - a.t; a.t = b.t;",
            "\treturn {a.x*b.x + a.y*b.y, a.x*b.y - a.y*b.x, tu - (b < a)};",
            "}"
        ],
        "description": "A class for ordering angles (as represented by int points and a number of rotations around the origin). Useful for rotational sweeping. Sometimes also represents points or vectors."
    },
    "LineProjectionReflection": {
        "scope": "cpp",
        "prefix": [
            "apoc_LineProjectionReflection"
        ],
        "body": [
            "template<class P>",
            "P lineProj(P a, P b, P p, bool refl=false) {",
            "\tP v = b - a;",
            "\treturn p - v.perp()*(1+refl)*v.cross(p-a)/v.dist2();",
            "}"
        ],
        "description": "Projects point p onto line ab. Set refl=true to get reflection of point p across line ab instead. The wrong point will be returned if P is an integer point and the desired point doesn't have integer coordinates. Products of three coordinates are used in intermediate steps so watch out for overflow."
    },
    "doSegIntersection": {
        "scope": "cpp",
        "prefix": [
            "apoc_doSegIntersection"
        ],
        "body": [
            "template<class P> bool doSegInter(P s1, P e1, P s2, P e2) {",
            "    return sideOf(s1, e1, s2) != sideOf(s1, e1, e2) &&",
            "           sideOf(s2, e2, s1) != sideOf(s2, e2, e1);",
            "}"
        ],
        "description": "Checks if two segments intersect (inclusive of intersections at endpoints)"
    },
    "CircleTangents": {
        "scope": "cpp",
        "prefix": [
            "apoc_CircleTangents"
        ],
        "body": [
            "template<class P>",
            "vector<pair<P, P>> tangents(P c1, double r1, P c2, double r2) {",
            "\tP d = c2 - c1;",
            "\tdouble dr = r1 - r2, d2 = d.dist2(), h2 = d2 - dr * dr;",
            "\tif (d2 == 0 || h2 < 0)  return {};",
            "\tvector<pair<P, P>> out;",
            "\tfor (double sign : {-1, 1}) {",
            "\t\tP v = (d * dr + d.perp() * sqrt(h2) * sign) / d2;",
            "\t\tout.push_back({c1 + v * r1, c2 + v * r2});",
            "\t}",
            "\tif (h2 == 0) out.pop_back();",
            "\treturn out;",
            "}"
        ],
        "description": "Finds the external tangents of two circles, or internal if r2 is negated. Can return 0, 1, or 2 tangents -- 0 if one circle contains the other (or overlaps it, in the internal case, or if the circles are the same); 1 if the circles are tangent to each other (in which case .first = .second and the tangent line is perpendicular to the line between the centers). .first and .second give the tangency points at circle 1 and 2 respectively. To find the tangents of a circle with a point set r2 to 0."
    },
    "FastDelaunay": {
        "scope": "cpp",
        "prefix": [
            "apoc_FastDelaunay"
        ],
        "body": [
            "typedef Point<ll> P;",
            "typedef struct Quad* Q;",
            "typedef __int128_t lll; // (can be ll if coords are < 2e4)",
            "P arb(LLONG_MAX,LLONG_MAX); // not equal to any other point",
            "",
            "struct Quad {",
            "\tQ rot, o; P p = arb; bool mark;",
            "\tP& F() { return r()->p; }",
            "\tQ& r() { return rot->rot; }",
            "\tQ prev() { return rot->o->rot; }",
            "\tQ next() { return r()->prev(); }",
            "} *H;",
            "",
            "bool circ(P p, P a, P b, P c) { // is p in the circumcircle?",
            "\tlll p2 = p.dist2(), A = a.dist2()-p2,",
            "\t    B = b.dist2()-p2, C = c.dist2()-p2;",
            "\treturn p.cross(a,b)*C + p.cross(b,c)*A + p.cross(c,a)*B > 0;",
            "}",
            "Q makeEdge(P orig, P dest) {",
            "\tQ r = H ? H : new Quad{new Quad{new Quad{new Quad{0}}}};",
            "\tH = r->o; r->r()->r() = r;",
            "\trep(i,0,4) r = r->rot, r->p = arb, r->o = i & 1 ? r : r->r();",
            "\tr->p = orig; r->F() = dest;",
            "\treturn r;",
            "}",
            "void splice(Q a, Q b) {",
            "\tswap(a->o->rot->o, b->o->rot->o); swap(a->o, b->o);",
            "}",
            "Q connect(Q a, Q b) {",
            "\tQ q = makeEdge(a->F(), b->p);",
            "\tsplice(q, a->next());",
            "\tsplice(q->r(), b);",
            "\treturn q;",
            "}",
            "",
            "pair<Q,Q> rec(const vector<P>& s) {",
            "\tif (sz(s) <= 3) {",
            "\t\tQ a = makeEdge(s[0], s[1]), b = makeEdge(s[1], s.back());",
            "\t\tif (sz(s) == 2) return { a, a->r() };",
            "\t\tsplice(a->r(), b);",
            "\t\tauto side = s[0].cross(s[1], s[2]);",
            "\t\tQ c = side ? connect(b, a) : 0;",
            "\t\treturn {side < 0 ? c->r() : a, side < 0 ? c : b->r() };",
            "\t}",
            "",
            "#define H(e) e->F(), e->p",
            "#define valid(e) (e->F().cross(H(base)) > 0)",
            "\tQ A, B, ra, rb;",
            "\tint half = sz(s) / 2;",
            "\ttie(ra, A) = rec({all(s) - half});",
            "\ttie(B, rb) = rec({sz(s) - half + all(s)});",
            "\twhile ((B->p.cross(H(A)) < 0 && (A = A->next())) ||",
            "\t       (A->p.cross(H(B)) > 0 && (B = B->r()->o)));",
            "\tQ base = connect(B->r(), A);",
            "\tif (A->p == ra->p) ra = base->r();",
            "\tif (B->p == rb->p) rb = base;",
            "",
            "#define DEL(e, init, dir) Q e = init->dir; if (valid(e)) \\",
            "\t\twhile (circ(e->dir->F(), H(base), e->F())) { \\",
            "\t\t\tQ t = e->dir; \\",
            "\t\t\tsplice(e, e->prev()); \\",
            "\t\t\tsplice(e->r(), e->r()->prev()); \\",
            "\t\t\te->o = H; H = e; e = t; \\",
            "\t\t}",
            "\tfor (;;) {",
            "\t\tDEL(LC, base->r(), o);  DEL(RC, base, prev());",
            "\t\tif (!valid(LC) && !valid(RC)) break;",
            "\t\tif (!valid(LC) || (valid(RC) && circ(H(RC), H(LC))))",
            "\t\t\tbase = connect(RC, base->r());",
            "\t\telse",
            "\t\t\tbase = connect(base->r(), LC->r());",
            "\t}",
            "\treturn { ra, rb };",
            "}",
            "",
            "vector<P> triangulate(vector<P> pts) {",
            "\tsort(all(pts));  assert(unique(all(pts)) == pts.end());",
            "\tif (sz(pts) < 2) return {};",
            "\tQ e = rec(pts).first;",
            "\tvector<Q> q = {e};",
            "\tint qi = 0;",
            "\twhile (e->o->F().cross(e->F(), e->p) < 0) e = e->o;",
            "#define ADD { Q c = e; do { c->mark = 1; pts.push_back(c->p); \\",
            "\tq.push_back(c->r()); c = c->next(); } while (c != e); }",
            "\tADD; pts.clear();",
            "\twhile (qi < sz(q)) if (!(e = q[qi++])->mark) ADD;",
            "\treturn pts;",
            "}"
        ],
        "description": "O(n \\log n) | Fast Delaunay triangulation. Each circumcircle contains none of the input points. There must be no duplicate points. If all points are on a line, no triangles will be returned. Should work for doubles as well, though there may be precision issues in 'circ'. Returns triangles in order {t[0][0], t[0][1], t[0][2], t[1][0], dots}, all counter-clockwise."
    },
    "inHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_inHull"
        ],
        "body": [
            "template<class P> bool inHull(const vector<P>& l, P p, bool strict = true) {",
            "\tint a = 1, b = sz(l) - 1, r = !strict;",
            "\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);",
            "\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);",
            "\tif (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)",
            "\t\treturn false;",
            "\twhile (abs(a - b) > 1) {",
            "\t\tint c = (a + b) / 2;",
            "\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;",
            "\t}",
            "\treturn sgn(l[a].cross(l[b], p)) < r;",
            "}"
        ],
        "description": "O(\\log N) / | Determine whether a point t lies inside a convex hull (CCW order, with no collinear points). Returns true if point lies within the hull. If strict is true, points on the boundary aren't included."
    },
    "inPolygon": {
        "scope": "cpp",
        "prefix": [
            "apoc_inPolygon"
        ],
        "body": [
            "/*",
            " * Usage: Returns 0 if outside, 1 if strictly inside, and 2 if on.",
            " */",
            "template<class P> int inPoly(vector<P> poly, P p) {",
            "    bool good = false; int n = sz(poly);",
            "    auto crosses = [](P s, P e, P p) {",
            "        return ((e.y >= p.y) - (s.y >= p.y)) * p.cross(s, e) > 0;",
            "    };",
            "    for(int i = 0; i < n; i++){",
            "        if(onSeg(poly[i], poly[(i+1)%n], p)) return 2;",
            "        good ^= crosses(poly[i], poly[(i+1)%n], p);",
            "    }",
            "    return good;",
            "}"
        ],
        "description": "O(n) | Uses the cutting-ray test to see if a point is inside a polygon."
    },
    "onSeg": {
        "scope": "cpp",
        "prefix": [
            "apoc_onSeg"
        ],
        "body": [
            "template<class P> bool onSeg(P s, P e, P p) {",
            "    return abs(s.cross(e, p)) < eps && (s-p).dot(e-p) < eps;",
            "}"
        ],
        "description": "Returns whether or not a point is on a segment"
    },
    "PolygonCenter": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonCenter"
        ],
        "body": [
            "typedef Point<double> P;",
            "P polygonCenter(const vector<P>& v) {",
            "\tP res(0, 0); double A = 0;",
            "\tfor (int i = 0, j = sz(v) - 1; i < sz(v); j = i++) {",
            "\t\tres = res + (v[i] + v[j]) * v[j].cross(v[i]);",
            "\t\tA += v[j].cross(v[i]);",
            "\t}",
            "\treturn res / A / 3;",
            "}"
        ],
        "description": "O(n) | Returns the center of mass for a polygon."
    },
    "PolygonArea": {
        "scope": "cpp",
        "prefix": [
            "apoc_PolygonArea"
        ],
        "body": [
            "template<class T>",
            "T polygonArea2(vector<Point<T>>& v) {",
            "\tT a = v.back().cross(v[0]);",
            "\trep(i,0,sz(v)-1) a += v[i].cross(v[i+1]);",
            "\treturn a;",
            "}"
        ],
        "description": "Returns twice the signed area of a polygon. Clockwise enumeration gives negative area. Watch out for overflow if using int as T!"
    },
    "ConvexHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_ConvexHull"
        ],
        "body": [
            "\\\\\\begin{minipage}{75mm}",
            "Returns a vector of the points of the convex hull in counter-clockwise order.",
            "Points on the edge of the hull between two other points are not considered part of the hull.",
            "\\end{minipage}",
            "\\begin{minipage}{15mm}",
            "\\vspace{-6mm}",
            "\\includegraphics[width=\\textwidth]{content/geometry/ConvexHull}",
            "\\vspace{-6mm}",
            "\\end{minipage}",
            "*/",
            "",
            "",
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "\tif (sz(pts) <= 1) return pts;",
            "\tsort(all(pts));",
            "\tvector<P> h(sz(pts)+1);",
            "\tint s = 0, t = 0;",
            "\tfor (int it = 2; it--; s = --t, reverse(all(pts)))",
            "\t\tfor (P p : pts) {",
            "\t\t\twhile (t >= s + 2 && h[t-2].cross(h[t-1], p) <= 0) t--;",
            "\t\t\th[t++] = p;",
            "\t\t}",
            "\treturn {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};",
            "}"
        ],
        "description": "O(n \\log n) | "
    },
    "PointInsideHull": {
        "scope": "cpp",
        "prefix": [
            "apoc_PointInsideHull"
        ],
        "body": [
            "/*",
            " * Usage: ",
            " */",
            "typedef Point<ll> P;",
            "",
            "bool inHull(const vector<P>& l, P p, bool strict = true) {",
            "\tint a = 1, b = sz(l) - 1, r = !strict;",
            "\tif (sz(l) < 3) return r && onSegment(l[0], l.back(), p);",
            "\tif (sideOf(l[0], l[a], l[b]) > 0) swap(a, b);",
            "\tif (sideOf(l[0], l[a], p) >= r || sideOf(l[0], l[b], p)<= -r)",
            "\t\treturn false;",
            "\twhile (abs(a - b) > 1) {",
            "\t\tint c = (a + b) / 2;",
            "\t\t(sideOf(l[0], l[c], p) > 0 ? b : a) = c;",
            "\t}",
            "\treturn sgn(l[a].cross(l[b], p)) < r;",
            "}"
        ],
        "description": "O(\\log N) / | Determine whether a point t lies inside a convex hull (CCW order, with no collinear points). Returns true if point lies within the hull. If strict is true, points on the boundary aren't included."
    },
    "multinomial": {
        "scope": "cpp",
        "prefix": [
            "apoc_multinomial"
        ],
        "body": [
            "ll multinomial(vi& v) {",
            "\tll c = 1, m = v.empty() ? 1 : v[0];",
            "\trep(i,1,sz(v)) rep(j,0,v[i])",
            "\t\tc = c * ++m / (j+1);",
            "\treturn c;",
            "}"
        ],
        "description": "Computes displaystyle binom{k_1 + dots + k_n}{k_1, k_2, dots, k_n} = frac{(sum k_i)!}{k_1!k_2!...k_n!}."
    },
    "IntPerm": {
        "scope": "cpp",
        "prefix": [
            "apoc_IntPerm"
        ],
        "body": [
            "int permToInt(vi& v) {",
            "\tint use = 0, i = 0, r = 0;",
            "\tfor(int x:v) r = r * ++i + __builtin_popcount(use & -(1<<x)),",
            "\t\tuse |= 1 << x;                     // (note: minus, not ~!)",
            "\treturn r;",
            "}"
        ],
        "description": "O(n) / | Permutation -> integer conversion. (Not order preserving.) Integer -> permutation can use a lookup table."
    }
}